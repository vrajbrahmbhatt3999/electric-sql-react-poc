import { Transformation, transformFields } from '../conversions/input.js';
class TransactionalDB {
  constructor(_tx, _fields, _converter) {
    this._tx = _tx;
    this._fields = _fields;
    this._converter = _converter;
  }
  withTableSchema(fields) {
    return new TransactionalDB(this._tx, fields, this._converter);
  }
  run(statement, successCallback, errorCallback) {
    const { text, values } = statement.toParam();
    this._tx.run(
      { sql: text, args: values },
      (tx, res) => {
        if (typeof successCallback !== "undefined")
          successCallback(
            new TransactionalDB(tx, this._fields, this._converter),
            res
          );
      },
      errorCallback
    );
  }
  query(statement, schema, successCallback, errorCallback) {
    const { text, values } = statement.toParam();
    this._tx.query(
      { sql: text, args: values },
      (tx, rows) => {
        if (typeof successCallback !== "undefined") {
          const objects = rows.map((row) => {
            const transformedRow = transformFields(
              row,
              this._fields,
              this._converter,
              Transformation.Decode
            );
            return schema.parse(transformedRow);
          });
          successCallback(
            new TransactionalDB(tx, this._fields, this._converter),
            objects
          );
        }
      },
      errorCallback
    );
  }
  raw(sql, successCallback, errorCallback) {
    this._tx.query(
      sql,
      (tx, rows) => {
        if (typeof successCallback !== "undefined") {
          successCallback(
            new TransactionalDB(tx, this._fields, this._converter),
            rows
          );
        }
      },
      errorCallback
    );
  }
}
export {
  TransactionalDB
};
//# sourceMappingURL=transactionalDB.js.map