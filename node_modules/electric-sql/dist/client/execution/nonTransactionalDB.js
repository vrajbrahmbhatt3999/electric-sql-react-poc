import { Transformation, transformFields } from '../conversions/input.js';
class NonTransactionalDB {
  constructor(_adapter, _fields, _converter) {
    this._adapter = _adapter;
    this._fields = _fields;
    this._converter = _converter;
  }
  withTableSchema(fields) {
    return new NonTransactionalDB(this._adapter, fields, this._converter);
  }
  run(statement, successCallback, errorCallback) {
    const { text, values } = statement.toParam();
    this._adapter.run({ sql: text, args: values }).then((res) => {
      if (typeof successCallback !== "undefined") {
        try {
          successCallback(this, res);
        } catch (err) {
          if (typeof errorCallback !== "undefined") {
            errorCallback(err);
          }
        }
      }
    }).catch((err) => {
      if (typeof errorCallback !== "undefined") {
        errorCallback(err);
      }
    });
  }
  query(statement, schema, successCallback, errorCallback) {
    const { text, values } = statement.toParam();
    this._adapter.query({ sql: text, args: values }).then((rows) => {
      try {
        const objects = rows.map((row) => {
          const transformedRow = transformFields(
            row,
            this._fields,
            this._converter,
            Transformation.Decode
          );
          return schema.parse(transformedRow);
        });
        successCallback(this, objects);
      } catch (err) {
        if (typeof errorCallback !== "undefined") {
          errorCallback(err);
        }
      }
    }).catch((err) => {
      if (typeof errorCallback !== "undefined") {
        errorCallback(err);
      }
    });
  }
  raw(sql, successCallback, errorCallback) {
    this._adapter.query(sql).then((rows) => {
      if (typeof successCallback !== "undefined") {
        successCallback(this, rows);
      }
    }).catch((err) => {
      if (typeof errorCallback !== "undefined") {
        errorCallback(err);
      }
    });
  }
}
export {
  NonTransactionalDB
};
//# sourceMappingURL=nonTransactionalDB.js.map