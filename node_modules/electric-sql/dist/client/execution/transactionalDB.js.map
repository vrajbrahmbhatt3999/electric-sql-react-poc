{"version":3,"sources":["../../../src/client/execution/transactionalDB.ts"],"sourcesContent":["import { RunResult, Transaction } from '../../electric/adapter'\nimport { QueryBuilder } from 'squel'\nimport { DB } from './db'\nimport * as z from 'zod'\nimport { Row, Statement } from '../../util'\nimport { Fields } from '../model/schema'\nimport { Transformation, transformFields } from '../conversions/input'\nimport { Converter } from '../conversions/converter'\n\nexport class TransactionalDB implements DB {\n  constructor(\n    private _tx: Transaction,\n    private _fields: Fields,\n    private _converter: Converter\n  ) {}\n\n  withTableSchema(fields: Fields) {\n    return new TransactionalDB(this._tx, fields, this._converter)\n  }\n\n  run(\n    statement: QueryBuilder,\n    successCallback?: (db: DB, res: RunResult) => void,\n    errorCallback?: (error: any) => void\n  ): void {\n    const { text, values } = statement.toParam()\n    this._tx.run(\n      { sql: text, args: values },\n      (tx, res) => {\n        if (typeof successCallback !== 'undefined')\n          successCallback(\n            new TransactionalDB(tx, this._fields, this._converter),\n            res\n          )\n      },\n      errorCallback\n    )\n  }\n\n  query<Z>(\n    statement: QueryBuilder,\n    schema: z.ZodType<Z>,\n    successCallback: (db: DB, res: Z[]) => void,\n    errorCallback?: (error: any) => void\n  ): void {\n    const { text, values } = statement.toParam()\n    this._tx.query(\n      { sql: text, args: values },\n      (tx, rows) => {\n        if (typeof successCallback !== 'undefined') {\n          const objects = rows.map((row) => {\n            // convert SQLite/PG values back to JS values\n            // and then parse the transformed object\n            // with the Zod schema to validate it\n            const transformedRow = transformFields(\n              row,\n              this._fields,\n              this._converter,\n              Transformation.Decode\n            )\n            return schema.parse(transformedRow)\n          })\n          successCallback(\n            new TransactionalDB(tx, this._fields, this._converter),\n            objects\n          )\n        }\n      },\n      errorCallback\n    )\n  }\n\n  raw(\n    sql: Statement,\n    successCallback?: (tx: DB, res: Row[]) => void,\n    errorCallback?: (error: any) => void\n  ) {\n    this._tx.query(\n      sql,\n      (tx, rows) => {\n        if (typeof successCallback !== 'undefined') {\n          successCallback(\n            new TransactionalDB(tx, this._fields, this._converter),\n            rows\n          )\n        }\n      },\n      errorCallback\n    )\n  }\n}\n"],"mappings":"AAMA,SAAS,gBAAgB,uBAAuB;AAGzC,MAAM,gBAA8B;AAAA,EACzC,YACU,KACA,SACA,YACR;AAHQ;AACA;AACA;AAAA,EACP;AAAA,EAEH,gBAAgB,QAAgB;AAC9B,WAAO,IAAI,gBAAgB,KAAK,KAAK,QAAQ,KAAK,UAAU;AAAA,EAC9D;AAAA,EAEA,IACE,WACA,iBACA,eACM;AACN,UAAM,EAAE,MAAM,OAAO,IAAI,UAAU,QAAQ;AAC3C,SAAK,IAAI;AAAA,MACP,EAAE,KAAK,MAAM,MAAM,OAAO;AAAA,MAC1B,CAAC,IAAI,QAAQ;AACX,YAAI,OAAO,oBAAoB;AAC7B;AAAA,YACE,IAAI,gBAAgB,IAAI,KAAK,SAAS,KAAK,UAAU;AAAA,YACrD;AAAA,UACF;AAAA,MACJ;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA,EAEA,MACE,WACA,QACA,iBACA,eACM;AACN,UAAM,EAAE,MAAM,OAAO,IAAI,UAAU,QAAQ;AAC3C,SAAK,IAAI;AAAA,MACP,EAAE,KAAK,MAAM,MAAM,OAAO;AAAA,MAC1B,CAAC,IAAI,SAAS;AACZ,YAAI,OAAO,oBAAoB,aAAa;AAC1C,gBAAM,UAAU,KAAK,IAAI,CAAC,QAAQ;AAIhC,kBAAM,iBAAiB;AAAA,cACrB;AAAA,cACA,KAAK;AAAA,cACL,KAAK;AAAA,cACL,eAAe;AAAA,YACjB;AACA,mBAAO,OAAO,MAAM,cAAc;AAAA,UACpC,CAAC;AACD;AAAA,YACE,IAAI,gBAAgB,IAAI,KAAK,SAAS,KAAK,UAAU;AAAA,YACrD;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA,EAEA,IACE,KACA,iBACA,eACA;AACA,SAAK,IAAI;AAAA,MACP;AAAA,MACA,CAAC,IAAI,SAAS;AACZ,YAAI,OAAO,oBAAoB,aAAa;AAC1C;AAAA,YACE,IAAI,gBAAgB,IAAI,KAAK,SAAS,KAAK,UAAU;AAAA,YACrD;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACF;","names":[]}