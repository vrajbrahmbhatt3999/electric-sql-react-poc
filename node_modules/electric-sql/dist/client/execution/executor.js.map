{"version":3,"sources":["../../../src/client/execution/executor.ts"],"sourcesContent":["import { DatabaseAdapter, RunResult } from '../../electric/adapter'\nimport { QueryBuilder } from 'squel'\nimport { DB } from './db'\nimport { TransactionalDB } from './transactionalDB'\nimport { NonTransactionalDB } from './nonTransactionalDB'\nimport { Notifier } from '../../notifiers'\nimport { Fields } from '../model/schema'\nimport { Converter } from '../conversions/converter'\n\nexport class Executor {\n  constructor(\n    private _adapter: DatabaseAdapter,\n    private _notifier: Notifier,\n    private _fields: Fields,\n    private _converter: Converter\n  ) {}\n\n  async runInTransaction(\n    qs: QueryBuilder[],\n    notify = true\n  ): Promise<RunResult> {\n    const stmts = qs.map((q) => {\n      return { sql: q.toString() }\n    })\n\n    const prom = this._adapter.runInTransaction(...stmts)\n\n    // Fire a potentiallyChanged event when the transaction executed successfully\n    prom.then((_res) => {\n      if (notify) {\n        this._notifier.potentiallyChanged()\n      }\n    })\n\n    return prom\n  }\n\n  // Executes the given function within a transaction\n  // and calls `potentiallyChanged` on the notifier if the `notify` argument is true.\n  async transaction<A>(\n    f: (\n      db: DB,\n      setResult: (res: A) => void,\n      onError: (err: any) => void\n    ) => void,\n    notify = true\n  ): Promise<A> {\n    // We cast the result to `Promise<A>` because we force ourselves to always use `setResult`\n    // and thus the promise will always be resolved with the value that was passed to `setResult` which is of type `A`\n    return (await this._adapter.transaction((tx, setResult) =>\n      f(\n        new TransactionalDB(tx, this._fields, this._converter),\n        (res) => {\n          if (notify) {\n            this._notifier.potentiallyChanged() // inform the notifier that the data may have changed\n          }\n          setResult(res)\n        },\n        () => {\n          // ignore it, errors are already caught by the adapter and will reject the promise\n        }\n      )\n    )) as unknown as Promise<A>\n  }\n\n  // Executes the given function without starting a new transaction\n  // and calls `potentiallyChanged` on the notifier if the `notify` argument is true.\n  async execute<A>(\n    f: (\n      db: DB,\n      setResult: (res: A) => void,\n      onError: (err: any) => void\n    ) => void,\n    notify = true\n  ): Promise<A> {\n    return new Promise((resolve, reject) => {\n      f(\n        new NonTransactionalDB(this._adapter, this._fields, this._converter),\n        (res) => {\n          if (notify) {\n            this._notifier.potentiallyChanged() // inform the notifier that the data may have changed\n          }\n          resolve(res)\n        },\n        reject\n      )\n    })\n  }\n}\n"],"mappings":"AAGA,SAAS,uBAAuB;AAChC,SAAS,0BAA0B;AAK5B,MAAM,SAAS;AAAA,EACpB,YACU,UACA,WACA,SACA,YACR;AAJQ;AACA;AACA;AACA;AAAA,EACP;AAAA,EAEH,MAAM,iBACJ,IACA,SAAS,MACW;AACpB,UAAM,QAAQ,GAAG,IAAI,CAAC,MAAM;AAC1B,aAAO,EAAE,KAAK,EAAE,SAAS,EAAE;AAAA,IAC7B,CAAC;AAED,UAAM,OAAO,KAAK,SAAS,iBAAiB,GAAG,KAAK;AAGpD,SAAK,KAAK,CAAC,SAAS;AAClB,UAAI,QAAQ;AACV,aAAK,UAAU,mBAAmB;AAAA,MACpC;AAAA,IACF,CAAC;AAED,WAAO;AAAA,EACT;AAAA;AAAA;AAAA,EAIA,MAAM,YACJ,GAKA,SAAS,MACG;AAGZ,WAAQ,MAAM,KAAK,SAAS;AAAA,MAAY,CAAC,IAAI,cAC3C;AAAA,QACE,IAAI,gBAAgB,IAAI,KAAK,SAAS,KAAK,UAAU;AAAA,QACrD,CAAC,QAAQ;AACP,cAAI,QAAQ;AACV,iBAAK,UAAU,mBAAmB;AAAA,UACpC;AACA,oBAAU,GAAG;AAAA,QACf;AAAA,QACA,MAAM;AAAA,QAEN;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA,EAIA,MAAM,QACJ,GAKA,SAAS,MACG;AACZ,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC;AAAA,QACE,IAAI,mBAAmB,KAAK,UAAU,KAAK,SAAS,KAAK,UAAU;AAAA,QACnE,CAAC,QAAQ;AACP,cAAI,QAAQ;AACV,iBAAK,UAAU,mBAAmB;AAAA,UACpC;AACA,kBAAQ,GAAG;AAAA,QACb;AAAA,QACA;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AACF;","names":[]}