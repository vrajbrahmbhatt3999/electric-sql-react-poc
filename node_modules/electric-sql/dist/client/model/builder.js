import squel from "squel";
import flow from "lodash.flow";
import { InvalidArgumentError } from '../validation/errors/invalidArgumentError.js';
import * as z from "zod";
import { PgBasicType } from '../conversions/types.js';
import { isFilterObject } from '../conversions/input.js';
import { escDoubleQ } from '../../util/index.js';
const squelPostgres = squel.useFlavour("postgres");
squelPostgres.registerValueHandler("bigint", function(bigint) {
  return bigint.toString();
});
squelPostgres.registerValueHandler(Uint8Array, function(uint8) {
  return uint8;
});
class Builder {
  constructor(_tableName, _fields, _tableDescription, dialect) {
    this._tableName = _tableName;
    this._fields = _fields;
    this._tableDescription = _tableDescription;
    this.dialect = dialect;
    this._quotedTableName = quoteIdentifier(this._tableName);
    squelPostgres.cls.DefaultQueryBuilderOptions.nameQuoteCharacter = '"';
    squelPostgres.cls.DefaultQueryBuilderOptions.autoQuoteFieldNames = true;
    if (dialect === "Postgres") {
      squelPostgres.registerValueHandler(Date, (date) => date);
    } else {
      squelPostgres.cls.DefaultQueryBuilderOptions.numberedParameters = false;
    }
  }
  _quotedTableName;
  create(i) {
    const query = squelPostgres.insert().into(this._quotedTableName).setFields(i.data);
    const queryWithReturn = this.returnAllFields(query);
    return queryWithReturn;
  }
  createMany(i) {
    const insert = squelPostgres.insert().into(this._quotedTableName).setFieldsRows(i.data);
    return i.skipDuplicates ? insert.onConflict() : insert;
  }
  findUnique(i) {
    return this.findWhere({ ...i, take: 2 }, true);
  }
  findFirst(i) {
    return this.findWhere({ ...i, take: 1 });
  }
  findMany(i) {
    return this.findWhere(i);
  }
  // Finds a record but does not select the fields provided in the `where` argument
  // whereas `findUnique`, `findFirst`, and `findMany` also automatically select the fields in `where`
  findWithoutAutoSelect(i) {
    return this.findWhere(i, false, false);
  }
  update(i) {
    return this.updateInternal(i, true);
  }
  updateMany(i) {
    return this.updateInternal(i);
  }
  delete(i) {
    return this.deleteInternal(i, true);
  }
  deleteMany(i) {
    return this.deleteInternal(i);
  }
  deleteInternal(i, idRequired = false) {
    const deleteQuery = squelPostgres.delete().from(this._quotedTableName);
    const whereObject = i.where;
    const fields = this.getFields(whereObject, idRequired);
    return addFilters(fields, whereObject, deleteQuery);
  }
  updateInternal(i, idRequired = false) {
    const unsupportedEntry = Object.entries(i.data).find((entry) => {
      const [_key, value] = entry;
      return isFilterObject(value);
    });
    if (unsupportedEntry)
      throw new InvalidArgumentError(
        `Unsupported value ${JSON.stringify(unsupportedEntry[1])} for field "${unsupportedEntry[0]}" in update query.`
      );
    const query = squelPostgres.update().table(this._quotedTableName).setFields(i.data);
    const queryWithReturn = this.returnAllFields(query);
    const whereObject = i.where;
    const fields = this.getFields(whereObject, idRequired);
    return addFilters(fields, whereObject, queryWithReturn);
  }
  /**
   * Creates a `SELECT fields FROM table WHERE conditions` query.
   * @param i Object containing optional `where` and `selection` fields.
   * @param idRequired If true, will throw an error if no fields are provided in the `where` argument.
   * @param selectWhereFields By default, `findWhere` selects the fields provided in the `where` argument. By providing `false` it will not automatically select those fields.
   */
  findWhere(i, idRequired = false, selectWhereFields = true) {
    if ("cursor" in i && typeof i.cursor !== "undefined") {
      throw new InvalidArgumentError("Unsupported cursor argument.");
    }
    const whereObject = i.where;
    const identificationFields = this.getFields(whereObject, idRequired);
    const query = squelPostgres.select({ autoQuoteFieldNames: false }).from(this._quotedTableName);
    const addFieldSelectionP = this.addFieldSelection.bind(
      this,
      i,
      selectWhereFields ? identificationFields : []
    );
    const addFiltersP = addFilters.bind(null, identificationFields, whereObject);
    const addLimitP = addLimit.bind(null, i);
    const addOffsetP = addOffset.bind(null, i);
    const addDistinctP = addDistinct.bind(null, i);
    const addOrderByP = this.addOrderBy.bind(this, i);
    const buildQuery = flow(
      addFieldSelectionP,
      addFiltersP,
      addLimitP,
      addOffsetP,
      addDistinctP,
      addOrderByP
    );
    return buildQuery(query);
  }
  addFieldSelection(i, identificationFields, q) {
    if (typeof i.select === "undefined") {
      i.select = {};
      this._fields.forEach((field) => {
        i.select[field] = true;
      });
    }
    const selectedFields = getSelectedFields(i.select);
    if (selectedFields.length === 0)
      throw new InvalidArgumentError(
        `The \`select\` statement for type ${this._tableName} needs at least one truthy value.`
      );
    const unknownField = selectedFields.find(
      (f) => !this._fields.includes(f)
    );
    if (unknownField) {
      throw new InvalidArgumentError(
        `Cannot select field ${unknownField} on table ${this._tableName}. Use 'include' to fetch related objects.`
      );
    }
    const fields = identificationFields.filter((f) => this._fields.includes(f)).concat(selectedFields).map((f) => this.castBigIntToText(f));
    return q.fields(fields);
  }
  /**
   * Casts a field to TEXT if it is of type BigInt
   * because not all adapters deal well with BigInts
   * (e.g. better-sqlite3 requires BigInt support to be enabled
   *       but then all integers are returned as BigInt...)
   * The DAL will convert the string into a BigInt in the `fromSqlite` function from `../conversions/sqlite.ts`.
   */
  castBigIntToText(field) {
    const pgType = this._tableDescription.fields.get(field);
    if (pgType === PgBasicType.PG_INT8 && this.dialect === "SQLite") {
      const quotedField = quoteIdentifier(field);
      return `cast(${quotedField} as TEXT) AS ${quotedField}`;
    }
    return quoteIdentifier(field);
  }
  addOrderBy(i, q) {
    if (typeof i.orderBy === "undefined")
      return q;
    const orderByArray = Array.isArray(i.orderBy) ? i.orderBy : [i.orderBy];
    return orderByArray.reduce((query, orderBy) => {
      const fields = Object.keys(orderBy);
      if (fields.length > 1)
        throw new InvalidArgumentError(
          `Argument 'orderBy' can have at most one field per 'OrderByInput' object. Consider providing several 'OrderByInput' objects in an array.`
        );
      if (fields.length === 0)
        return query;
      const field = fields[0];
      const order = orderBy[field];
      if (typeof order === "object" && order !== null)
        throw new InvalidArgumentError(
          `Ordering query results based on the '${field}' related object(s) is not yet supported`
        );
      const squelOrder = order === "asc";
      return query.order(quoteIdentifier(field), squelOrder);
    }, q);
  }
  getFields(whereObject, fieldsRequired = false) {
    const obj = typeof whereObject !== "undefined" ? whereObject : {};
    const fields = Object.keys(obj);
    if (fieldsRequired && fields.length === 0)
      throw new InvalidArgumentError(
        `Argument \`where\` for query on ${this._tableName} type requires at least one argument.`
      );
    return fields;
  }
  returnAllFields(query) {
    return this._fields.reduce((query2, field) => {
      const pgType = this._tableDescription.fields.get(field);
      if (pgType === PgBasicType.PG_INT8 && this.dialect === "SQLite") {
        const quotedField = quoteIdentifier(field);
        const f = squelPostgres.rstr(
          `cast(${quotedField} as TEXT) AS ${quotedField}`
        );
        return query2.returning(f);
      }
      return query2.returning(field);
    }, query);
  }
}
function addFilters(fields, whereObject, q) {
  return fields.reduce((query, fieldName) => {
    const fieldValue = whereObject[fieldName];
    const filters = makeFilter(fieldValue, fieldName);
    return filters.reduce((query2, filter) => {
      return query2.where(filter.sql, ...filter.args ?? []);
    }, query);
  }, q);
}
function makeFilter(fieldValue, fieldName, prefixFieldsWith = "") {
  if (fieldValue === null)
    return [{ sql: `${prefixFieldsWith}${quoteIdentifier(fieldName)} IS NULL` }];
  else if (fieldName === "AND" || fieldName === "OR" || fieldName === "NOT") {
    return [
      makeBooleanFilter(
        fieldName,
        fieldValue,
        prefixFieldsWith
      )
    ];
  } else if (isFilterObject(fieldValue)) {
    const fs = {
      equals: z.any(),
      in: z.any().array().optional(),
      not: z.any().optional(),
      notIn: z.any().optional(),
      lt: z.any().optional(),
      lte: z.any().optional(),
      gt: z.any().optional(),
      gte: z.any().optional(),
      startsWith: z.string().optional(),
      endsWith: z.string().optional(),
      contains: z.string().optional()
    };
    const fsHandlers = {
      equals: makeEqualsFilter.bind(null),
      in: makeInFilter.bind(null),
      not: makeNotFilter.bind(null),
      notIn: makeNotInFilter.bind(null),
      lt: makeLtFilter.bind(null),
      lte: makeLteFilter.bind(null),
      gt: makeGtFilter.bind(null),
      gte: makeGteFilter.bind(null),
      startsWith: makeStartsWithFilter.bind(null),
      endsWith: makeEndsWithFilter.bind(null),
      contains: makeContainsFilter.bind(null)
    };
    const filterSchema = z.object(fs).strict().refine(
      (data) => Object.keys(fs).some((filter) => filter in data),
      "Please provide at least one filter."
    );
    const obj = filterSchema.parse(fieldValue);
    const filters = [];
    Object.entries(fsHandlers).forEach((entry) => {
      const [filter, handler] = entry;
      if (filter in obj) {
        const sql = handler(
          prefixFieldsWith + quoteIdentifier(fieldName),
          obj[filter]
        );
        filters.push(sql);
      }
    });
    return filters;
  } else
    return [
      {
        sql: `${prefixFieldsWith}${quoteIdentifier(fieldName)} = ?`,
        args: [fieldValue]
      }
    ];
}
function joinStatements(statements, connective) {
  const sql = statements.map((s) => s.sql).join(` ${connective} `);
  const args = statements.map((s) => s.args).reduce((a1, a2) => (a1 ?? []).concat(a2 ?? []));
  return { sql, args };
}
function makeBooleanFilter(fieldName, value, prefixFieldsWith) {
  const objects = Array.isArray(value) ? value : [value];
  const sqlStmts = objects.map((obj) => {
    const fields = Object.keys(obj);
    const stmts = fields.reduce(
      (stmts2, fieldName2) => {
        const fieldValue = obj[fieldName2];
        const stmts22 = makeFilter(fieldValue, fieldName2, prefixFieldsWith);
        return stmts2.concat(stmts22);
      },
      []
    );
    return joinStatements(stmts, "AND");
  });
  if (fieldName === "NOT") {
    const statements = sqlStmts.map(({ sql, args }) => {
      return {
        sql: sqlStmts.length > 1 ? `(NOT ${sql})` : `NOT ${sql}`,
        // ternary if to avoid obsolete parentheses
        args
      };
    });
    return joinStatements(statements, "AND");
  } else {
    return joinStatements(sqlStmts, fieldName);
  }
}
function makeEqualsFilter(fieldName, value) {
  return { sql: `${fieldName} = ?`, args: [value] };
}
function makeInFilter(fieldName, values) {
  return { sql: `${fieldName} IN ?`, args: [values] };
}
function makeNotInFilter(fieldName, values) {
  return { sql: `${fieldName} NOT IN ?`, args: [values] };
}
function makeNotFilter(fieldName, value) {
  if (value === null) {
    return { sql: `${fieldName} IS NOT NULL` };
  } else {
    return { sql: `${fieldName} != ?`, args: [value] };
  }
}
function makeLtFilter(fieldName, value) {
  return { sql: `${fieldName} < ?`, args: [value] };
}
function makeLteFilter(fieldName, value) {
  return { sql: `${fieldName} <= ?`, args: [value] };
}
function makeGtFilter(fieldName, value) {
  return { sql: `${fieldName} > ?`, args: [value] };
}
function makeGteFilter(fieldName, value) {
  return { sql: `${fieldName} >= ?`, args: [value] };
}
function makeStartsWithFilter(fieldName, value) {
  if (typeof value !== "string")
    throw new Error("startsWith filter must be a string");
  return {
    sql: `${fieldName} LIKE ?`,
    args: [`${escapeLike(value)}%`]
  };
}
function makeEndsWithFilter(fieldName, value) {
  if (typeof value !== "string")
    throw new Error("endsWith filter must be a string");
  return {
    sql: `${fieldName} LIKE ?`,
    args: [`%${escapeLike(value)}`]
  };
}
function makeContainsFilter(fieldName, value) {
  if (typeof value !== "string")
    throw new Error("contains filter must be a string");
  return {
    sql: `${fieldName} LIKE ?`,
    args: [`%${escapeLike(value)}%`]
  };
}
function escapeLike(value) {
  return value.replaceAll(/(%|_)/g, "\\$1");
}
function addOffset(i, q) {
  if (typeof i.skip === "undefined")
    return q;
  return q.offset(i.skip);
}
function addLimit(i, q) {
  if (typeof i.take === "undefined")
    return q;
  return q.limit(i.take);
}
function addDistinct(i, q) {
  if (typeof i.distinct === "undefined")
    return q;
  return q.distinct(...i.distinct.map(quoteIdentifier));
}
function getSelectedFields(obj) {
  return Object.keys(obj).filter((key) => obj[key]);
}
function quoteIdentifier(identifier) {
  return `"${escDoubleQ(identifier)}"`;
}
export {
  Builder,
  makeFilter
};
//# sourceMappingURL=builder.js.map