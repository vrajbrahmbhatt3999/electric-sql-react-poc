import * as z from 'zod';
import { CreateInput, CreateManyInput } from '../input/createInput.js';
import { FindInput, FindUniqueInput } from '../input/findInput.js';
import { UpdateInput, UpdateManyInput } from '../input/updateInput.js';
import { UpsertInput } from '../input/upsertInput.js';
import { DeleteInput, DeleteManyInput } from '../input/deleteInput.js';
import { HKT } from '../util/hkt.js';
import { Migration } from '../../migrators/index.js';
import { PgType } from '../conversions/types.js';
export type Arity = 'one' | 'many';
export type TableName = string;
export type FieldName = string;
export type RelationName = string;
export type Fields = Map<FieldName, PgType>;
export type TableSchema<T extends Record<string, any>, CreateData extends object, UpdateData extends object, Select, Where extends object | undefined, WhereUnique extends object, Include extends Record<string, any>, OrderBy, ScalarFieldEnum, _GetPayload extends HKT> = {
    fields: Fields;
    relations: Relation[];
    modelSchema: z.ZodType<Partial<T>>;
    createSchema: z.ZodType<CreateInput<CreateData, Select, Include>>;
    createManySchema: z.ZodType<CreateManyInput<CreateData>>;
    findUniqueSchema: z.ZodType<FindUniqueInput<Select, WhereUnique, Include>>;
    findSchema: z.ZodType<FindInput<Select, Where, Include, OrderBy, ScalarFieldEnum>>;
    updateSchema: z.ZodType<UpdateInput<UpdateData, Select, WhereUnique, Include>>;
    updateManySchema: z.ZodType<UpdateManyInput<UpdateData, Where>>;
    upsertSchema: z.ZodType<UpsertInput<CreateData, UpdateData, Select, WhereUnique, Include>>;
    deleteSchema: z.ZodType<DeleteInput<Select, WhereUnique, Include>>;
    deleteManySchema: z.ZodType<DeleteManyInput<Where>>;
};
export type ExtendedTableSchema<T extends Record<string, any>, CreateData extends object, UpdateData extends object, Select, Where extends object | undefined, WhereUnique extends object, Include extends Record<string, any>, OrderBy, ScalarFieldEnum, GetPayload extends HKT> = TableSchema<T, CreateData, UpdateData, Select, Where, WhereUnique, Include, OrderBy, ScalarFieldEnum, GetPayload> & {
    outgoingRelations: Relation[];
    incomingRelations: Relation[];
};
export type TableSchemas = Record<TableName, TableSchema<any, any, any, any, any, any, any, any, any, HKT>>;
export type ExtendedTableSchemas = Record<TableName, ExtendedTableSchema<any, any, any, any, any, any, any, any, any, HKT>>;
export declare class Relation {
    relationField: FieldName;
    fromField: FieldName;
    toField: FieldName;
    relatedTable: TableName;
    relationName: RelationName;
    relatedObjects: Arity;
    constructor(relationField: FieldName, fromField: FieldName, toField: FieldName, relatedTable: TableName, relationName: RelationName, relatedObjects: Arity);
    isIncomingRelation(): boolean;
    isOutgoingRelation(): boolean;
    getOppositeRelation(dbDescription: DbSchema<any>): Relation;
}
export declare class DbSchema<T extends TableSchemas> {
    tables: T;
    migrations: Migration[];
    pgMigrations: Migration[];
    readonly extendedTables: ExtendedTableSchemas;
    private readonly incomingRelationsIndex;
    /**
     * @param tables Description of the database tables
     * @param migrations Bundled SQLite migrations
     * @param pgMigrations Bundled Postgres migrations
     */
    constructor(tables: T, migrations: Migration[], pgMigrations: Migration[]);
    private extend;
    private indexIncomingRelations;
    hasTable(table: TableName): boolean;
    getTableDescription(table: TableName): ExtendedTableSchema<any, any, any, any, any, any, any, any, any, HKT>;
    getFields(table: TableName): Fields;
    getFieldNames(table: TableName): FieldName[];
    hasRelationForField(table: TableName, field: FieldName): boolean;
    getRelationName(table: TableName, field: FieldName): RelationName;
    getRelation(table: TableName, relation: RelationName): Relation;
    getRelatedTable(table: TableName, field: FieldName): TableName;
    getForeignKey(table: TableName, field: FieldName): FieldName;
    getRelations(table: TableName): Relation[];
    getOutgoingRelations(table: TableName): Relation[];
    getIncomingRelations(table: TableName): Relation[];
    getRelationsPointingAtField(table: TableName, field: FieldName): Relation[];
}
