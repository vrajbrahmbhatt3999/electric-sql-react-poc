{"version":3,"sources":["../../../src/client/model/client.ts"],"sourcesContent":["import { ElectricNamespace } from '../../electric/namespace'\nimport { DbSchema, TableSchema } from './schema'\nimport { rawQuery, liveRawQuery, unsafeExec, Table } from './table'\nimport { Row, Statement } from '../../util'\nimport { LiveResultContext } from './model'\nimport { Notifier } from '../../notifiers'\nimport { DatabaseAdapter } from '../../electric/adapter'\nimport { GlobalRegistry, Registry, Satellite } from '../../satellite'\nimport { ReplicationTransformManager } from './transforms'\nimport { Dialect } from '../../migrators/query-builder/builder'\nimport { InputTransformer } from '../conversions/input'\nimport { sqliteConverter } from '../conversions/sqlite'\nimport { postgresConverter } from '../conversions/postgres'\nimport { IShapeManager } from './shapes'\n\nexport type ClientTables<DB extends DbSchema<any>> = {\n  [Tbl in keyof DB['tables']]: DB['tables'][Tbl] extends TableSchema<\n    infer T,\n    infer CreateData,\n    infer UpdateData,\n    infer Select,\n    infer Where,\n    infer WhereUnique,\n    infer Include,\n    infer OrderBy,\n    infer ScalarFieldEnum,\n    infer GetPayload\n  >\n    ? Table<\n        T,\n        CreateData,\n        UpdateData,\n        Select,\n        Where,\n        WhereUnique,\n        Include,\n        OrderBy,\n        ScalarFieldEnum,\n        GetPayload\n      >\n    : never\n}\n\ninterface RawQueries {\n  /**\n   * Executes a raw SQL query without protecting against modifications\n   * to the store that are incompatible with the replication mechanism\n   *\n   * [WARNING]: might break data replication, use with care!\n   * @param sql - A raw SQL query and its bind parameters.\n   * @returns The rows that result from the query.\n   */\n  unsafeExec(sql: Statement): Promise<Row[]>\n\n  /**\n   * Executes a read-only raw SQL query.\n   * @param sql - A raw SQL query and its bind parameters.\n   * @returns The rows that result from the query.\n   */\n  rawQuery(sql: Statement): Promise<Row[]>\n\n  /**\n   * A read-only raw SQL query that can be used with {@link useLiveQuery}.\n   * Same as {@link RawQueries#raw} but wraps the result in a {@link LiveResult} object.\n   * @param sql - A raw SQL query and its bind parameters.\n   */\n  liveRawQuery(sql: Statement): LiveResultContext<any>\n\n  /**\n   * @deprecated\n   * For safe, read-only SQL queries, use the `rawQuery` API\n   * For unsafe, store-modifying queries, use the `unsafeExec` API\n   *\n   * Executes a raw SQL query.\n   * @param sql - A raw SQL query and its bind parameters.\n   * @returns The rows that result from the query.\n   */\n  raw(sql: Statement): Promise<Row[]>\n\n  /**\n   * @deprecated\n   * Use `liveRawQuery` instead for reactive read-only SQL queries.\n   *\n   * A read-only raw SQL query that can be used with {@link useLiveQuery}.\n   * Same as {@link RawQueries#raw} but wraps the result in a {@link LiveResult} object.\n   * @param sql - A raw SQL query and its bind parameters.\n   */\n  liveRaw(sql: Statement): LiveResultContext<any>\n}\n\n/**\n * Electric client.\n * Extends the {@link ElectricNamespace} with a `db` property\n * providing raw query capabilities as well as a data access library for each DB table.\n */\nexport class ElectricClient<\n  DB extends DbSchema<any>\n> extends ElectricNamespace {\n  public sync: Omit<IShapeManager, 'subscribe'>\n\n  private constructor(\n    public db: ClientTables<DB> & RawQueries,\n    dbName: string,\n    adapter: DatabaseAdapter,\n    notifier: Notifier,\n    public readonly satellite: Satellite,\n    registry: Registry | GlobalRegistry\n  ) {\n    super(dbName, adapter, notifier, registry)\n    this.satellite = satellite\n    // Expose the Shape Sync API without additional properties\n    this.sync = {\n      syncStatus: this.satellite.syncStatus.bind(this.satellite),\n      unsubscribe: this.satellite.unsubscribe.bind(this.satellite),\n    }\n  }\n\n  /**\n   * Connects to the Electric sync service.\n   * This method is idempotent, it is safe to call it multiple times.\n   * @param token - The JWT token to use to connect to the Electric sync service.\n   *                This token is required on first connection but can be left out when reconnecting\n   *                in which case the last seen token is reused.\n   */\n  async connect(token?: string): Promise<void> {\n    if (token === undefined && !this.satellite.hasToken()) {\n      throw new Error('A token is required the first time you connect.')\n    }\n    if (token !== undefined) {\n      this.satellite.setToken(token)\n    }\n    await this.satellite.connectWithBackoff()\n  }\n\n  disconnect(): void {\n    this.satellite.clientDisconnect()\n  }\n\n  // Builds the DAL namespace from a `dbDescription` object\n  static create<DB extends DbSchema<any>>(\n    dbName: string,\n    dbDescription: DB,\n    adapter: DatabaseAdapter,\n    notifier: Notifier,\n    satellite: Satellite,\n    registry: Registry | GlobalRegistry,\n    dialect: Dialect\n  ): ElectricClient<DB> {\n    const tables = dbDescription.extendedTables\n    const converter = dialect === 'SQLite' ? sqliteConverter : postgresConverter\n    const replicationTransformManager = new ReplicationTransformManager(\n      satellite,\n      converter\n    )\n    const inputTransformer = new InputTransformer(converter)\n\n    const createTable = (tableName: string) => {\n      return new Table(\n        tableName,\n        adapter,\n        notifier,\n        satellite,\n        replicationTransformManager,\n        dbDescription,\n        inputTransformer,\n        dialect\n      )\n    }\n\n    // Create all tables\n    const dal = Object.fromEntries(\n      Object.keys(tables).map((tableName) => {\n        return [tableName, createTable(tableName)]\n      })\n    ) as ClientTables<DB>\n\n    // Now inform each table about all tables\n    Object.keys(dal).forEach((tableName) => {\n      dal[tableName].setTables(new Map(Object.entries(dal)))\n    })\n\n    const db: ClientTables<DB> & RawQueries = {\n      ...dal,\n      unsafeExec: unsafeExec.bind(null, adapter),\n      rawQuery: rawQuery.bind(null, adapter),\n      liveRawQuery: liveRawQuery.bind(null, adapter, notifier),\n      raw: unsafeExec.bind(null, adapter),\n      liveRaw: liveRawQuery.bind(null, adapter, notifier),\n    }\n\n    return new ElectricClient(\n      db,\n      dbName,\n      adapter,\n      notifier,\n      satellite,\n      registry\n    )\n  }\n}\n"],"mappings":"AAAA,SAAS,yBAAyB;AAElC,SAAS,UAAU,cAAc,YAAY,aAAa;AAM1D,SAAS,mCAAmC;AAE5C,SAAS,wBAAwB;AACjC,SAAS,uBAAuB;AAChC,SAAS,yBAAyB;AAmF3B,MAAM,uBAEH,kBAAkB;AAAA,EAGlB,YACC,IACP,QACA,SACA,UACgB,WAChB,UACA;AACA,UAAM,QAAQ,SAAS,UAAU,QAAQ;AAPlC;AAIS;AAIhB,SAAK,YAAY;AAEjB,SAAK,OAAO;AAAA,MACV,YAAY,KAAK,UAAU,WAAW,KAAK,KAAK,SAAS;AAAA,MACzD,aAAa,KAAK,UAAU,YAAY,KAAK,KAAK,SAAS;AAAA,IAC7D;AAAA,EACF;AAAA,EAjBO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA0BP,MAAM,QAAQ,OAA+B;AAC3C,QAAI,UAAU,UAAa,CAAC,KAAK,UAAU,SAAS,GAAG;AACrD,YAAM,IAAI,MAAM,iDAAiD;AAAA,IACnE;AACA,QAAI,UAAU,QAAW;AACvB,WAAK,UAAU,SAAS,KAAK;AAAA,IAC/B;AACA,UAAM,KAAK,UAAU,mBAAmB;AAAA,EAC1C;AAAA,EAEA,aAAmB;AACjB,SAAK,UAAU,iBAAiB;AAAA,EAClC;AAAA;AAAA,EAGA,OAAO,OACL,QACA,eACA,SACA,UACA,WACA,UACA,SACoB;AACpB,UAAM,SAAS,cAAc;AAC7B,UAAM,YAAY,YAAY,WAAW,kBAAkB;AAC3D,UAAM,8BAA8B,IAAI;AAAA,MACtC;AAAA,MACA;AAAA,IACF;AACA,UAAM,mBAAmB,IAAI,iBAAiB,SAAS;AAEvD,UAAM,cAAc,CAAC,cAAsB;AACzC,aAAO,IAAI;AAAA,QACT;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAGA,UAAM,MAAM,OAAO;AAAA,MACjB,OAAO,KAAK,MAAM,EAAE,IAAI,CAAC,cAAc;AACrC,eAAO,CAAC,WAAW,YAAY,SAAS,CAAC;AAAA,MAC3C,CAAC;AAAA,IACH;AAGA,WAAO,KAAK,GAAG,EAAE,QAAQ,CAAC,cAAc;AACtC,UAAI,SAAS,EAAE,UAAU,IAAI,IAAI,OAAO,QAAQ,GAAG,CAAC,CAAC;AAAA,IACvD,CAAC;AAED,UAAM,KAAoC;AAAA,MACxC,GAAG;AAAA,MACH,YAAY,WAAW,KAAK,MAAM,OAAO;AAAA,MACzC,UAAU,SAAS,KAAK,MAAM,OAAO;AAAA,MACrC,cAAc,aAAa,KAAK,MAAM,SAAS,QAAQ;AAAA,MACvD,KAAK,WAAW,KAAK,MAAM,OAAO;AAAA,MAClC,SAAS,aAAa,KAAK,MAAM,SAAS,QAAQ;AAAA,IACpD;AAEA,WAAO,IAAI;AAAA,MACT;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACF;","names":[]}