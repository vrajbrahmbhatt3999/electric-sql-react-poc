import {
  parseNestedCreate,
  omitCountFromSelectAndIncludeSchema,
  parseNestedUpdate,
  validate
} from '../validation/validation.js';
import { Builder, makeFilter } from './builder.js';
import { Executor } from '../execution/executor.js';
import { InvalidArgumentError } from '../validation/errors/invalidArgumentError.js';
import { _NOT_UNIQUE_, _RECORD_NOT_FOUND_ } from '../validation/errors/messages.js';
import { LiveResult } from './model.js';
import { QualifiedTablename } from '../../util/tablename.js';
import { forEach } from '../util/continuationHelpers.js';
import { notNullNotUndefined } from '../util/functions.js';
import pick from "lodash.pick";
import omitBy from "lodash.omitby";
import hasOwn from "object.hasown";
import * as z from "zod";
import {
  isPotentiallyDangerous,
  parseTableNames,
  createQueryResultSubscribeFunction,
  isObject,
  interpolateSqlArgs
} from '../../util/index.js';
class Table {
  constructor(tableName, adapter, _notifier, _shapeManager, _replicationTransformManager, _dbDescription, _transformer, dialect) {
    this.tableName = tableName;
    this._notifier = _notifier;
    this._shapeManager = _shapeManager;
    this._replicationTransformManager = _replicationTransformManager;
    this._dbDescription = _dbDescription;
    this._transformer = _transformer;
    this.dialect = dialect;
    this._fields = this._dbDescription.getFields(tableName);
    const fieldNames = this._dbDescription.getFieldNames(tableName);
    const tableDescription = this._dbDescription.getTableDescription(tableName);
    this._builder = new Builder(
      tableName,
      fieldNames,
      tableDescription,
      this.dialect
    );
    this._executor = new Executor(
      adapter,
      _notifier,
      this._fields,
      this._transformer.converter
    );
    const namespace = this.dialect === "Postgres" ? "public" : "main";
    this._qualifiedTableName = new QualifiedTablename(namespace, tableName);
    this._tables = /* @__PURE__ */ new Map();
    this._schema = tableDescription.modelSchema;
    this.createSchema = omitCountFromSelectAndIncludeSchema(
      tableDescription.createSchema
    );
    this.createManySchema = tableDescription.createManySchema;
    this.findUniqueSchema = tableDescription.findUniqueSchema;
    this.findSchema = tableDescription.findSchema;
    this.updateSchema = omitCountFromSelectAndIncludeSchema(
      tableDescription.updateSchema
    );
    this.updateManySchema = tableDescription.updateManySchema;
    this.upsertSchema = tableDescription.upsertSchema;
    this.deleteSchema = tableDescription.deleteSchema;
    this.deleteManySchema = tableDescription.deleteManySchema;
    this.syncSchema = tableDescription.findSchema.pick({
      include: true
    });
    const shape = tableDescription.findSchema.shape.where;
    this.syncSchema = this.syncSchema.extend({
      where: shape.or(z.string().optional()),
      key: z.string().optional()
    });
  }
  _builder;
  _executor;
  _qualifiedTableName;
  _tables;
  _fields;
  _schema;
  createSchema;
  createManySchema;
  findUniqueSchema;
  findSchema;
  updateSchema;
  updateManySchema;
  upsertSchema;
  deleteSchema;
  deleteManySchema;
  syncSchema;
  setTables(tables) {
    this._tables = tables;
  }
  computeShape(i) {
    const include = i.include ?? {};
    const where = i.where ?? "";
    const includedFields = Object.keys(include);
    const includedTables = includedFields.map((field) => {
      const relatedTableName = this._dbDescription.getRelatedTable(
        this.tableName,
        field
      );
      const fkk = this._dbDescription.getForeignKey(this.tableName, field);
      const relatedTable = this._tables.get(relatedTableName);
      const includedObj = include[field];
      if (typeof includedObj === "object" && !Array.isArray(includedObj) && includedObj !== null) {
        return {
          foreignKey: [fkk],
          select: relatedTable.computeShape(includedObj)
        };
      } else if (typeof includedObj === "boolean" && includedObj) {
        return {
          foreignKey: [fkk],
          select: {
            tablename: relatedTableName
          }
        };
      } else {
        throw new Error(
          `Unexpected value in include tree for sync: ${JSON.stringify(
            includedObj
          )}`
        );
      }
    });
    const whereClause = makeSqlWhereClause(where);
    return {
      tablename: this.tableName,
      include: includedTables,
      ...whereClause === "" ? {} : { where: whereClause }
    };
  }
  getIncludedTables(i) {
    const include = i.include ?? {};
    const includedFields = Object.keys(include);
    const includedTables = /* @__PURE__ */ new Set([this]);
    includedFields.forEach((field) => {
      const relatedTableName = this._dbDescription.getRelatedTable(
        this.tableName,
        field
      );
      const relatedTable = this._tables.get(relatedTableName);
      const extendedTable = includedTables.add(relatedTable);
      const includedObj = include[field];
      if (isObject(includedObj)) {
        const nestedTables = relatedTable.getIncludedTables(includedObj);
        nestedTables.forEach((tbl) => extendedTable.add(tbl));
        return extendedTable;
      } else if (typeof includedObj === "boolean") {
        return extendedTable;
      } else {
        throw new Error(
          `Unexpected value in include tree for syncShape: ${JSON.stringify(
            includedObj
          )}`
        );
      }
    });
    return includedTables;
  }
  sync(i) {
    const validatedInput = this.syncSchema.parse(i ?? {});
    const shape = this.computeShape(validatedInput);
    return this._shapeManager.subscribe([shape], validatedInput.key);
  }
  /*
   * The API is implemented in continuation passing style.
   * Private methods return a function expecting 2 arguments:
   *   1. a transaction
   *   2. a continuation
   * These methods will then execute their query inside the provided transaction and pass the result to the continuation.
   * As such, one can compose these methods arbitrarily and then run them inside a single transaction.
   */
  async create(i) {
    return this._executor.transaction(
      (db, cont, onError) => this._create(i, db, cont, onError)
    );
  }
  async createMany(i) {
    return this._executor.execute(this._createMany.bind(this, i));
  }
  async findUnique(i) {
    return this._executor.execute(
      (db, cont, onError) => this._findUnique(i, db, cont, onError),
      false
    );
  }
  liveUnique(i) {
    return this.makeLiveResult(() => this.findUnique(i), i);
  }
  async findFirst(i) {
    return this._executor.execute(
      (db, cont, onError) => this._findFirst(i, db, cont, onError),
      false
    );
  }
  liveFirst(i) {
    return this.makeLiveResult(() => this.findFirst(i), i ?? {});
  }
  async findMany(i) {
    return this._executor.execute(
      (db, cont, onError) => this._findMany(i, db, cont, onError),
      false
    );
  }
  liveMany(i) {
    return this.makeLiveResult(() => this.findMany(i), i ?? {});
  }
  async update(i) {
    return this._executor.transaction(
      (db, cont, onError) => this._update(i, db, cont, onError)
    );
  }
  async updateMany(i) {
    return this._executor.execute(this._updateMany.bind(this, i));
  }
  async upsert(i) {
    return this._executor.transaction(
      (db, cont, onError) => this._upsert(i, db, cont, onError)
    );
  }
  async delete(i) {
    return this._executor.transaction(
      (db, cont, onError) => this._delete(i, db, cont, onError)
    );
  }
  async deleteMany(i) {
    return this._executor.execute(this._deleteMany.bind(this, i));
  }
  forEachRelation(data, f, cont) {
    const relations = this._dbDescription.getRelations(this.tableName);
    forEach(
      (rel, cont2) => {
        if (hasOwn(data, rel.relationField)) {
          f(rel, cont2);
        } else {
          cont2();
        }
      },
      relations,
      cont
    );
  }
  forEachOutgoingRelation(data, f, cont) {
    this.forEachRelation(
      data,
      (rel, cont2) => {
        if (rel.isOutgoingRelation()) {
          f(rel, cont2);
        } else {
          cont2();
        }
      },
      cont
    );
  }
  _create(i, db, continuation, onError) {
    const validatedInput = this._transformer.transformCreate(
      validate(i, this.createSchema),
      this._fields
    );
    const data = validatedInput.data;
    this.forEachOutgoingRelation(
      data,
      (rel, cont) => {
        const { fromField, toField, relationField, relatedTable } = rel;
        const relatedObject = parseNestedCreate(data[relationField]).create;
        const relatedTbl = this._tables.get(relatedTable);
        relatedTbl._create(
          { data: relatedObject },
          db.withTableSchema(relatedTbl._fields),
          (createdRelatedObject) => {
            delete data[relationField];
            data[fromField] = createdRelatedObject[toField];
            cont();
          },
          onError
        );
      },
      () => {
        const incomingRelations = this._dbDescription.getIncomingRelations(
          this.tableName
        );
        let makeRelatedObjects = (_obj, cont) => cont();
        const createRelatedObject = (rel, relatedObject) => {
          const { relationField, relatedTable, relationName } = rel;
          delete data[relationField];
          const oldMakeRelatedObjects = makeRelatedObjects;
          makeRelatedObjects = (obj, cont) => {
            const relatedTbl = this._tables.get(relatedTable);
            const { fromField, toField } = this._dbDescription.getRelation(
              relatedTable,
              relationName
            );
            relatedObject[fromField] = obj[toField];
            relatedTbl._create(
              { data: relatedObject },
              db.withTableSchema(relatedTbl._fields),
              () => {
                oldMakeRelatedObjects(obj, cont);
              },
              onError
            );
          };
        };
        incomingRelations.forEach((rel) => {
          const { relationField } = rel;
          if (hasOwn(data, relationField)) {
            const relatedObjects = parseNestedCreate(data[relationField]).create;
            if (Array.isArray(relatedObjects)) {
              relatedObjects.forEach(createRelatedObject.bind(this, rel));
            } else {
              createRelatedObject(rel, relatedObjects);
            }
          }
        });
        const createQuery = this._builder.create({
          ...validatedInput,
          data
        });
        db.query(
          createQuery,
          this._schema,
          (db2, insertedObjects) => {
            if (insertedObjects.length !== 1)
              onError("Wrong amount of objects were created.");
            const insertedObject = insertedObjects[0];
            makeRelatedObjects(insertedObject, () => {
              this._findUniqueWithoutAutoSelect(
                {
                  where: data,
                  select: validatedInput.select,
                  ...notNullNotUndefined(validatedInput.include) && {
                    include: validatedInput.include
                  }
                  // only add `include` property if it is defined
                },
                db2,
                continuation,
                onError,
                "Create"
              );
            });
          },
          onError
        );
      }
    );
  }
  _createMany(i, db, continuation, onError) {
    const data = this._transformer.transformCreateMany(
      validate(i, this.createManySchema),
      this._fields
    );
    const sql = this._builder.createMany(data);
    db.run(
      sql,
      (_, { rowsAffected }) => {
        continuation({ count: rowsAffected });
      },
      onError
    );
  }
  _findUnique(i, db, continuation, onError) {
    const data = this._transformer.transformFindUnique(
      validate(i, this.findUniqueSchema),
      this._fields
    );
    const sql = this._builder.findUnique(data);
    db.query(
      sql,
      this._schema,
      (_, res) => {
        if (res.length > 1)
          throw new InvalidArgumentError(_NOT_UNIQUE_);
        if (res.length === 1)
          return this.fetchIncludes(
            res,
            data.include,
            db,
            (rows) => {
              continuation(rows[0]);
            },
            onError
          );
        return continuation(null);
      },
      onError
    );
  }
  _findFirst(i, db, continuation, onError) {
    const data = this._transformer.transformFindNonUnique(
      validate(i ?? {}, this.findSchema),
      this._fields
    );
    const sql = this._builder.findFirst(data);
    db.query(
      sql,
      this._schema,
      (_, res) => {
        if (res.length === 0)
          return continuation(null);
        return this.fetchIncludes(
          [res[0]],
          data.include,
          db,
          (rows) => {
            continuation(rows[0]);
          },
          onError
        );
      },
      onError
    );
  }
  /**
   * Joins objects in `rows` with objects in `relatedRows` where `row.fromField === relatedRow.toField`.
   * Beware: this function mutates the objects in `rows`.
   * @param rows Array of original objects
   * @param relatedRows Array of related objects
   * @param fromField Field of objects in `rows` that points to related object.
   * @param toField Field of objects in `relatedRows` that is pointed at by the original object.
   */
  joinObjects(rows, relatedRows, fromField, toField, relationField, relationArity) {
    return rows.map((row) => {
      const relatedObjects = relatedRows.filter(
        (r) => row[fromField] === r[toField]
      );
      if (relatedObjects.length === 0)
        return row;
      else if (relationArity === "one") {
        if (relatedObjects.length > 1)
          throw TypeError(
            `Relation on field '${relationField}' is one-to-one but found several related objects: ` + JSON.stringify(relatedObjects)
          );
        const [relatedObject] = relatedObjects;
        return Object.assign(row, {
          [relationField]: relatedObject
        });
      } else {
        return Object.assign(row, {
          [relationField]: relatedObjects
        });
      }
    });
  }
  fetchRelated(rows, relatedTable, fromField, toField, relationField, relationType, includeArg, db, onResult, onError) {
    const otherTable = this._tables.get(relatedTable);
    const args = includeArg === true ? {} : includeArg;
    const where = typeof args.where === "undefined" ? {} : args.where;
    const foreignKeys = rows.map((row) => row[fromField]).filter((fk) => fk !== null && fk !== void 0);
    otherTable._findMany(
      {
        ...args,
        where: {
          ...where,
          [toField]: {
            in: foreignKeys
          }
        }
      },
      db.withTableSchema(otherTable._fields),
      (relatedRows) => {
        this.joinObjects(
          rows,
          relatedRows,
          fromField,
          toField,
          relationField,
          relationType
        );
        onResult();
      },
      onError
    );
  }
  fetchInclude(rows, relation, includeArg, db, onResult, onError) {
    if (includeArg === false) {
      return onResult();
    } else if (relation.isIncomingRelation()) {
      const { fromField, toField } = relation.getOppositeRelation(
        this._dbDescription
      );
      this.fetchRelated(
        rows,
        relation.relatedTable,
        toField,
        fromField,
        relation.relationField,
        relation.relatedObjects,
        includeArg,
        db,
        onResult,
        onError
      );
    } else {
      const {
        fromField,
        toField,
        relationField,
        relatedObjects,
        relatedTable
      } = relation;
      this.fetchRelated(
        rows,
        relatedTable,
        fromField,
        toField,
        relationField,
        relatedObjects,
        includeArg,
        db,
        onResult,
        onError
      );
    }
  }
  fetchIncludes(rows, include, db, onResult, onError) {
    if (typeof include === "undefined" || rows.length === 0)
      return onResult(rows);
    else {
      const relationFields = Object.keys(include);
      forEach(
        (relationField, cont) => {
          if (!this._dbDescription.hasRelationForField(
            this.tableName,
            relationField
          )) {
            throw new InvalidArgumentError(
              "Unexpected field `" + relationField + "` in `include` argument."
            );
          }
          const relationName = this._dbDescription.getRelationName(
            this.tableName,
            relationField
          );
          const relation = this._dbDescription.getRelation(
            this.tableName,
            relationName
          );
          this.fetchInclude(
            rows,
            relation,
            include[relationField],
            db,
            cont,
            onError
          );
        },
        relationFields,
        () => {
          onResult(rows);
        }
      );
    }
  }
  _findMany(i, db, continuation, onError) {
    const data = this._transformer.transformFindNonUnique(
      validate(i ?? {}, this.findSchema),
      this._fields
    );
    const sql = this._builder.findMany(data);
    db.query(
      sql,
      this._schema,
      (_, rows) => {
        this.fetchIncludes(
          rows,
          data.include,
          db,
          continuation,
          onError
        );
      },
      onError
    );
  }
  _findUniqueWithoutAutoSelect(i, db, continuation, onError, queryType) {
    const q = this._builder.findWithoutAutoSelect(i);
    db.query(
      q,
      this._schema,
      (_, rows) => {
        if (rows.length === 0)
          throw new InvalidArgumentError(_RECORD_NOT_FOUND_(queryType));
        if (rows.length > 1)
          throw new InvalidArgumentError(_NOT_UNIQUE_);
        this.fetchIncludes(
          rows,
          i.include,
          db,
          (joinedRows) => {
            const [joinedObj] = joinedRows;
            continuation(joinedObj);
          },
          onError
        );
      },
      onError
    );
  }
  /**
   * Updates the related object of a one-to-one relation (when `updateType === 'update'`)
   * or many related objects from a one-to-many relation (when `updateType === 'updateMany'`).
   * The related object(s) is one or more rows from the `relatedTable` that matches the `obj.where` argument
   * and where the value of `toField` equals `fromFieldValue`.
   */
  updateRelatedObject(obj, relatedTable, fromFieldValue, toField, isIncomingRelation, db, cont, onError, updateType = "update") {
    if (typeof obj === "undefined") {
      cont();
    } else {
      const relatedTbl = this._tables.get(relatedTable);
      if (updateType === "update") {
        const whereArg = isIncomingRelation ? obj.where : {
          ...obj.where,
          [toField]: fromFieldValue
        };
        relatedTbl._update(
          {
            data: obj.data,
            where: whereArg
          },
          db.withTableSchema(relatedTbl._fields),
          cont,
          onError
        );
      } else {
        relatedTbl._updateMany(
          {
            data: obj.data,
            where: {
              ...obj.where,
              // `obj.where` might not be enough to identify only the objects that are related
              //  so restrict the object to only those that are related by this foreign key
              [toField]: fromFieldValue
            }
          },
          db.withTableSchema(relatedTbl._fields),
          cont,
          onError
        );
      }
    }
  }
  /**
   * Takes the original object and the updated object
   * and updates foreign keys of related objects
   * that were pointing at a field that got updated.
   * @param cont Function to call after the foreign keys are updated.
   */
  updateFKs(originalObject, updatedObj, db, onError, cont) {
    const diff = omitBy(updatedObj, (value, field) => {
      return originalObject[field] === value;
    });
    const updatedFields = Object.keys(diff);
    const updatedIncomingFields = updatedFields.filter((field) => {
      return this._dbDescription.getRelationsPointingAtField(this.tableName, field).length > 0;
    });
    forEach(
      (toField, cont2) => {
        const incomingRelations = this._dbDescription.getRelationsPointingAtField(
          this.tableName,
          toField
        );
        forEach(
          (relation, cont3) => {
            const relatedTableName = relation.relatedTable;
            const { fromField } = relation.getOppositeRelation(
              this._dbDescription
            );
            const relatedTable = this._tables.get(relatedTableName);
            relatedTable._updateMany(
              {
                data: {
                  [fromField]: updatedObj[toField]
                },
                where: {
                  [fromField]: originalObject[toField]
                }
              },
              db.withTableSchema(relatedTable._fields),
              cont3,
              onError
            );
          },
          incomingRelations,
          cont2
        );
      },
      updatedIncomingFields,
      cont
    );
  }
  /**
   * Updates related objects for incoming relations based on
   * nested `updateMany` argument that is provided with `update`.
   *
   * @example
   * The example below updates the title of all posts written by `user1`.
   * In the `User` table there is an incoming relation from each post to the user that wrote it.
   * This method updates all related objects for such an incoming relation:
   * ```
   * User.update({
   *   data: {
   *     posts: {
   *       updateMany: {
   *         data: {
   *           title: 'A new title for all my posts'
   *         },
   *         where: {}
   *       }
   *     }
   *   },
   *   where: {
   *     id: user1.id
   *   }
   * })
   * ```
   *
   * @param relatedTable The name of the table containing the related objects.
   * @param relationName The name of the relation between the two tables.
   * @param ogObject The object on which `update` is called, before the update is executed.
   * @param updateManyObject The object that was passed as `updateMany` argument to `update`.
   * @param onError Error handler callback.
   * @param cont Function that will be called once the related objects are updated.
   */
  updateManyRelatedObjectsFromIncomingRelation(relatedTable, relationName, ogObject, updateManyObject, db, onError, cont) {
    const { fromField, toField } = this._dbDescription.getRelation(
      relatedTable,
      relationName
    );
    const toFieldValue = ogObject[toField];
    const updateManyArray = Array.isArray(updateManyObject) ? updateManyObject : typeof updateManyObject === "undefined" ? [] : [updateManyObject];
    forEach(
      (updateObj, cont2) => {
        this.updateRelatedObject(
          updateObj,
          relatedTable,
          toFieldValue,
          fromField,
          true,
          db,
          cont2,
          onError,
          "updateMany"
        );
      },
      updateManyArray,
      cont
    );
  }
  /**
   * Updates related objects for incoming relations based on
   * nested `update` argument that is provided with `update`.
   * For example:
   *  User.update({
   *    data: {
   *      posts: {
   *        update: {
   *          data: {
   *            title: 'A new title for all my posts'
   *          },
   *          where: {
   *            id: post2.id
   *          }
   *        }
   *      }
   *    },
   *    where: {
   *      id: user1.id
   *    }
   *  })
   * The above example updates the title of post2 that was written by `user1`.
   * This method updates that related object for such incoming relations.
   *
   * @param relatedTable The name of the table containing the related objects.
   * @param relationName The name of the relation between the two tables.
   * @param ogObject The object on which `update` is called, before the update is executed.
   * @param updateObject The object that was passed as nested `update` argument to `update`.
   * @param onError Error handler callback.
   * @param cont Function that will be called once the related objects are updated.
   */
  updateRelatedObjectFromIncomingRelation(relatedTable, relationName, ogObject, updateObject, db, onError, cont) {
    const { relatedObjects } = this._dbDescription.getRelation(
      this.tableName,
      relationName
    );
    const { fromField, toField } = this._dbDescription.getRelation(
      relatedTable,
      relationName
    );
    const toFieldValue = ogObject[toField];
    if (relatedObjects === "many") {
      const updateObjects = Array.isArray(updateObject) ? updateObject : typeof updateObject === "undefined" ? [] : [updateObject];
      forEach(
        (updateObj, cont2) => {
          this.updateRelatedObject(
            updateObj,
            relatedTable,
            toFieldValue,
            fromField,
            true,
            db,
            (res) => {
              const updatedObj = res;
              if (updatedObj[fromField] !== toFieldValue) {
                throw new InvalidArgumentError(
                  `Nested update cannot update an unrelated object.
Related object has field ${fromField} === ${toFieldValue}
but the object identified by ${JSON.stringify(
                    updateObj
                  )} has ${fromField} === ${updatedObj[fromField]}`
                );
              }
              cont2();
            },
            onError
          );
        },
        updateObjects,
        cont
      );
    } else {
      const typedUpdateObj = typeof updateObject === "undefined" ? void 0 : { data: updateObject, where: { [toField]: toFieldValue } };
      this.updateRelatedObject(
        typedUpdateObj,
        relatedTable,
        toFieldValue,
        fromField,
        true,
        db,
        cont,
        onError
      );
    }
  }
  updateRelatedObjectFromOutgoingRelation(relation, ogObject, updateObject, relatedTable, db, cont, onError) {
    const { fromField, toField } = relation;
    const fromFieldValue = ogObject[fromField];
    const wrappedUpdateObject = typeof updateObject === "undefined" ? void 0 : { data: updateObject };
    this.updateRelatedObject(
      wrappedUpdateObject,
      relatedTable,
      fromFieldValue,
      toField,
      false,
      db,
      cont,
      onError
    );
  }
  _update(i, db, continuation, onError) {
    const data = this._transformer.transformUpdate(
      validate(i, this.updateSchema),
      this._fields
    );
    this._findUnique(
      { where: data.where },
      db,
      (originalObject) => {
        const ogObject = originalObject;
        if (originalObject === null)
          throw new InvalidArgumentError(_RECORD_NOT_FOUND_("Update"));
        const fields = this._dbDescription.getFieldNames(this.tableName);
        const nonRelationalData = pick(data.data, fields);
        const nonRelationalFields = Object.keys(nonRelationalData);
        const nonRelationalObject = {
          ...data,
          data: nonRelationalData
        };
        const updateRelatedObjects = (db2, res) => {
          const updatedObj = res[0];
          this.updateFKs(originalObject, updatedObj, db2, onError, () => {
            this.updateRelatedObjects(
              data,
              ogObject,
              db2,
              nonRelationalData,
              onError,
              continuation
            );
          });
        };
        if (nonRelationalFields.length > 0) {
          const updateDataQuery = this._builder.update(nonRelationalObject);
          db.query(updateDataQuery, this._schema, updateRelatedObjects, onError);
        } else {
          updateRelatedObjects(db, [ogObject]);
        }
      },
      onError
    );
  }
  /**
   * Updates may also include nested updates to related objects.
   * This function updates those related objects as requested by the user.
   */
  updateRelatedObjects(data, ogObject, db, nonRelationalData, onError, continuation) {
    this.forEachRelation(
      data.data,
      (rel, cont) => {
        const { relationField, relatedTable, relationName } = rel;
        const dataRecord = data.data;
        const relationActions = parseNestedUpdate(dataRecord[relationField]);
        const updateObject = relationActions.update;
        if (rel.isOutgoingRelation()) {
          this.updateRelatedObjectFromOutgoingRelation(
            rel,
            ogObject,
            updateObject,
            relatedTable,
            db,
            (updatedObj) => {
              const updatedObject = updatedObj;
              const toFieldValue = updatedObject[rel.toField];
              nonRelationalData[rel.fromField] = toFieldValue;
              cont();
            },
            onError
          );
        } else {
          this.updateRelatedObjectFromIncomingRelation(
            relatedTable,
            relationName,
            ogObject,
            updateObject,
            db,
            onError,
            () => {
              const updateManyObject = relationActions.updateMany;
              this.updateManyRelatedObjectsFromIncomingRelation(
                relatedTable,
                relationName,
                ogObject,
                updateManyObject,
                db,
                onError,
                cont
              );
            }
          );
        }
      },
      () => {
        this._findUniqueWithoutAutoSelect(
          {
            where: { ...data.where, ...nonRelationalData },
            select: data.select,
            ...notNullNotUndefined(data.include) && {
              include: data.include
            }
            // only add `include` property if it is defined
          },
          db,
          continuation,
          onError,
          "Update"
        );
      }
    );
  }
  _updateMany(i, db, continuation, onError) {
    const data = this._transformer.transformUpdateMany(
      validate(i, this.updateManySchema),
      this._fields
    );
    const sql = this._builder.updateMany(data);
    db.run(
      sql,
      (_, { rowsAffected }) => {
        return continuation({ count: rowsAffected });
      },
      onError
    );
  }
  _upsert(i, db, continuation, onError) {
    validate(i, this.upsertSchema);
    this._findUnique(
      { where: i.where },
      db,
      (rows) => {
        if (rows === null) {
          return this._create(
            {
              data: i.create,
              select: i.select,
              ...notNullNotUndefined(i.include) && {
                include: i.include
              }
              // only add `include` property if it is defined
            },
            db,
            continuation,
            onError
          );
        } else {
          return this._update(
            {
              data: i.update,
              where: i.where,
              select: i.select,
              ...notNullNotUndefined(i.include) && {
                include: i.include
              }
              // only add `include` property if it is defined
            },
            db,
            continuation,
            onError
          );
        }
      },
      onError
    );
  }
  _delete(i, db, continuation, onError) {
    const data = this._transformer.transformDelete(
      validate(i, this.deleteSchema),
      this._fields
    );
    this._findUniqueWithoutAutoSelect(
      data,
      db,
      (record) => {
        const deleteQuery = this._builder.delete(data);
        db.run(
          deleteQuery,
          () => continuation(record),
          onError
        );
      },
      onError,
      "Delete"
    );
  }
  _deleteMany(i, db, continuation, onError) {
    const data = this._transformer.transformDeleteMany(
      validate(i ?? {}, this.deleteManySchema),
      this._fields
    );
    const sql = this._builder.deleteMany(data);
    db.run(
      sql,
      (_, { rowsAffected }) => {
        continuation({ count: rowsAffected });
      },
      onError
    );
  }
  makeLiveResult(runner, i) {
    const tables = [...this.getIncludedTables(i)].map(
      (x) => x._qualifiedTableName
    );
    const result = () => {
      return runner().then((res) => {
        return new LiveResult(res, tables);
      });
    };
    result.subscribe = createQueryResultSubscribeFunction(
      this._notifier,
      result,
      tables
    );
    result.sourceQuery = i;
    return result;
  }
  setReplicationTransform(i) {
    const fkCols = this._dbDescription.getOutgoingRelations(this.tableName).map((r) => r.fromField);
    const pkCols = this._dbDescription.getIncomingRelations(this.tableName).map((r) => r.getOppositeRelation(this._dbDescription).toField);
    const immutableFields = Array.from(new Set(fkCols.concat(pkCols)));
    this._replicationTransformManager.setTableTransform(
      this._qualifiedTableName,
      {
        transformInbound: (record) => this._replicationTransformManager.transformTableRecord(
          record,
          i.transformInbound,
          this._fields,
          this._schema,
          immutableFields
        ),
        transformOutbound: (record) => this._replicationTransformManager.transformTableRecord(
          record,
          i.transformOutbound,
          this._fields,
          this._schema,
          immutableFields
        )
      }
    );
  }
  clearReplicationTransform() {
    this._replicationTransformManager.clearTableTransform(
      this._qualifiedTableName
    );
  }
}
function unsafeExec(adapter, sql) {
  return adapter.query(sql);
}
function rawQuery(adapter, sql) {
  if (isPotentiallyDangerous(sql.sql)) {
    throw new InvalidArgumentError(
      "Cannot use queries that might alter the store - please use read-only queries"
    );
  }
  return unsafeExec(adapter, sql);
}
function liveRawQuery(adapter, notifier, sql) {
  const result = async () => {
    const tablenames = parseTableNames(sql.sql, adapter.defaultNamespace);
    const res = await rawQuery(adapter, sql);
    return new LiveResult(res, tablenames);
  };
  result.subscribe = createQueryResultSubscribeFunction(
    notifier,
    result,
    parseTableNames(sql.sql, adapter.defaultNamespace)
  );
  result.sourceQuery = sql;
  return result;
}
function makeSqlWhereClause(where) {
  if (typeof where === "string")
    return where;
  const statements = Object.entries(where).flatMap(([key, value]) => makeFilter(value, key, "this.")).map(interpolateSqlArgsForPostgres);
  if (statements.length < 2)
    return statements[0] ?? "";
  else
    return statements.map((x) => "(" + x + ")").join(" AND ");
}
function interpolateSqlArgsForPostgres({
  sql,
  args
}) {
  return interpolateSqlArgs({ sql, args: args?.map(quoteValueForPostgres) });
}
function quoteValueForPostgres(value) {
  if (typeof value === "string")
    return `'${value.replaceAll("'", "''")}'`;
  if (typeof value === "number")
    return value.toString();
  if (value instanceof Date && !isNaN(value.valueOf()))
    return `'${value.toISOString()}'`;
  if (typeof value === "boolean")
    return value.toString();
  if (Array.isArray(value))
    return `(${value.map(quoteValueForPostgres).join(", ")})`;
  throw new Error(
    `Sorry! We currently cannot handle where clauses using value ${value}. You can try serializing it to a string yourself. 
Please leave a feature request at https://github.com/electric-sql/electric/issues.`
  );
}
export {
  Table,
  liveRawQuery,
  rawQuery,
  unsafeExec
};
//# sourceMappingURL=table.js.map