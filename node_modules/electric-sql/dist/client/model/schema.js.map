{"version":3,"sources":["../../../src/client/model/schema.ts"],"sourcesContent":["import mapValues from 'lodash.mapvalues'\nimport partition from 'lodash.partition'\nimport * as z from 'zod'\nimport { CreateInput, CreateManyInput } from '../input/createInput'\nimport { FindInput, FindUniqueInput } from '../input/findInput'\nimport { UpdateInput, UpdateManyInput } from '../input/updateInput'\nimport { UpsertInput } from '../input/upsertInput'\nimport { DeleteInput, DeleteManyInput } from '../input/deleteInput'\nimport { HKT } from '../util/hkt'\nimport groupBy from 'lodash.groupby'\nimport { Migration } from '../../migrators'\nimport { PgType } from '../conversions/types'\n\nexport type Arity = 'one' | 'many'\n\nexport type TableName = string\nexport type FieldName = string\nexport type RelationName = string\n\nexport type Fields = Map<FieldName, PgType>\n\nexport type TableSchema<\n  T extends Record<string, any>,\n  CreateData extends object,\n  UpdateData extends object,\n  Select,\n  Where extends object | undefined,\n  WhereUnique extends object,\n  Include extends Record<string, any>,\n  OrderBy,\n  ScalarFieldEnum,\n  _GetPayload extends HKT\n> = {\n  fields: Fields\n  relations: Relation[]\n  modelSchema: z.ZodType<Partial<T>>\n  createSchema: z.ZodType<CreateInput<CreateData, Select, Include>>\n  createManySchema: z.ZodType<CreateManyInput<CreateData>>\n  findUniqueSchema: z.ZodType<FindUniqueInput<Select, WhereUnique, Include>>\n  findSchema: z.ZodType<\n    FindInput<Select, Where, Include, OrderBy, ScalarFieldEnum>\n  >\n  updateSchema: z.ZodType<UpdateInput<UpdateData, Select, WhereUnique, Include>>\n  updateManySchema: z.ZodType<UpdateManyInput<UpdateData, Where>>\n  upsertSchema: z.ZodType<\n    UpsertInput<CreateData, UpdateData, Select, WhereUnique, Include>\n  >\n  deleteSchema: z.ZodType<DeleteInput<Select, WhereUnique, Include>>\n  deleteManySchema: z.ZodType<DeleteManyInput<Where>>\n}\n\nexport type ExtendedTableSchema<\n  T extends Record<string, any>,\n  CreateData extends object,\n  UpdateData extends object,\n  Select,\n  Where extends object | undefined,\n  WhereUnique extends object,\n  Include extends Record<string, any>,\n  OrderBy,\n  ScalarFieldEnum,\n  GetPayload extends HKT\n> = TableSchema<\n  T,\n  CreateData,\n  UpdateData,\n  Select,\n  Where,\n  WhereUnique,\n  Include,\n  OrderBy,\n  ScalarFieldEnum,\n  GetPayload\n> & {\n  outgoingRelations: Relation[]\n  incomingRelations: Relation[]\n}\n\nexport type TableSchemas = Record<\n  TableName,\n  TableSchema<any, any, any, any, any, any, any, any, any, HKT>\n>\n\nexport type ExtendedTableSchemas = Record<\n  TableName,\n  ExtendedTableSchema<any, any, any, any, any, any, any, any, any, HKT>\n>\n\nexport class Relation {\n  constructor(\n    public relationField: FieldName,\n    public fromField: FieldName,\n    public toField: FieldName,\n    public relatedTable: TableName,\n    public relationName: RelationName,\n    // 'one' if this object can have only one related object,\n    // 'many' if this object potentially has many related objects\n    public relatedObjects: Arity\n  ) {}\n\n  isIncomingRelation(): boolean {\n    return this.fromField === '' && this.toField === ''\n  }\n\n  isOutgoingRelation(): boolean {\n    return !this.isIncomingRelation()\n  }\n\n  getOppositeRelation(dbDescription: DbSchema<any>): Relation {\n    return dbDescription.getRelation(this.relatedTable, this.relationName)\n  }\n}\n\nexport class DbSchema<T extends TableSchemas> {\n  public readonly extendedTables: ExtendedTableSchemas\n\n  // index mapping fields to an array of relations that map to that field\n  private readonly incomingRelationsIndex: Record<\n    TableName,\n    Record<FieldName, Array<Relation>>\n  >\n\n  /**\n   * @param tables Description of the database tables\n   * @param migrations Bundled SQLite migrations\n   * @param pgMigrations Bundled Postgres migrations\n   */\n  constructor(\n    public tables: T,\n    public migrations: Migration[],\n    public pgMigrations: Migration[]\n  ) {\n    this.extendedTables = this.extend(tables)\n    this.incomingRelationsIndex = this.indexIncomingRelations()\n  }\n\n  private extend(tbls: T): ExtendedTableSchemas {\n    // map over object fields, then take the relations and then split them into 2 parts based on\n    // isIncomingRelation and isOutgoingRelation\n    return mapValues(tbls, (descr) => {\n      const [incoming, outgoing] = partition(descr.relations, (r) =>\n        r.isIncomingRelation()\n      )\n      return {\n        ...descr,\n        incomingRelations: incoming,\n        outgoingRelations: outgoing,\n      }\n    })\n  }\n\n  private indexIncomingRelations(): Record<\n    TableName,\n    Record<FieldName, Array<Relation>>\n  > {\n    const tableNames = Object.keys(this.extendedTables)\n    const buildRelationIndex = (tableName: TableName) => {\n      // For each incoming relation we store the field that is pointed at by the relation\n      // Several relations may point to the same field.\n      // Therefore, we first group the incoming relations based on the field that they point to\n      // Then we store those relations per field\n      const inRelations = this.getIncomingRelations(tableName)\n      return groupBy(inRelations, (relation) => {\n        // group the relations by their `toField` property\n        // but need to fetch that property on the outgoing side of the relation\n        return relation.getOppositeRelation(this).toField\n      })\n    }\n\n    const obj: Record<TableName, Record<FieldName, Array<Relation>>> = {}\n    tableNames.forEach((tableName) => {\n      obj[tableName] = buildRelationIndex(tableName)\n    })\n\n    return obj\n  }\n\n  hasTable(table: TableName): boolean {\n    return Object.keys(this.extendedTables).includes(table)\n  }\n\n  getTableDescription(\n    table: TableName\n  ): ExtendedTableSchema<any, any, any, any, any, any, any, any, any, HKT> {\n    return this.extendedTables[table]\n  }\n\n  getFields(table: TableName): Fields {\n    return this.extendedTables[table].fields\n  }\n\n  getFieldNames(table: TableName): FieldName[] {\n    return Array.from(this.getFields(table).keys())\n  }\n\n  hasRelationForField(table: TableName, field: FieldName): boolean {\n    return this.getRelations(table).some((r) => r.relationField === field)\n  }\n\n  getRelationName(table: TableName, field: FieldName): RelationName {\n    return this.getRelations(table).find((r) => r.relationField === field)!\n      .relationName\n  }\n\n  getRelation(table: TableName, relation: RelationName): Relation {\n    return this.getRelations(table).find((r) => r.relationName === relation)!\n  }\n\n  getRelatedTable(table: TableName, field: FieldName): TableName {\n    const relationName = this.getRelationName(table, field)\n    const relation = this.getRelation(table, relationName)\n    return relation.relatedTable\n  }\n\n  getForeignKey(table: TableName, field: FieldName): FieldName {\n    const relationName = this.getRelationName(table, field)\n    const relation = this.getRelation(table, relationName)\n    if (relation.isOutgoingRelation()) {\n      return relation.fromField\n    }\n    // it's an incoming relation\n    // we need to fetch the `fromField` from the outgoing relation\n    const oppositeRelation = relation.getOppositeRelation(this)\n    return oppositeRelation.fromField\n  }\n\n  // Profile.post <-> Post.profile (from: profileId, to: id)\n  getRelations(table: TableName): Relation[] {\n    return this.extendedTables[table].relations\n  }\n\n  getOutgoingRelations(table: TableName): Relation[] {\n    return this.extendedTables[table].outgoingRelations\n  }\n\n  getIncomingRelations(table: TableName): Relation[] {\n    return this.extendedTables[table].incomingRelations\n  }\n\n  getRelationsPointingAtField(table: TableName, field: FieldName): Relation[] {\n    const index = this.incomingRelationsIndex[table]\n    const relations = index[field]\n    if (typeof relations === 'undefined') return []\n    else return relations\n  }\n}\n"],"mappings":"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","names":[]}