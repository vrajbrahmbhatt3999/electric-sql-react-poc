import { CreateInput, CreateManyInput } from '../input/createInput.js';
import { FindInput, FindUniqueInput } from '../input/findInput.js';
import { SyncInput } from '../input/syncInput.js';
import { UpdateInput, UpdateManyInput } from '../input/updateInput.js';
import { DeleteInput, DeleteManyInput } from '../input/deleteInput.js';
import { DatabaseAdapter } from '../../electric/adapter.js';
import { BatchPayload } from '../output/batchPayload.js';
import { UpsertInput } from '../input/upsertInput.js';
import { SelectSubset } from '../util/types.js';
import { DB } from '../execution/db.js';
import { LiveResultContext, Model } from './model.js';
import { Notifier } from '../../notifiers/index.js';
import { DbSchema, TableName } from './schema.js';
import { HKT, Kind } from '../util/hkt.js';
import { Row, Statement, ReplicatedRowTransformer } from '../../util/index.js';
import { IShapeManager } from './shapes.js';
import { ShapeSubscription } from '../../satellite/index.js';
import { Shape } from '../../satellite/shapes/types.js';
import { IReplicationTransformManager } from './transforms.js';
import { InputTransformer } from '../conversions/input.js';
import { Dialect } from '../../migrators/query-builder/builder.js';
type AnyTable = Table<any, any, any, any, any, any, any, any, any, HKT>;
export declare class Table<T extends Record<string, any>, CreateData extends object, UpdateData extends object, Select, Where extends object | undefined, WhereUnique extends object, Include extends Record<string, any>, OrderBy, ScalarFieldEnum, GetPayload extends HKT> implements Model<T, CreateData, UpdateData, Select, Where, WhereUnique, Include, OrderBy, ScalarFieldEnum, GetPayload> {
    tableName: string;
    private _notifier;
    private _shapeManager;
    private _replicationTransformManager;
    private _dbDescription;
    private _transformer;
    dialect: Dialect;
    private _builder;
    private _executor;
    private _qualifiedTableName;
    private _tables;
    private _fields;
    private _schema;
    private createSchema;
    private createManySchema;
    private findUniqueSchema;
    private findSchema;
    private updateSchema;
    private updateManySchema;
    private upsertSchema;
    private deleteSchema;
    private deleteManySchema;
    private syncSchema;
    constructor(tableName: string, adapter: DatabaseAdapter, _notifier: Notifier, _shapeManager: IShapeManager, _replicationTransformManager: IReplicationTransformManager, _dbDescription: DbSchema<any>, _transformer: InputTransformer, dialect: Dialect);
    setTables(tables: Map<TableName, AnyTable>): void;
    protected computeShape<T extends SyncInput<Include, Where>>(i: T): Shape;
    protected getIncludedTables<T extends SyncInput<Include, unknown>>(i: T): Set<AnyTable>;
    sync<T extends SyncInput<Include, Where>>(i?: T): Promise<ShapeSubscription>;
    create<T extends CreateInput<CreateData, Select, Include>>(i: SelectSubset<T, CreateInput<CreateData, Select, Include>>): Promise<Kind<GetPayload, T>>;
    createMany<T extends CreateManyInput<CreateData>>(i: SelectSubset<T, CreateManyInput<CreateData>>): Promise<BatchPayload>;
    findUnique<T extends FindUniqueInput<Select, WhereUnique, Include>>(i: SelectSubset<T, FindUniqueInput<Select, WhereUnique, Include>>): Promise<Kind<GetPayload, T> | null>;
    liveUnique<T extends FindUniqueInput<Select, WhereUnique, Include>>(i: SelectSubset<T, FindUniqueInput<Select, WhereUnique, Include>>): LiveResultContext<Kind<GetPayload, T> | null>;
    findFirst<T extends FindInput<Select, Where, Include, OrderBy, ScalarFieldEnum>>(i?: SelectSubset<T, FindInput<Select, Where, Include, OrderBy, ScalarFieldEnum>>): Promise<Kind<GetPayload, T> | null>;
    liveFirst<T extends FindInput<Select, Where, Include, OrderBy, ScalarFieldEnum>>(i?: SelectSubset<T, FindInput<Select, Where, Include, OrderBy, ScalarFieldEnum>>): LiveResultContext<Kind<GetPayload, T> | null>;
    findMany<T extends FindInput<Select, Where, Include, OrderBy, ScalarFieldEnum>>(i?: SelectSubset<T, FindInput<Select, Where, Include, OrderBy, ScalarFieldEnum>>): Promise<Array<Kind<GetPayload, T>>>;
    liveMany<T extends FindInput<Select, Where, Include, OrderBy, ScalarFieldEnum>>(i?: SelectSubset<T, FindInput<Select, Where, Include, OrderBy, ScalarFieldEnum>>): LiveResultContext<Kind<GetPayload, T>[]>;
    update<T extends UpdateInput<UpdateData, Select, WhereUnique, Include>>(i: SelectSubset<T, UpdateInput<UpdateData, Select, WhereUnique, Include>>): Promise<Kind<GetPayload, T>>;
    updateMany<T extends UpdateManyInput<UpdateData, Where>>(i: SelectSubset<T, UpdateManyInput<UpdateData, Where>>): Promise<BatchPayload>;
    upsert<T extends UpsertInput<CreateData, UpdateData, Select, WhereUnique, Include>>(i: SelectSubset<T, UpsertInput<CreateData, UpdateData, Select, WhereUnique, Include>>): Promise<Kind<GetPayload, T>>;
    delete<T extends DeleteInput<Select, WhereUnique, Include>>(i: SelectSubset<T, DeleteInput<Select, WhereUnique, Include>>): Promise<Kind<GetPayload, T>>;
    deleteMany<T extends DeleteManyInput<Where>>(i?: SelectSubset<T, DeleteManyInput<Where>>): Promise<BatchPayload>;
    private forEachRelation;
    private forEachOutgoingRelation;
    protected _create<T extends CreateInput<CreateData, Select, Include>>(i: SelectSubset<T, CreateInput<CreateData, Select, Include>>, db: DB, continuation: (record: Kind<GetPayload, T> & Record<string, any>) => void, onError: (err: any) => void): void;
    private _createMany;
    private _findUnique;
    private _findFirst;
    /**
     * Joins objects in `rows` with objects in `relatedRows` where `row.fromField === relatedRow.toField`.
     * Beware: this function mutates the objects in `rows`.
     * @param rows Array of original objects
     * @param relatedRows Array of related objects
     * @param fromField Field of objects in `rows` that points to related object.
     * @param toField Field of objects in `relatedRows` that is pointed at by the original object.
     */
    private joinObjects;
    private fetchRelated;
    private fetchInclude;
    private fetchIncludes;
    private _findMany;
    private _findUniqueWithoutAutoSelect;
    /**
     * Updates the related object of a one-to-one relation (when `updateType === 'update'`)
     * or many related objects from a one-to-many relation (when `updateType === 'updateMany'`).
     * The related object(s) is one or more rows from the `relatedTable` that matches the `obj.where` argument
     * and where the value of `toField` equals `fromFieldValue`.
     */
    private updateRelatedObject;
    /**
     * Takes the original object and the updated object
     * and updates foreign keys of related objects
     * that were pointing at a field that got updated.
     * @param cont Function to call after the foreign keys are updated.
     */
    private updateFKs;
    /**
     * Updates related objects for incoming relations based on
     * nested `updateMany` argument that is provided with `update`.
     *
     * @example
     * The example below updates the title of all posts written by `user1`.
     * In the `User` table there is an incoming relation from each post to the user that wrote it.
     * This method updates all related objects for such an incoming relation:
     * ```
     * User.update({
     *   data: {
     *     posts: {
     *       updateMany: {
     *         data: {
     *           title: 'A new title for all my posts'
     *         },
     *         where: {}
     *       }
     *     }
     *   },
     *   where: {
     *     id: user1.id
     *   }
     * })
     * ```
     *
     * @param relatedTable The name of the table containing the related objects.
     * @param relationName The name of the relation between the two tables.
     * @param ogObject The object on which `update` is called, before the update is executed.
     * @param updateManyObject The object that was passed as `updateMany` argument to `update`.
     * @param onError Error handler callback.
     * @param cont Function that will be called once the related objects are updated.
     */
    private updateManyRelatedObjectsFromIncomingRelation;
    /**
     * Updates related objects for incoming relations based on
     * nested `update` argument that is provided with `update`.
     * For example:
     *  User.update({
     *    data: {
     *      posts: {
     *        update: {
     *          data: {
     *            title: 'A new title for all my posts'
     *          },
     *          where: {
     *            id: post2.id
     *          }
     *        }
     *      }
     *    },
     *    where: {
     *      id: user1.id
     *    }
     *  })
     * The above example updates the title of post2 that was written by `user1`.
     * This method updates that related object for such incoming relations.
     *
     * @param relatedTable The name of the table containing the related objects.
     * @param relationName The name of the relation between the two tables.
     * @param ogObject The object on which `update` is called, before the update is executed.
     * @param updateObject The object that was passed as nested `update` argument to `update`.
     * @param onError Error handler callback.
     * @param cont Function that will be called once the related objects are updated.
     */
    private updateRelatedObjectFromIncomingRelation;
    private updateRelatedObjectFromOutgoingRelation;
    private _update;
    /**
     * Updates may also include nested updates to related objects.
     * This function updates those related objects as requested by the user.
     */
    private updateRelatedObjects;
    private _updateMany;
    private _upsert;
    private _delete;
    private _deleteMany;
    private makeLiveResult;
    setReplicationTransform(i: ReplicatedRowTransformer<T>): void;
    clearReplicationTransform(): void;
}
export declare function unsafeExec(adapter: DatabaseAdapter, sql: Statement): Promise<Row[]>;
export declare function rawQuery(adapter: DatabaseAdapter, sql: Statement): Promise<Row[]>;
export declare function liveRawQuery(adapter: DatabaseAdapter, notifier: Notifier, sql: Statement): LiveResultContext<Row[]>;
export {};
