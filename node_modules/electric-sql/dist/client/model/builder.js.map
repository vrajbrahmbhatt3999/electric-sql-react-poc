{"version":3,"sources":["../../../src/client/model/builder.ts"],"sourcesContent":["import { CreateInput, CreateManyInput } from '../input/createInput'\nimport squel, {\n  PostgresSelect,\n  QueryBuilder,\n  ReturningMixin,\n  WhereMixin,\n} from 'squel'\nimport { FindInput, FindUniqueInput } from '../input/findInput'\nimport { UpdateInput, UpdateManyInput } from '../input/updateInput'\nimport { DeleteInput, DeleteManyInput } from '../input/deleteInput'\nimport flow from 'lodash.flow'\nimport { InvalidArgumentError } from '../validation/errors/invalidArgumentError'\nimport * as z from 'zod'\nimport { ExtendedTableSchema } from './schema'\nimport { PgBasicType } from '../conversions/types'\nimport { HKT } from '../util/hkt'\nimport { Dialect } from '../../migrators/query-builder/builder'\nimport { isFilterObject } from '../conversions/input'\nimport { escDoubleQ } from '../../util'\n\nconst squelPostgres = squel.useFlavour('postgres')\nsquelPostgres.registerValueHandler('bigint', function (bigint) {\n  return bigint.toString()\n})\nsquelPostgres.registerValueHandler(Uint8Array, function (uint8) {\n  return uint8\n})\n\ntype AnyFindInput = FindInput<any, any, any, any, any>\n\nexport class Builder {\n  private _quotedTableName: string\n\n  constructor(\n    private _tableName: string,\n    private _fields: string[],\n    private _tableDescription: ExtendedTableSchema<\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      HKT\n    >,\n    public dialect: Dialect\n  ) {\n    this._quotedTableName = quoteIdentifier(this._tableName)\n    squelPostgres.cls.DefaultQueryBuilderOptions.nameQuoteCharacter = '\"'\n    squelPostgres.cls.DefaultQueryBuilderOptions.autoQuoteFieldNames = true\n    if (dialect === 'Postgres') {\n      // need to register the Date type\n      // as Squel does not support it out-of-the-box\n      // but our Postgres drivers do support it.\n      squelPostgres.registerValueHandler(Date, (date) => date)\n    } else {\n      // Don't use numbered parameters if dialect is SQLite\n      squelPostgres.cls.DefaultQueryBuilderOptions.numberedParameters = false\n    }\n  }\n\n  create(i: CreateInput<any, any, any>): QueryBuilder {\n    // Make a SQL query out of the data\n    const query = squelPostgres\n      .insert()\n      .into(this._quotedTableName)\n      .setFields(i.data)\n\n    // Adds a `RETURNING` statement that returns all known fields\n    const queryWithReturn = this.returnAllFields(query)\n    return queryWithReturn\n  }\n\n  createMany(i: CreateManyInput<any>): QueryBuilder {\n    const insert = squelPostgres\n      .insert()\n      .into(this._quotedTableName)\n      .setFieldsRows(i.data)\n    return i.skipDuplicates\n      ? insert.onConflict() // adds \"ON CONFLICT DO NOTHING\" to the query\n      : insert\n  }\n\n  findUnique(i: FindUniqueInput<any, any, any>): QueryBuilder {\n    return this.findWhere({ ...i, take: 2 }, true) // take 2 such that we can throw an error if more than one record matches\n  }\n\n  findFirst(i: AnyFindInput): QueryBuilder {\n    return this.findWhere({ ...i, take: 1 })\n  }\n\n  findMany(i: AnyFindInput): QueryBuilder {\n    return this.findWhere(i)\n  }\n\n  // Finds a record but does not select the fields provided in the `where` argument\n  // whereas `findUnique`, `findFirst`, and `findMany` also automatically select the fields in `where`\n  findWithoutAutoSelect(i: AnyFindInput): QueryBuilder {\n    return this.findWhere(i, false, false)\n  }\n\n  update(i: UpdateInput<any, any, any, any>): QueryBuilder {\n    return this.updateInternal(i, true)\n  }\n\n  updateMany(i: UpdateManyInput<any, any>): QueryBuilder {\n    return this.updateInternal(i)\n  }\n\n  delete(i: DeleteInput<any, any, any>): QueryBuilder {\n    return this.deleteInternal(i, true)\n  }\n\n  deleteMany(i: DeleteManyInput<any>): QueryBuilder {\n    return this.deleteInternal(i)\n  }\n\n  private deleteInternal(\n    i: DeleteManyInput<any>,\n    idRequired = false\n  ): QueryBuilder {\n    const deleteQuery = squelPostgres.delete().from(this._quotedTableName)\n    const whereObject = i.where // safe because the schema for `where` adds an empty object as default which is provided if the `where` field is absent\n    const fields = this.getFields(whereObject, idRequired)\n    return addFilters(fields, whereObject, deleteQuery)\n  }\n\n  private updateInternal(\n    i: UpdateManyInput<any, any>,\n    idRequired = false\n  ): QueryBuilder {\n    const unsupportedEntry = Object.entries(i.data).find((entry) => {\n      const [_key, value] = entry\n      return isFilterObject(value)\n    })\n    if (unsupportedEntry)\n      throw new InvalidArgumentError(\n        `Unsupported value ${JSON.stringify(unsupportedEntry[1])} for field \"${\n          unsupportedEntry[0]\n        }\" in update query.`\n      )\n\n    const query = squelPostgres\n      .update()\n      .table(this._quotedTableName)\n      .setFields(i.data)\n\n    // Adds a `RETURNING` statement that returns all known fields\n    const queryWithReturn = this.returnAllFields(query)\n\n    const whereObject = i.where // safe because the schema for `where` adds an empty object as default which is provided if the `where` field is absent\n    const fields = this.getFields(whereObject, idRequired)\n    return addFilters(fields, whereObject, queryWithReturn)\n  }\n\n  /**\n   * Creates a `SELECT fields FROM table WHERE conditions` query.\n   * @param i Object containing optional `where` and `selection` fields.\n   * @param idRequired If true, will throw an error if no fields are provided in the `where` argument.\n   * @param selectWhereFields By default, `findWhere` selects the fields provided in the `where` argument. By providing `false` it will not automatically select those fields.\n   */\n  private findWhere(\n    i: FindInput<any, any, any, any, any>,\n    idRequired = false,\n    selectWhereFields = true\n  ): QueryBuilder {\n    if ('cursor' in i && typeof i.cursor !== 'undefined') {\n      throw new InvalidArgumentError('Unsupported cursor argument.')\n    }\n\n    const whereObject = i.where\n    const identificationFields = this.getFields(whereObject, idRequired)\n\n    // don't autoquote field names in the selection\n    // because if a field is a BigInt we cast it\n    // and squel would add quotes around the entire cast\n    const query = squelPostgres\n      .select({ autoQuoteFieldNames: false })\n      .from(this._quotedTableName) // specify from which table to select\n    // only select the fields provided in `i.select` and the ones in `i.where`\n    const addFieldSelectionP = this.addFieldSelection.bind(\n      this,\n      i,\n      selectWhereFields ? identificationFields : []\n    )\n    // add a where clause to filter on the conditions provided in `i.where`\n    const addFiltersP = addFilters.bind(null, identificationFields, whereObject)\n    const addLimitP = addLimit.bind(null, i)\n    const addOffsetP = addOffset.bind(null, i)\n    const addDistinctP = addDistinct.bind(null, i)\n    const addOrderByP = this.addOrderBy.bind(this, i)\n    const buildQuery = flow(\n      addFieldSelectionP,\n      addFiltersP,\n      addLimitP,\n      addOffsetP,\n      addDistinctP,\n      addOrderByP\n    )\n    return buildQuery(query)\n  }\n\n  private addFieldSelection(\n    i: AnyFindInput,\n    identificationFields: string[],\n    q: PostgresSelect\n  ): PostgresSelect {\n    if (typeof i.select === 'undefined') {\n      // Select all known fields explicitly\n      // which is safer than executing a SELECT * query\n      i.select = {}\n      this._fields.forEach((field) => {\n        i.select[field as keyof typeof i.select] = true\n      })\n    }\n\n    const selectedFields = getSelectedFields(i.select)\n    if (selectedFields.length === 0)\n      throw new InvalidArgumentError(\n        `The \\`select\\` statement for type ${this._tableName} needs at least one truthy value.`\n      )\n\n    const unknownField: string | undefined = selectedFields.find(\n      (f) => !this._fields.includes(f)\n    )\n    if (unknownField) {\n      // query selects a field that does not exist on this table\n      throw new InvalidArgumentError(\n        `Cannot select field ${unknownField} on table ${this._tableName}. Use 'include' to fetch related objects.`\n      )\n    }\n\n    // the filter below removes boolean filters like AND, OR, NOT\n    // which are not columns and thus should not be selected\n    const fields = identificationFields\n      .filter((f) => this._fields.includes(f))\n      .concat(selectedFields)\n      .map((f) => this.castBigIntToText(f))\n\n    return q.fields(fields)\n  }\n\n  /**\n   * Casts a field to TEXT if it is of type BigInt\n   * because not all adapters deal well with BigInts\n   * (e.g. better-sqlite3 requires BigInt support to be enabled\n   *       but then all integers are returned as BigInt...)\n   * The DAL will convert the string into a BigInt in the `fromSqlite` function from `../conversions/sqlite.ts`.\n   */\n  private castBigIntToText(field: string) {\n    const pgType = this._tableDescription.fields.get(field)\n    if (pgType === PgBasicType.PG_INT8 && this.dialect === 'SQLite') {\n      const quotedField = quoteIdentifier(field)\n      return `cast(${quotedField} as TEXT) AS ${quotedField}`\n    }\n    return quoteIdentifier(field)\n  }\n\n  private addOrderBy(i: AnyFindInput, q: PostgresSelect): PostgresSelect {\n    if (typeof i.orderBy === 'undefined') return q\n    const orderByArray = Array.isArray(i.orderBy) ? i.orderBy : [i.orderBy]\n\n    return orderByArray.reduce((query: PostgresSelect, orderBy: object) => {\n      // Don't accept more than one field in `fieldOrdering` because we can't infer the order of those fields!\n      // If we need to order on several fields, they should be provided as several OrderByInput objects in an array.\n      const fields = Object.keys(orderBy)\n      if (fields.length > 1)\n        throw new InvalidArgumentError(\n          `Argument 'orderBy' can have at most one field per 'OrderByInput' object. Consider providing several 'OrderByInput' objects in an array.`\n        )\n      if (fields.length === 0) return query\n\n      const field = fields[0]\n      const order = orderBy[field as keyof object]\n\n      if (typeof order === 'object' && order !== null)\n        throw new InvalidArgumentError(\n          `Ordering query results based on the '${field}' related object(s) is not yet supported`\n        )\n\n      const squelOrder = order === 'asc' // squel expects 'true' for ascending order, 'false' for descending order\n      // have to quote the field name ourselves\n      // because Squel does not seem to auto quote\n      // field names in order by statements\n      return query.order(quoteIdentifier(field), squelOrder)\n    }, q)\n  }\n\n  private getFields(whereObject?: object, fieldsRequired = false) {\n    const obj = typeof whereObject !== 'undefined' ? whereObject : {} // provide empty object if no `where` argument is provided\n    const fields = Object.keys(obj)\n\n    if (fieldsRequired && fields.length === 0)\n      throw new InvalidArgumentError(\n        `Argument \\`where\\` for query on ${this._tableName} type requires at least one argument.`\n      )\n\n    return fields\n  }\n\n  private returnAllFields<T extends QueryBuilder & ReturningMixin>(\n    query: T\n  ): T {\n    return this._fields.reduce((query, field) => {\n      // if field is of type BigInt cast the result to TEXT\n      // because not all adapters deal well with BigInts\n      // the DAL will convert the string into a BigInt in the `fromSqlite` function from `../conversions/sqlite.ts`.\n      const pgType = this._tableDescription.fields.get(field)\n      if (pgType === PgBasicType.PG_INT8 && this.dialect === 'SQLite') {\n        // make a raw string and quote the field name ourselves\n        // because otherwise Squel would add quotes around the entire cast\n        const quotedField = quoteIdentifier(field)\n        const f = squelPostgres.rstr(\n          `cast(${quotedField} as TEXT) AS ${quotedField}`\n        )\n        return query.returning(f)\n      }\n      return query.returning(field)\n    }, query)\n  }\n}\n\n/**\n * Adds filters to the provided query based on the provided `where` object.\n *\n * @param fields - Fields of the `whereObject` argument.\n * @param whereObject - The `where` argument provided by the user.\n * @param q - The SQL query.\n */\nfunction addFilters<T, Q extends QueryBuilder & WhereMixin>(\n  fields: string[],\n  whereObject: T,\n  q: Q\n): Q {\n  return fields.reduce<Q>((query: Q, fieldName: string) => {\n    const fieldValue = whereObject[fieldName as keyof T]\n    const filters = makeFilter(fieldValue, fieldName)\n    return filters.reduce((query, filter) => {\n      return query.where(filter.sql, ...(filter.args ?? [])) as Q\n    }, query)\n  }, q)\n}\n\nexport function makeFilter(\n  fieldValue: unknown,\n  fieldName: string,\n  prefixFieldsWith = ''\n): Array<{ sql: string; args?: unknown[] }> {\n  if (fieldValue === null)\n    return [{ sql: `${prefixFieldsWith}${quoteIdentifier(fieldName)} IS NULL` }]\n  else if (fieldName === 'AND' || fieldName === 'OR' || fieldName === 'NOT') {\n    return [\n      makeBooleanFilter(\n        fieldName as 'AND' | 'OR' | 'NOT',\n        fieldValue,\n        prefixFieldsWith\n      ),\n    ]\n  } else if (isFilterObject(fieldValue)) {\n    // an object containing filters is provided\n    // e.g. users.findMany({ where: { id: { in: [1, 2, 3] } } })\n    const fs = {\n      equals: z.any(),\n      in: z.any().array().optional(),\n      not: z.any().optional(),\n      notIn: z.any().optional(),\n      lt: z.any().optional(),\n      lte: z.any().optional(),\n      gt: z.any().optional(),\n      gte: z.any().optional(),\n      startsWith: z.string().optional(),\n      endsWith: z.string().optional(),\n      contains: z.string().optional(),\n    }\n\n    const fsHandlers = {\n      equals: makeEqualsFilter.bind(null),\n      in: makeInFilter.bind(null),\n      not: makeNotFilter.bind(null),\n      notIn: makeNotInFilter.bind(null),\n      lt: makeLtFilter.bind(null),\n      lte: makeLteFilter.bind(null),\n      gt: makeGtFilter.bind(null),\n      gte: makeGteFilter.bind(null),\n      startsWith: makeStartsWithFilter.bind(null),\n      endsWith: makeEndsWithFilter.bind(null),\n      contains: makeContainsFilter.bind(null),\n    }\n\n    const filterSchema = z\n      .object(fs)\n      .strict()\n      .refine(\n        (data) => Object.keys(fs).some((filter) => filter in data),\n        'Please provide at least one filter.'\n      )\n    // TODO: remove this schema check once we support all filters\n    //       or remove the unsupported filters from the types and schemas that are generated from the Prisma schema\n\n    const obj = filterSchema.parse(fieldValue)\n    const filters: Array<{ sql: string; args?: unknown[] }> = []\n\n    Object.entries(fsHandlers).forEach((entry) => {\n      const [filter, handler] = entry\n      if (filter in obj) {\n        const sql = handler(\n          prefixFieldsWith + quoteIdentifier(fieldName),\n          obj[filter as keyof typeof obj]\n        )\n        filters.push(sql)\n      }\n    })\n\n    return filters\n  }\n  // needed because `WHERE field = NULL` is not valid SQL\n  else\n    return [\n      {\n        sql: `${prefixFieldsWith}${quoteIdentifier(fieldName)} = ?`,\n        args: [fieldValue],\n      },\n    ]\n}\n\nfunction joinStatements(\n  statements: Array<{ sql: string; args?: unknown[] }>,\n  connective: 'OR' | 'AND'\n): { sql: string; args?: unknown[] } {\n  const sql = statements.map((s) => s.sql).join(` ${connective} `)\n  const args = statements\n    .map((s) => s.args)\n    .reduce((a1, a2) => (a1 ?? []).concat(a2 ?? []))\n  return { sql, args }\n}\n\nfunction makeBooleanFilter(\n  fieldName: 'AND' | 'OR' | 'NOT',\n  value: unknown,\n  prefixFieldsWith: string\n): { sql: string; args?: unknown[] } {\n  const objects = Array.isArray(value) ? value : [value] // the value may be a single object or an array of objects connected by the provided connective (AND, OR, NOT)\n  const sqlStmts = objects.map((obj) => {\n    // Make the necessary filters for this object:\n    //  - a filter for each field of this object\n    //  - connect those filters into 1 filter using AND\n    const fields = Object.keys(obj)\n    const stmts = fields.reduce(\n      (stmts: Array<{ sql: string; args?: unknown[] }>, fieldName) => {\n        const fieldValue = obj[fieldName as keyof typeof obj]\n        const stmts2 = makeFilter(fieldValue, fieldName, prefixFieldsWith)\n        return stmts.concat(stmts2)\n      },\n      []\n    )\n    return joinStatements(stmts, 'AND')\n  })\n\n  if (fieldName === 'NOT') {\n    // Every statement in `sqlStmts` must be negated\n    // and the negated statements must then be connected by a conjunction (i.e. using AND)\n    const statements = sqlStmts.map(({ sql, args }) => {\n      return {\n        sql: sqlStmts.length > 1 ? `(NOT ${sql})` : `NOT ${sql}`, // ternary if to avoid obsolete parentheses\n        args: args,\n      }\n    })\n    return joinStatements(statements, 'AND')\n  } else {\n    // Join all filters in `sqlStmts` using the requested connective (which is 'OR' or 'NOT')\n    return joinStatements(sqlStmts, fieldName)\n  }\n}\n\nfunction makeEqualsFilter(\n  fieldName: string,\n  value: unknown | undefined\n): { sql: string; args?: unknown[] } {\n  return { sql: `${fieldName} = ?`, args: [value] }\n}\n\nfunction makeInFilter(\n  fieldName: string,\n  values: unknown[] | undefined\n): { sql: string; args?: unknown[] } {\n  return { sql: `${fieldName} IN ?`, args: [values] }\n}\n\nfunction makeNotInFilter(\n  fieldName: string,\n  values: unknown[] | undefined\n): { sql: string; args?: unknown[] } {\n  return { sql: `${fieldName} NOT IN ?`, args: [values] }\n}\n\nfunction makeNotFilter(\n  fieldName: string,\n  value: unknown\n): { sql: string; args?: unknown[] } {\n  if (value === null) {\n    // needed because `WHERE field != NULL` is not valid SQL\n    return { sql: `${fieldName} IS NOT NULL` }\n  } else {\n    return { sql: `${fieldName} != ?`, args: [value] }\n  }\n}\n\nfunction makeLtFilter(\n  fieldName: string,\n  value: unknown\n): { sql: string; args?: unknown[] } {\n  return { sql: `${fieldName} < ?`, args: [value] }\n}\n\nfunction makeLteFilter(\n  fieldName: string,\n  value: unknown\n): { sql: string; args?: unknown[] } {\n  return { sql: `${fieldName} <= ?`, args: [value] }\n}\n\nfunction makeGtFilter(\n  fieldName: string,\n  value: unknown\n): { sql: string; args?: unknown[] } {\n  return { sql: `${fieldName} > ?`, args: [value] }\n}\n\nfunction makeGteFilter(\n  fieldName: string,\n  value: unknown\n): { sql: string; args?: unknown[] } {\n  return { sql: `${fieldName} >= ?`, args: [value] }\n}\n\nfunction makeStartsWithFilter(\n  fieldName: string,\n  value: unknown\n): { sql: string; args?: unknown[] } {\n  if (typeof value !== 'string')\n    throw new Error('startsWith filter must be a string')\n  return {\n    sql: `${fieldName} LIKE ?`,\n    args: [`${escapeLike(value)}%`],\n  }\n}\n\nfunction makeEndsWithFilter(\n  fieldName: string,\n  value: unknown\n): { sql: string; args?: unknown[] } {\n  if (typeof value !== 'string')\n    throw new Error('endsWith filter must be a string')\n  return {\n    sql: `${fieldName} LIKE ?`,\n    args: [`%${escapeLike(value)}`],\n  }\n}\n\nfunction makeContainsFilter(\n  fieldName: string,\n  value: unknown\n): { sql: string; args?: unknown[] } {\n  if (typeof value !== 'string')\n    throw new Error('contains filter must be a string')\n  return {\n    sql: `${fieldName} LIKE ?`,\n    args: [`%${escapeLike(value)}%`],\n  }\n}\n\nfunction escapeLike(value: string): string {\n  return value.replaceAll(/(%|_)/g, '\\\\$1')\n}\n\nfunction addOffset(i: AnyFindInput, q: PostgresSelect): PostgresSelect {\n  if (typeof i.skip === 'undefined') return q // no offset\n  return q.offset(i.skip)\n}\n\nfunction addLimit(i: AnyFindInput, q: PostgresSelect): PostgresSelect {\n  if (typeof i.take === 'undefined') return q // no limit\n  return q.limit(i.take)\n}\n\nfunction addDistinct(i: AnyFindInput, q: PostgresSelect): PostgresSelect {\n  if (typeof i.distinct === 'undefined') return q\n  // have to quote the fields ourselves\n  // because Squel does not seem to auto quote\n  // field names in order by statements\n  return q.distinct(...i.distinct.map(quoteIdentifier))\n}\n\n/**\n * Returns an array containing the names of the fields that are set to `true`\n *\n * @param obj - A selection object.\n * @returns Array containing the names of the selected fields.\n */\nfunction getSelectedFields(obj: object): string[] {\n  return Object.keys(obj).filter((key) => obj[key as keyof object])\n}\n\n/**\n * Quotes the identifier, thereby, escaping any quotes in the identifier.\n */\nfunction quoteIdentifier(identifier: string): string {\n  return `\"${escDoubleQ(identifier)}\"`\n}\n"],"mappings":"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","names":["query","stmts","fieldName","stmts2"]}