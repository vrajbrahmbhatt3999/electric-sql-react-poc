{"version":3,"sources":["../../../src/client/model/table.ts"],"sourcesContent":["import { CreateInput, CreateManyInput } from '../input/createInput'\nimport { FindInput, FindUniqueInput } from '../input/findInput'\nimport { SyncInput } from '../input/syncInput'\nimport {\n  parseNestedCreate,\n  omitCountFromSelectAndIncludeSchema,\n  parseNestedUpdate,\n  validate,\n} from '../validation/validation'\nimport { UpdateInput, UpdateManyInput } from '../input/updateInput'\nimport { DeleteInput, DeleteManyInput } from '../input/deleteInput'\nimport { DatabaseAdapter } from '../../electric/adapter'\nimport { Builder, makeFilter } from './builder'\nimport { Executor } from '../execution/executor'\nimport { BatchPayload } from '../output/batchPayload'\nimport { InvalidArgumentError } from '../validation/errors/invalidArgumentError'\nimport { _NOT_UNIQUE_, _RECORD_NOT_FOUND_ } from '../validation/errors/messages'\nimport { UpsertInput } from '../input/upsertInput'\nimport { SelectSubset } from '../util/types'\nimport { DB } from '../execution/db'\nimport { LiveResult, LiveResultContext, Model } from './model'\nimport { QualifiedTablename } from '../../util/tablename'\nimport { Notifier } from '../../notifiers'\nimport { forEach } from '../util/continuationHelpers'\nimport { Arity, DbSchema, Fields, Relation, TableName } from './schema'\nimport { HKT, Kind } from '../util/hkt'\nimport { notNullNotUndefined } from '../util/functions'\nimport pick from 'lodash.pick'\nimport omitBy from 'lodash.omitby'\nimport hasOwn from 'object.hasown'\nimport * as z from 'zod'\nimport {\n  isPotentiallyDangerous,\n  parseTableNames,\n  Row,\n  Statement,\n  createQueryResultSubscribeFunction,\n  isObject,\n  ReplicatedRowTransformer,\n  interpolateSqlArgs,\n} from '../../util'\nimport { NarrowInclude } from '../input/inputNarrowing'\nimport { IShapeManager } from './shapes'\nimport { ShapeSubscription } from '../../satellite'\nimport { Rel, Shape } from '../../satellite/shapes/types'\nimport { IReplicationTransformManager } from './transforms'\nimport { InputTransformer } from '../conversions/input'\nimport { Dialect } from '../../migrators/query-builder/builder'\n\ntype AnyTable = Table<any, any, any, any, any, any, any, any, any, HKT>\n\nexport class Table<\n  T extends Record<string, any>,\n  CreateData extends object,\n  UpdateData extends object,\n  Select,\n  Where extends object | undefined,\n  WhereUnique extends object,\n  Include extends Record<string, any>,\n  OrderBy,\n  ScalarFieldEnum,\n  GetPayload extends HKT\n> implements\n    Model<\n      T,\n      CreateData,\n      UpdateData,\n      Select,\n      Where,\n      WhereUnique,\n      Include,\n      OrderBy,\n      ScalarFieldEnum,\n      GetPayload\n    >\n{\n  private _builder: Builder\n  private _executor: Executor\n  private _qualifiedTableName: QualifiedTablename\n  private _tables: Map<TableName, AnyTable>\n  private _fields: Fields\n\n  private _schema: z.ZodType<Partial<T>>\n  private createSchema: z.ZodType<CreateInput<CreateData, Select, Include>>\n  private createManySchema: z.ZodType<CreateManyInput<CreateData>>\n  private findUniqueSchema: z.ZodType<\n    FindUniqueInput<Select, WhereUnique, Include>\n  >\n  private findSchema: z.ZodType<\n    FindInput<Select, Where, Include, OrderBy, ScalarFieldEnum>\n  >\n  private updateSchema: z.ZodType<\n    UpdateInput<UpdateData, Select, WhereUnique, Include>\n  >\n  private updateManySchema: z.ZodType<UpdateManyInput<UpdateData, Where>>\n  private upsertSchema: z.ZodType<\n    UpsertInput<CreateData, UpdateData, Select, WhereUnique, Include>\n  >\n  private deleteSchema: z.ZodType<DeleteInput<Select, WhereUnique, Include>>\n  private deleteManySchema: z.ZodType<DeleteManyInput<Where>>\n  private syncSchema: z.ZodType<SyncInput<Include, Where>>\n\n  constructor(\n    public tableName: string,\n    adapter: DatabaseAdapter,\n    private _notifier: Notifier,\n    private _shapeManager: IShapeManager,\n    private _replicationTransformManager: IReplicationTransformManager,\n    private _dbDescription: DbSchema<any>,\n    private _transformer: InputTransformer,\n    public dialect: Dialect\n  ) {\n    this._fields = this._dbDescription.getFields(tableName)\n    const fieldNames = this._dbDescription.getFieldNames(tableName)\n    const tableDescription = this._dbDescription.getTableDescription(tableName)\n    this._builder = new Builder(\n      tableName,\n      fieldNames,\n      tableDescription,\n      this.dialect\n    )\n    this._executor = new Executor(\n      adapter,\n      _notifier,\n      this._fields,\n      this._transformer.converter\n    )\n    const namespace = this.dialect === 'Postgres' ? 'public' : 'main'\n    this._qualifiedTableName = new QualifiedTablename(namespace, tableName)\n    this._tables = new Map()\n    this._schema = tableDescription.modelSchema\n    this.createSchema = omitCountFromSelectAndIncludeSchema(\n      tableDescription.createSchema\n    )\n    this.createManySchema = tableDescription.createManySchema\n    this.findUniqueSchema = tableDescription.findUniqueSchema\n    this.findSchema = tableDescription.findSchema\n    this.updateSchema = omitCountFromSelectAndIncludeSchema(\n      tableDescription.updateSchema\n    )\n    this.updateManySchema = tableDescription.updateManySchema\n    this.upsertSchema = tableDescription.upsertSchema\n    this.deleteSchema = tableDescription.deleteSchema\n    this.deleteManySchema = tableDescription.deleteManySchema\n\n    // TODO: The syncSchema currently allows too much\n    //       modify the `where` clause of the schema to allow only the fields\n    //       (no nested relation fields)\n    //       and also change the field types to expect the value type and no nested filter schema allowed\n    this.syncSchema = (tableDescription.findSchema as z.AnyZodObject).pick({\n      include: true,\n    })\n    const shape = (tableDescription.findSchema as z.AnyZodObject).shape.where\n\n    this.syncSchema = (this.syncSchema as any).extend({\n      where: shape.or(z.string().optional()),\n      key: z.string().optional(),\n    })\n  }\n\n  setTables(tables: Map<TableName, AnyTable>) {\n    this._tables = tables\n  }\n\n  protected computeShape<T extends SyncInput<Include, Where>>(i: T): Shape {\n    // Recursively go over the included fields\n    const include = i.include ?? {}\n    const where = i.where ?? ''\n    const includedFields = Object.keys(include)\n    const includedTables = includedFields.map((field: string): Rel => {\n      // Fetch the table that is included\n      const relatedTableName = this._dbDescription.getRelatedTable(\n        this.tableName,\n        field\n      )\n      const fkk = this._dbDescription.getForeignKey(this.tableName, field)\n      const relatedTable = this._tables.get(relatedTableName)!\n\n      // And follow nested includes\n      const includedObj = (include as any)[field]\n      if (\n        typeof includedObj === 'object' &&\n        !Array.isArray(includedObj) &&\n        includedObj !== null\n      ) {\n        // There is a nested include, follow it\n        return {\n          foreignKey: [fkk],\n          select: relatedTable.computeShape(includedObj),\n        }\n      } else if (typeof includedObj === 'boolean' && includedObj) {\n        return {\n          foreignKey: [fkk],\n          select: {\n            tablename: relatedTableName,\n          },\n        }\n      } else {\n        throw new Error(\n          `Unexpected value in include tree for sync: ${JSON.stringify(\n            includedObj\n          )}`\n        )\n      }\n    })\n\n    const whereClause = makeSqlWhereClause(where)\n    return {\n      tablename: this.tableName,\n      include: includedTables,\n      ...(whereClause === '' ? {} : { where: whereClause }),\n    }\n  }\n\n  protected getIncludedTables<T extends SyncInput<Include, unknown>>(\n    i: T\n  ): Set<AnyTable> {\n    // Recursively go over the included fields\n    // and for each field store its table\n    const include = i.include ?? {}\n    const includedFields = Object.keys(include)\n    const includedTables: Set<AnyTable> = new Set([this])\n    includedFields.forEach((field: string) => {\n      // Fetch the table that is included\n      const relatedTableName = this._dbDescription.getRelatedTable(\n        this.tableName,\n        field\n      )\n      const relatedTable = this._tables.get(relatedTableName)!\n      const extendedTable = includedTables.add(relatedTable)\n      // And follow nested includes\n      const includedObj = (include as any)[field]\n      if (isObject(includedObj)) {\n        // There is a nested include, follow it\n        const nestedTables = relatedTable.getIncludedTables(includedObj)\n        nestedTables.forEach((tbl) => extendedTable.add(tbl))\n        return extendedTable\n      } else if (typeof includedObj === 'boolean') {\n        return extendedTable\n      } else {\n        throw new Error(\n          `Unexpected value in include tree for syncShape: ${JSON.stringify(\n            includedObj\n          )}`\n        )\n      }\n    })\n\n    return includedTables\n  }\n\n  sync<T extends SyncInput<Include, Where>>(i?: T): Promise<ShapeSubscription> {\n    const validatedInput = this.syncSchema.parse(i ?? {})\n    const shape = this.computeShape(validatedInput)\n    return this._shapeManager.subscribe([shape], validatedInput.key)\n  }\n\n  /*\n   * The API is implemented in continuation passing style.\n   * Private methods return a function expecting 2 arguments:\n   *   1. a transaction\n   *   2. a continuation\n   * These methods will then execute their query inside the provided transaction and pass the result to the continuation.\n   * As such, one can compose these methods arbitrarily and then run them inside a single transaction.\n   */\n\n  async create<T extends CreateInput<CreateData, Select, Include>>(\n    i: SelectSubset<T, CreateInput<CreateData, Select, Include>>\n  ): Promise<Kind<GetPayload, T>> {\n    // a higher kinded type GetPayload<T>\n    // We have to typecast it because internally when querying the DB we get back a Partial<T>\n    // But since we carefully craft the queries we know that only the selected fields are in that object\n    return this._executor.transaction((db, cont, onError) =>\n      this._create<T>(i, db, cont, onError)\n    )\n  }\n\n  async createMany<T extends CreateManyInput<CreateData>>(\n    i: SelectSubset<T, CreateManyInput<CreateData>>\n  ): Promise<BatchPayload> {\n    return this._executor.execute(this._createMany.bind(this, i))\n  }\n\n  async findUnique<T extends FindUniqueInput<Select, WhereUnique, Include>>(\n    i: SelectSubset<T, FindUniqueInput<Select, WhereUnique, Include>>\n  ): Promise<Kind<GetPayload, T> | null> {\n    return this._executor.execute(\n      (db, cont, onError) => this._findUnique(i, db, cont, onError),\n      false\n    )\n  }\n\n  liveUnique<T extends FindUniqueInput<Select, WhereUnique, Include>>(\n    i: SelectSubset<T, FindUniqueInput<Select, WhereUnique, Include>>\n  ): LiveResultContext<Kind<GetPayload, T> | null> {\n    return this.makeLiveResult(() => this.findUnique(i), i)\n  }\n\n  async findFirst<\n    T extends FindInput<Select, Where, Include, OrderBy, ScalarFieldEnum>\n  >(\n    i?: SelectSubset<\n      T,\n      FindInput<Select, Where, Include, OrderBy, ScalarFieldEnum>\n    >\n  ): Promise<Kind<GetPayload, T> | null> {\n    return this._executor.execute(\n      (db, cont, onError) => this._findFirst(i, db, cont, onError),\n      false\n    )\n  }\n\n  liveFirst<\n    T extends FindInput<Select, Where, Include, OrderBy, ScalarFieldEnum>\n  >(\n    i?: SelectSubset<\n      T,\n      FindInput<Select, Where, Include, OrderBy, ScalarFieldEnum>\n    >\n  ): LiveResultContext<Kind<GetPayload, T> | null> {\n    return this.makeLiveResult(() => this.findFirst(i), i ?? {})\n  }\n\n  async findMany<\n    T extends FindInput<Select, Where, Include, OrderBy, ScalarFieldEnum>\n  >(\n    i?: SelectSubset<\n      T,\n      FindInput<Select, Where, Include, OrderBy, ScalarFieldEnum>\n    >\n  ): Promise<Array<Kind<GetPayload, T>>> {\n    return this._executor.execute(\n      (db, cont, onError) => this._findMany(i, db, cont, onError),\n      false\n    )\n  }\n\n  liveMany<\n    T extends FindInput<Select, Where, Include, OrderBy, ScalarFieldEnum>\n  >(\n    i?: SelectSubset<\n      T,\n      FindInput<Select, Where, Include, OrderBy, ScalarFieldEnum>\n    >\n  ): LiveResultContext<Kind<GetPayload, T>[]> {\n    return this.makeLiveResult(() => this.findMany(i), i ?? {})\n  }\n\n  async update<T extends UpdateInput<UpdateData, Select, WhereUnique, Include>>(\n    i: SelectSubset<T, UpdateInput<UpdateData, Select, WhereUnique, Include>>\n  ): Promise<Kind<GetPayload, T>> {\n    return this._executor.transaction((db, cont, onError) =>\n      this._update(i, db, cont, onError)\n    )\n  }\n\n  async updateMany<T extends UpdateManyInput<UpdateData, Where>>(\n    i: SelectSubset<T, UpdateManyInput<UpdateData, Where>>\n  ): Promise<BatchPayload> {\n    return this._executor.execute(this._updateMany.bind(this, i))\n  }\n\n  async upsert<\n    T extends UpsertInput<CreateData, UpdateData, Select, WhereUnique, Include>\n  >(\n    i: SelectSubset<\n      T,\n      UpsertInput<CreateData, UpdateData, Select, WhereUnique, Include>\n    >\n  ): Promise<Kind<GetPayload, T>> {\n    return this._executor.transaction((db, cont, onError) =>\n      this._upsert(i, db, cont, onError)\n    )\n  }\n\n  async delete<T extends DeleteInput<Select, WhereUnique, Include>>(\n    i: SelectSubset<T, DeleteInput<Select, WhereUnique, Include>>\n  ): Promise<Kind<GetPayload, T>> {\n    return this._executor.transaction((db, cont, onError) =>\n      this._delete(i, db, cont, onError)\n    )\n  }\n\n  async deleteMany<T extends DeleteManyInput<Where>>(\n    i?: SelectSubset<T, DeleteManyInput<Where>>\n  ): Promise<BatchPayload> {\n    return this._executor.execute(this._deleteMany.bind(this, i))\n  }\n\n  private forEachRelation<T extends object>(\n    data: T,\n    f: (rel: Relation, cont: () => void) => void,\n    cont: () => void\n  ) {\n    const relations = this._dbDescription.getRelations(this.tableName)\n\n    forEach(\n      (rel: Relation, cont: () => void) => {\n        if (hasOwn(data, rel.relationField)) {\n          f(rel, cont)\n        } else {\n          cont()\n        }\n      },\n      relations,\n      cont\n    )\n  }\n\n  private forEachOutgoingRelation<T extends object>(\n    data: T,\n    f: (rel: Relation, cont: () => void) => void,\n    cont: () => void\n  ) {\n    this.forEachRelation(\n      data,\n      (rel, cont) => {\n        if (rel.isOutgoingRelation()) {\n          f(rel, cont)\n        } else {\n          cont()\n        }\n      },\n      cont\n    )\n  }\n\n  protected _create<T extends CreateInput<CreateData, Select, Include>>(\n    i: SelectSubset<T, CreateInput<CreateData, Select, Include>>,\n    db: DB,\n    continuation: (record: Kind<GetPayload, T> & Record<string, any>) => void,\n    onError: (err: any) => void\n  ) {\n    const validatedInput = this._transformer.transformCreate(\n      validate(i, this.createSchema),\n      this._fields\n    )\n    const data = validatedInput.data as Record<string, any>\n\n    /*\n     * For each outgoing relation with a provided relation field:\n     *  - fetch the object in the relation field and recursively create that object\n     *  - remember to fill in the FK (i.e. assign the createdObject.toField to fromField in the object we will create)\n     *  - remove this relation field from the object we will create\n     */\n\n    this.forEachOutgoingRelation(\n      data,\n      (rel: Relation, cont: () => void) => {\n        const { fromField, toField, relationField, relatedTable } = rel\n        // fetch the object in the relation field and recursively create that object\n\n        // Return an error if user provided a createMany, connect, connectOrCreate\n        // the former will not be supported because you can pass an array of related objects to `create`\n        // the latter 2 should eventually be implemented at some point\n        const relatedObject = parseNestedCreate(data[relationField]).create\n\n        const relatedTbl = this._tables.get(relatedTable)!\n        relatedTbl._create(\n          { data: relatedObject },\n          db.withTableSchema(relatedTbl._fields),\n          (createdRelatedObject) => {\n            delete data[relationField] // remove the relation field\n            data[fromField] = createdRelatedObject[toField] // fill in the FK\n            cont()\n          },\n          onError\n        )\n      },\n      () => {\n        // Once, we created the related objects above,\n        // we continue and handle the incoming relations.\n\n        /*\n         * For each incoming relation:\n         *  - remove the relation field from this object\n         *  - remember to create the related object and fill in the `toField` of the object we will create as the FK `fromField` of the related object\n         */\n\n        const incomingRelations = this._dbDescription.getIncomingRelations(\n          this.tableName\n        )\n\n        // below `createRelatedObject` reassigns this variable with a function that wraps this one\n        // each wrapper creates an object and calls the wrapped function\n        // at the end, the function below will be called which will call the continuation\n        let makeRelatedObjects: (obj: object, cont: () => void) => void = (\n          _obj,\n          cont: () => void\n        ) => cont()\n\n        const createRelatedObject = (\n          rel: Relation,\n          relatedObject: Record<string, any>\n        ) => {\n          const { relationField, relatedTable, relationName } = rel\n          // remove this relation field\n          delete data[relationField]\n          // create the related object and fill in the FK\n          // i.e. fill in the `fromField` on the related object using this object's `toField`\n          const oldMakeRelatedObjects = makeRelatedObjects\n          makeRelatedObjects = (obj: Record<string, any>, cont: () => void) => {\n            const relatedTbl = this._tables.get(relatedTable)!\n            // the `fromField` and `toField` are defined on the side of the outgoing relation\n            const { fromField, toField } = this._dbDescription.getRelation(\n              relatedTable,\n              relationName\n            )!\n            // Create the related object\n            relatedObject[fromField] = obj[toField] // fill in FK\n            relatedTbl._create(\n              { data: relatedObject },\n              db.withTableSchema(relatedTbl._fields),\n              () => {\n                oldMakeRelatedObjects(obj, cont)\n              },\n              onError\n            )\n          }\n        }\n\n        incomingRelations.forEach((rel: Relation) => {\n          const { relationField } = rel\n          if (hasOwn(data, relationField)) {\n            const relatedObjects = parseNestedCreate(data[relationField]).create\n            if (Array.isArray(relatedObjects)) {\n              // this is a one-to-many relation\n              // create all the related objects\n              relatedObjects.forEach(createRelatedObject.bind(this, rel))\n            } else {\n              // this is a one-to-one relation\n              // create the related object\n              createRelatedObject(rel, relatedObjects)\n            }\n          }\n        })\n\n        /*\n         * Now create the object and then:\n         *  - create the related objects for the incoming relations\n         */\n\n        // Make a SQL query out of the parsed data\n        const createQuery = this._builder.create({\n          ...validatedInput,\n          data: data,\n        })\n\n        db.query(\n          createQuery,\n          this._schema,\n          (db, insertedObjects) => {\n            if (insertedObjects.length !== 1)\n              onError('Wrong amount of objects were created.')\n\n            // Now, create the related objects\n            const insertedObject = insertedObjects[0]\n            makeRelatedObjects(insertedObject, () => {\n              // Now read the record that was inserted\n              // need to read it because some fields could be auto-generated\n              // it would be enough to select on a unique ID, but we don't know which field(s) is the unique ID\n              // hence, for now `findCreated` filters on all the values that are provided in `validatedInput.data`\n              this._findUniqueWithoutAutoSelect(\n                {\n                  where: data,\n                  select: validatedInput.select,\n                  ...(notNullNotUndefined(validatedInput.include) && {\n                    include: validatedInput.include,\n                  }), // only add `include` property if it is defined\n                } as any,\n                db,\n                continuation as any,\n                onError,\n                'Create'\n              )\n            })\n          },\n          onError\n        )\n      }\n    )\n  }\n\n  private _createMany<T extends CreateManyInput<CreateData>>(\n    i: SelectSubset<T, CreateManyInput<CreateData>>,\n    db: DB,\n    continuation: (res: BatchPayload) => void,\n    onError: (err: any) => void\n  ) {\n    const data = this._transformer.transformCreateMany(\n      validate(i, this.createManySchema),\n      this._fields\n    )\n    const sql = this._builder.createMany(data)\n    db.run(\n      sql,\n      (_, { rowsAffected }) => {\n        continuation({ count: rowsAffected })\n      },\n      onError\n    )\n  }\n\n  private _findUnique<T extends FindUniqueInput<Select, WhereUnique, Include>>(\n    i: SelectSubset<T, FindUniqueInput<Select, WhereUnique, Include>>,\n    db: DB,\n    continuation: (res: Kind<GetPayload, T> | null) => void,\n    onError: (err: any) => void\n  ) {\n    const data = this._transformer.transformFindUnique(\n      validate(i, this.findUniqueSchema),\n      this._fields\n    )\n    const sql = this._builder.findUnique(data)\n    db.query(\n      sql,\n      this._schema,\n      (_, res) => {\n        if (res.length > 1) throw new InvalidArgumentError(_NOT_UNIQUE_)\n        if (res.length === 1)\n          return this.fetchIncludes(\n            res as any,\n            data.include,\n            db,\n            (rows) => {\n              continuation(rows[0] as any)\n            },\n            onError\n          )\n        return continuation(null)\n      },\n      onError\n    )\n  }\n\n  private _findFirst<\n    T extends FindInput<Select, Where, Include, OrderBy, ScalarFieldEnum>\n  >(\n    i:\n      | SelectSubset<\n          T,\n          FindInput<Select, Where, Include, OrderBy, ScalarFieldEnum>\n        >\n      | undefined,\n    db: DB,\n    continuation: (res: Kind<GetPayload, T> | null) => void,\n    onError: (err: any) => void\n  ) {\n    const data = this._transformer.transformFindNonUnique(\n      validate(i ?? {}, this.findSchema),\n      this._fields\n    )\n    const sql = this._builder.findFirst(data)\n    db.query(\n      sql,\n      this._schema,\n      (_, res) => {\n        if (res.length === 0) return continuation(null)\n        return this.fetchIncludes(\n          [res[0]] as any,\n          (data as any).include,\n          db,\n          (rows) => {\n            continuation(rows[0] as any)\n          },\n          onError\n        )\n      },\n      onError\n    )\n  }\n\n  /**\n   * Joins objects in `rows` with objects in `relatedRows` where `row.fromField === relatedRow.toField`.\n   * Beware: this function mutates the objects in `rows`.\n   * @param rows Array of original objects\n   * @param relatedRows Array of related objects\n   * @param fromField Field of objects in `rows` that points to related object.\n   * @param toField Field of objects in `relatedRows` that is pointed at by the original object.\n   */\n  private joinObjects(\n    rows: Array<Record<string, any>>,\n    relatedRows: Array<Record<string, any>>,\n    fromField: string,\n    toField: string,\n    relationField: string,\n    relationArity: Arity\n  ) {\n    return rows.map((row) => {\n      const relatedObjects = relatedRows.filter(\n        (r) => row[fromField] === r[toField]\n      )\n      if (relatedObjects.length === 0) return row\n      else if (relationArity === 'one') {\n        if (relatedObjects.length > 1)\n          throw TypeError(\n            `Relation on field '${relationField}' is one-to-one but found several related objects: ` +\n              JSON.stringify(relatedObjects)\n          )\n        // one-to-one or one-to-many relation and we fetched the related object on the one side.\n        // so we assign the related object to `relationField`\n        const [relatedObject] = relatedObjects\n        return Object.assign(row, {\n          [relationField]: relatedObject,\n        })\n      } else {\n        // one-to-many relation and we fetched the related objects on the many side\n        // so we assign the array of related objects to `relationField`\n        return Object.assign(row, {\n          [relationField]: relatedObjects,\n        })\n      }\n    })\n  }\n\n  private fetchRelated(\n    rows: Kind<GetPayload, T>[],\n    relatedTable: string,\n    fromField: string,\n    toField: string,\n    relationField: string,\n    relationType: Arity,\n    includeArg: true | FindInput<any, any, any, any, any>,\n    db: DB,\n    onResult: () => void,\n    onError: (err: any) => void\n  ) {\n    const otherTable = this._tables.get(relatedTable)!\n    const args = includeArg === true ? {} : includeArg\n    const where = typeof args.where === 'undefined' ? {} : args.where\n    const foreignKeys = rows\n      .map((row) => row[fromField as keyof typeof row])\n      .filter((fk) => fk !== null && fk !== undefined)\n    otherTable._findMany(\n      {\n        ...args,\n        where: {\n          ...where,\n          [toField]: {\n            in: foreignKeys,\n          },\n        },\n      },\n      db.withTableSchema(otherTable._fields),\n      (relatedRows: object[]) => {\n        // Now, join the original `rows` with the `relatedRows`\n        // where `row.fromField == relatedRow.toField`\n        // (this mutates the original rows)\n        this.joinObjects(\n          rows,\n          relatedRows,\n          fromField,\n          toField,\n          relationField,\n          relationType\n        ) as Kind<GetPayload, T>[]\n        onResult()\n      },\n      onError\n    )\n  }\n\n  private fetchInclude(\n    rows: Kind<GetPayload, T>[],\n    relation: Relation,\n    includeArg: boolean | FindInput<any, any, any, any, any>,\n    db: DB,\n    onResult: () => void,\n    onError: (err: any) => void\n  ) {\n    if (includeArg === false) {\n      return onResult()\n    } else if (relation.isIncomingRelation()) {\n      // incoming relation from the `fromField` in the other table\n      // to the `toField` in this table\n      const { fromField, toField } = relation.getOppositeRelation(\n        this._dbDescription\n      )\n      // The `fromField` and `toField` are defined\n      // from the perspective of the outgoing relation\n      // (`fromField` being in the table and `toField` being in the related table).\n      // Fetch the related object like for an outgoing relation\n      // but switch the `toField` and `fromField` fields because\n      // `toField` is defined in this table and `fromField` is defined in the related table.\n      this.fetchRelated(\n        rows,\n        relation.relatedTable,\n        toField,\n        fromField,\n        relation.relationField,\n        relation.relatedObjects,\n        includeArg,\n        db,\n        onResult,\n        onError\n      )\n    } else {\n      // outgoing relation from the `fromField` in this table\n      // to the `toField` in `relatedTable`\n      const {\n        fromField,\n        toField,\n        relationField,\n        relatedObjects,\n        relatedTable,\n      } = relation\n      this.fetchRelated(\n        rows,\n        relatedTable,\n        fromField,\n        toField,\n        relationField,\n        relatedObjects,\n        includeArg,\n        db,\n        onResult,\n        onError\n      )\n    }\n  }\n\n  private fetchIncludes(\n    rows: Kind<GetPayload, T>[],\n    include: NarrowInclude<Include> | undefined,\n    db: DB,\n    onResult: (res: Kind<GetPayload, T>[]) => void,\n    onError: (err: any) => void\n  ) {\n    if (typeof include === 'undefined' || rows.length === 0)\n      return onResult(rows)\n    else {\n      const relationFields = Object.keys(include)\n      forEach(\n        (relationField: string, cont: () => void) => {\n          if (\n            !this._dbDescription.hasRelationForField(\n              this.tableName,\n              relationField\n            )\n          ) {\n            throw new InvalidArgumentError(\n              'Unexpected field `' + relationField + '` in `include` argument.'\n            )\n          }\n\n          const relationName = this._dbDescription.getRelationName(\n            this.tableName,\n            relationField\n          )!\n          const relation = this._dbDescription.getRelation(\n            this.tableName,\n            relationName\n          )\n\n          // `fetchInclude` mutates the `rows` to include the related objects\n          this.fetchInclude(\n            rows,\n            relation,\n            include[relationField],\n            db,\n            cont,\n            onError\n          )\n        },\n        relationFields,\n        () => {\n          // once the loop finished, call `onResult`\n          onResult(rows)\n        }\n      )\n    }\n  }\n\n  private _findMany<\n    T extends FindInput<Select, Where, Include, OrderBy, ScalarFieldEnum>\n  >(\n    i:\n      | SelectSubset<\n          T,\n          FindInput<Select, Where, Include, OrderBy, ScalarFieldEnum>\n        >\n      | undefined,\n    db: DB,\n    continuation: (res: Kind<GetPayload, T>[]) => void,\n    onError: (err: any) => void\n  ) {\n    const data = this._transformer.transformFindNonUnique(\n      validate(i ?? {}, this.findSchema),\n      this._fields\n    )\n    const sql = this._builder.findMany(data)\n    db.query(\n      sql,\n      this._schema,\n      (_, rows) => {\n        this.fetchIncludes(\n          rows as any,\n          (data as any).include,\n          db,\n          continuation as any,\n          onError\n        )\n      },\n      onError\n    )\n  }\n\n  private _findUniqueWithoutAutoSelect<\n    T extends FindUniqueInput<Select, WhereUnique, Include>\n  >(\n    i: SelectSubset<T, FindUniqueInput<Select, WhereUnique, Include>>,\n    db: DB,\n    continuation: (res: Kind<GetPayload, T> & Record<string, any>) => void,\n    onError: (err: any) => void,\n    queryType: string\n  ) {\n    const q = this._builder.findWithoutAutoSelect(i)\n    db.query(\n      q,\n      this._schema,\n      (_, rows) => {\n        if (rows.length === 0)\n          throw new InvalidArgumentError(_RECORD_NOT_FOUND_(queryType))\n        if (rows.length > 1) throw new InvalidArgumentError(_NOT_UNIQUE_)\n\n        // Fetch the related objects requested by the `include` argument\n        this.fetchIncludes(\n          rows as any,\n          i.include,\n          db,\n          (joinedRows) => {\n            const [joinedObj] = joinedRows\n            continuation(joinedObj as any)\n          },\n          onError\n        )\n      },\n      onError\n    )\n  }\n\n  /**\n   * Updates the related object of a one-to-one relation (when `updateType === 'update'`)\n   * or many related objects from a one-to-many relation (when `updateType === 'updateMany'`).\n   * The related object(s) is one or more rows from the `relatedTable` that matches the `obj.where` argument\n   * and where the value of `toField` equals `fromFieldValue`.\n   */\n  private updateRelatedObject(\n    obj: { where?: object; data: object } | undefined,\n    relatedTable: string,\n    fromFieldValue: any,\n    toField: string,\n    isIncomingRelation: boolean,\n    db: DB,\n    cont: (updatedObj?: Record<string, any>) => void,\n    onError: (err: any) => void,\n    updateType: 'update' | 'updateMany' = 'update'\n  ) {\n    if (typeof obj === 'undefined') {\n      cont()\n    } else {\n      const relatedTbl = this._tables.get(relatedTable)!\n\n      if (updateType === 'update') {\n        // for incoming relations there is no need to match on `toField`\n        // because the `where` argument of the nested update already uniquely identifies the object\n        const whereArg = isIncomingRelation\n          ? obj.where\n          : {\n              ...obj.where,\n              [toField]: fromFieldValue,\n            }\n\n        relatedTbl._update(\n          {\n            data: obj.data,\n            where: whereArg,\n          },\n          db.withTableSchema(relatedTbl._fields),\n          cont,\n          onError\n        )\n      } else {\n        relatedTbl._updateMany(\n          {\n            data: obj.data,\n            where: {\n              ...obj.where,\n              // `obj.where` might not be enough to identify only the objects that are related\n              //  so restrict the object to only those that are related by this foreign key\n              [toField]: fromFieldValue,\n            },\n          },\n          db.withTableSchema(relatedTbl._fields),\n          cont,\n          onError\n        )\n      }\n    }\n  }\n\n  /**\n   * Takes the original object and the updated object\n   * and updates foreign keys of related objects\n   * that were pointing at a field that got updated.\n   * @param cont Function to call after the foreign keys are updated.\n   */\n  private updateFKs(\n    originalObject: Kind<\n      GetPayload,\n      FindUniqueInput<Select, WhereUnique, Include>\n    >,\n    updatedObj: Kind<GetPayload, FindUniqueInput<Select, WhereUnique, Include>>,\n    db: DB,\n    onError: (err: any) => void,\n    cont: () => void\n  ) {\n    /*\n     * Compute a diff containing all fields that were updated.\n     * For each updated field check if there are relations pointing to that field.\n     * For each relation pointing to that field, update that pointer such that it points to the new value.\n     */\n    const diff = omitBy(updatedObj, (value, field) => {\n      return originalObject[field] === value\n    })\n\n    const updatedFields = Object.keys(diff)\n    // Keep only the updated fields that are pointed at by at least one relation\n    const updatedIncomingFields = updatedFields.filter((field) => {\n      return (\n        this._dbDescription.getRelationsPointingAtField(this.tableName, field)\n          .length > 0\n      )\n    })\n\n    forEach(\n      (toField, cont) => {\n        // Update each relation pointing to this field\n        const incomingRelations =\n          this._dbDescription.getRelationsPointingAtField(\n            this.tableName,\n            toField\n          )\n        forEach(\n          (relation, cont) => {\n            // Fetch the `fromField` and `toField` of the relation\n            // This is defined on the outgoing side of the relation\n            const relatedTableName = relation.relatedTable\n            const { fromField } = relation.getOppositeRelation(\n              this._dbDescription\n            )\n            const relatedTable = this._tables.get(relatedTableName)!\n            relatedTable._updateMany(\n              {\n                data: {\n                  [fromField]: updatedObj[toField],\n                },\n                where: {\n                  [fromField]: originalObject[toField],\n                },\n              },\n              db.withTableSchema(relatedTable._fields),\n              cont,\n              onError\n            )\n          },\n          incomingRelations,\n          cont\n        )\n      },\n      updatedIncomingFields,\n      cont\n    )\n  }\n\n  /**\n   * Updates related objects for incoming relations based on\n   * nested `updateMany` argument that is provided with `update`.\n   *\n   * @example\n   * The example below updates the title of all posts written by `user1`.\n   * In the `User` table there is an incoming relation from each post to the user that wrote it.\n   * This method updates all related objects for such an incoming relation:\n   * ```\n   * User.update({\n   *   data: {\n   *     posts: {\n   *       updateMany: {\n   *         data: {\n   *           title: 'A new title for all my posts'\n   *         },\n   *         where: {}\n   *       }\n   *     }\n   *   },\n   *   where: {\n   *     id: user1.id\n   *   }\n   * })\n   * ```\n   *\n   * @param relatedTable The name of the table containing the related objects.\n   * @param relationName The name of the relation between the two tables.\n   * @param ogObject The object on which `update` is called, before the update is executed.\n   * @param updateManyObject The object that was passed as `updateMany` argument to `update`.\n   * @param onError Error handler callback.\n   * @param cont Function that will be called once the related objects are updated.\n   */\n  private updateManyRelatedObjectsFromIncomingRelation(\n    relatedTable: string,\n    relationName: string,\n    ogObject: Record<string, any>,\n    updateManyObject: object | undefined | any[],\n    db: DB,\n    onError: (err: any) => void,\n    cont: () => void\n  ) {\n    // incoming relation, can be one-to-one or one-to-many\n\n    // the `fromField` and `toField` are defined from the perspective of the outgoing relation\n    // update the related object like for an outgoing relation but switch the `to` and `from` fields\n    const { fromField, toField } = this._dbDescription.getRelation(\n      relatedTable,\n      relationName\n    )!\n    const toFieldValue = ogObject[toField]\n\n    // User may optionally provide an `updateMany` field containing an object or an array of objects\n    // if it is an object we wrap it in an array and then process the array of objects\n    const updateManyArray = Array.isArray(updateManyObject)\n      ? updateManyObject\n      : typeof updateManyObject === 'undefined'\n      ? []\n      : [updateManyObject]\n\n    // update all the requested related objects\n    forEach(\n      (updateObj, cont) => {\n        this.updateRelatedObject(\n          updateObj,\n          relatedTable,\n          toFieldValue,\n          fromField,\n          true,\n          db,\n          cont,\n          onError,\n          'updateMany'\n        )\n      },\n      updateManyArray,\n      cont\n    )\n  }\n\n  /**\n   * Updates related objects for incoming relations based on\n   * nested `update` argument that is provided with `update`.\n   * For example:\n   *  User.update({\n   *    data: {\n   *      posts: {\n   *        update: {\n   *          data: {\n   *            title: 'A new title for all my posts'\n   *          },\n   *          where: {\n   *            id: post2.id\n   *          }\n   *        }\n   *      }\n   *    },\n   *    where: {\n   *      id: user1.id\n   *    }\n   *  })\n   * The above example updates the title of post2 that was written by `user1`.\n   * This method updates that related object for such incoming relations.\n   *\n   * @param relatedTable The name of the table containing the related objects.\n   * @param relationName The name of the relation between the two tables.\n   * @param ogObject The object on which `update` is called, before the update is executed.\n   * @param updateObject The object that was passed as nested `update` argument to `update`.\n   * @param onError Error handler callback.\n   * @param cont Function that will be called once the related objects are updated.\n   */\n  private updateRelatedObjectFromIncomingRelation(\n    relatedTable: string,\n    relationName: string,\n    ogObject: Record<string, any>,\n    updateObject: object | undefined | any[],\n    db: DB,\n    onError: (err: any) => void,\n    cont: () => void\n  ) {\n    // incoming relation, can be one-to-one or one-to-many\n    const { relatedObjects } = this._dbDescription.getRelation(\n      this.tableName,\n      relationName\n    )!\n\n    // the `fromField` and `toField` are defined on the side of the outgoing relation\n    // update the related object like for an outgoing relation but switch the `to` and `from` fields\n    const { fromField, toField } = this._dbDescription.getRelation(\n      relatedTable,\n      relationName\n    )!\n    const toFieldValue = ogObject[toField]\n\n    if (relatedObjects === 'many') {\n      // this is a one-to-many relation\n      // update all the requested related objects\n\n      // `updateObj` may be an array of objects or a single object\n      // if it is a single object we wrap it in an array and then process the array\n      const updateObjects = Array.isArray(updateObject)\n        ? updateObject\n        : typeof updateObject === 'undefined'\n        ? []\n        : [updateObject]\n\n      forEach(\n        (updateObj, cont) => {\n          this.updateRelatedObject(\n            updateObj,\n            relatedTable,\n            toFieldValue,\n            fromField,\n            true,\n            db,\n            (res) => {\n              // the `where` argument of the nested update uniquely identifies the object\n              // and is used to update the related object.\n              // However, we need to make sure that the object\n              // that is identified by `where` is indeed a related object!\n              const updatedObj = res as Record<string, any>\n              if (updatedObj[fromField] !== toFieldValue) {\n                // the object is not related to the object of the original `update` query\n                throw new InvalidArgumentError(\n                  `Nested update cannot update an unrelated object.\\n` +\n                    `Related object has field ${fromField} === ${toFieldValue}\\n` +\n                    `but the object identified by ${JSON.stringify(\n                      updateObj\n                    )} has ${fromField} === ${updatedObj[fromField]}`\n                )\n              }\n              cont()\n            },\n            onError\n          )\n        },\n        updateObjects,\n        cont\n      )\n    } else {\n      // this is a one-to-one relation\n      // update the related object\n      const typedUpdateObj =\n        typeof updateObject === 'undefined'\n          ? undefined\n          : { data: updateObject, where: { [toField]: toFieldValue } }\n\n      this.updateRelatedObject(\n        typedUpdateObj,\n        relatedTable,\n        toFieldValue,\n        fromField,\n        true,\n        db,\n        cont,\n        onError\n      )\n    }\n  }\n\n  private updateRelatedObjectFromOutgoingRelation(\n    relation: Relation,\n    ogObject: Record<string, any>,\n    updateObject: object | undefined,\n    relatedTable: string,\n    db: DB,\n    cont: (updatedObj: Record<string, any> | undefined) => void,\n    onError: (err: any) => void\n  ) {\n    // outgoing relation\n    const { fromField, toField } = relation\n    const fromFieldValue = ogObject[fromField]\n\n    // update the related object\n    const wrappedUpdateObject =\n      typeof updateObject === 'undefined' ? undefined : { data: updateObject }\n\n    this.updateRelatedObject(\n      wrappedUpdateObject,\n      relatedTable,\n      fromFieldValue,\n      toField,\n      false,\n      db,\n      cont,\n      onError\n    )\n  }\n\n  private _update<\n    T extends UpdateInput<UpdateData, Select, WhereUnique, Include>\n  >(\n    i: SelectSubset<T, UpdateInput<UpdateData, Select, WhereUnique, Include>>,\n    db: DB,\n    continuation: (res: Kind<GetPayload, T>) => void,\n    onError: (err: any) => void\n  ) {\n    const data = this._transformer.transformUpdate(\n      validate(i, this.updateSchema),\n      this._fields\n    )\n\n    // Find the record and make sure it is unique\n    this._findUnique(\n      { where: data.where } as any,\n      db,\n      (originalObject) => {\n        const ogObject = originalObject as Record<string, any>\n        if (originalObject === null)\n          throw new InvalidArgumentError(_RECORD_NOT_FOUND_('Update'))\n\n        // We will update the record we found but\n        // we need to remove all relation fields from `data.data`\n        // because they don't exist on this table\n        // and those related object(s) will be updated afterwards\n        const fields = this._dbDescription.getFieldNames(this.tableName)\n        const nonRelationalData: Record<string, any> = pick(data.data, fields)\n        const nonRelationalFields: string[] = Object.keys(nonRelationalData)\n        const nonRelationalObject = {\n          ...data,\n          data: nonRelationalData,\n        }\n\n        const updateRelatedObjects = (db: DB, res: unknown[]) => {\n          const updatedObj = res[0] as typeof originalObject\n          // Some objects may be pointing to `originalObject`\n          // but the value they were pointing at may have changed\n          // so we need to update those FKs correspondingly\n          this.updateFKs(originalObject, updatedObj, db, onError, () => {\n            // Also update any related objects that are provided in the query\n            this.updateRelatedObjects(\n              data as unknown as UpdateInput<\n                UpdateData,\n                Select,\n                WhereUnique,\n                Include\n              >,\n              ogObject,\n              db,\n              nonRelationalData,\n              onError,\n              continuation\n            )\n          })\n        }\n\n        if (nonRelationalFields.length > 0) {\n          // Update the record\n          const updateDataQuery = this._builder.update(nonRelationalObject)\n          db.query(updateDataQuery, this._schema, updateRelatedObjects, onError)\n        } else {\n          // Nothing to update for this record\n          // but we may have to update related records\n          updateRelatedObjects(db, [ogObject])\n        }\n      },\n      onError\n    )\n  }\n\n  /**\n   * Updates may also include nested updates to related objects.\n   * This function updates those related objects as requested by the user.\n   */\n  private updateRelatedObjects<\n    T extends UpdateInput<UpdateData, Select, WhereUnique, Include>\n  >(\n    data: UpdateInput<UpdateData, Select, WhereUnique, Include>,\n    ogObject: Record<string, any>,\n    db: DB,\n    nonRelationalData: Record<string, any>,\n    onError: (err: any) => void,\n    continuation: (res: Kind<GetPayload, T>) => void\n  ) {\n    /*\n     * For each outgoing FK relation:\n     *  - update the related object\n     *  - add the fromField (i.e. outgoing FK) to `nonRelationalData`\n     *    because we will fetch the updated object based on its new values\n     *    and that field may have changed\n     */\n    this.forEachRelation(\n      data.data as object,\n      (rel: Relation, cont: () => void) => {\n        const { relationField, relatedTable, relationName } = rel\n        const dataRecord = data.data as Record<string, any>\n\n        // fetch the related object and recursively update that object\n        const relationActions = parseNestedUpdate(dataRecord[relationField])\n        const updateObject = relationActions.update\n\n        if (rel.isOutgoingRelation()) {\n          this.updateRelatedObjectFromOutgoingRelation(\n            rel,\n            ogObject,\n            updateObject,\n            relatedTable,\n            db,\n            (updatedObj) => {\n              // The update might have changed the value of `toField` that this `fromField` is pointing to\n              // That update will then have modified our `fromField` to point to the modified `toField`\n              const updatedObject = updatedObj!\n              const toFieldValue = updatedObject[rel.toField]\n\n              // Add the new value of the `fromField` to `nonRelationalData`\n              // such that we keep it into account when fetching the updated record\n              nonRelationalData[rel.fromField] = toFieldValue\n              cont()\n            },\n            onError\n          )\n        } else {\n          // incoming relation, can be one-to-one or one-to-many\n          this.updateRelatedObjectFromIncomingRelation(\n            relatedTable,\n            relationName,\n            ogObject,\n            updateObject,\n            db,\n            onError,\n            () => {\n              // Now also handle nested `updateMany` argument\n              // `updateMany` argument can only be provided on an incoming one-to-many relation\n              const updateManyObject = relationActions.updateMany\n              this.updateManyRelatedObjectsFromIncomingRelation(\n                relatedTable,\n                relationName,\n                ogObject,\n                updateManyObject,\n                db,\n                onError,\n                cont\n              )\n            }\n          )\n        }\n      },\n      () => {\n        // Fetch the updated record\n        this._findUniqueWithoutAutoSelect(\n          {\n            where: { ...data.where, ...nonRelationalData },\n            select: data.select,\n            ...(notNullNotUndefined(data.include) && {\n              include: data.include,\n            }), // only add `include` property if it is defined\n          } as any,\n          db,\n          continuation,\n          onError,\n          'Update'\n        )\n      }\n    )\n  }\n\n  private _updateMany<T extends UpdateManyInput<UpdateData, Where>>(\n    i: SelectSubset<T, UpdateManyInput<UpdateData, Where>>,\n    db: DB,\n    continuation: (res: BatchPayload) => void,\n    onError: (err: any) => void\n  ) {\n    const data = this._transformer.transformUpdateMany(\n      validate(i, this.updateManySchema),\n      this._fields\n    )\n    const sql = this._builder.updateMany(data)\n    db.run(\n      sql,\n      (_, { rowsAffected }) => {\n        return continuation({ count: rowsAffected })\n      },\n      onError\n    )\n  }\n\n  private _upsert<\n    T extends UpsertInput<CreateData, UpdateData, Select, WhereUnique, Include>\n  >(\n    i: SelectSubset<\n      T,\n      UpsertInput<CreateData, UpdateData, Select, WhereUnique, Include>\n    >,\n    db: DB,\n    continuation: (res: Kind<GetPayload, T>) => void,\n    onError: (err: any) => void\n  ) {\n    // validate but do not transform - upsert will call either\n    // create or update that will perform the appropriate transforms\n    validate(i, this.upsertSchema)\n\n    // Check if the record exists\n    this._findUnique(\n      { where: i.where } as any,\n      db,\n      (rows) => {\n        if (rows === null) {\n          // Create the record\n          return this._create(\n            {\n              data: i.create,\n              select: i.select,\n              ...(notNullNotUndefined(i.include) && {\n                include: i.include,\n              }), // only add `include` property if it is defined\n            } as any,\n            db,\n            continuation as any,\n            onError\n          )\n        } else {\n          // Update the record\n          return this._update(\n            {\n              data: i.update,\n              where: i.where,\n              select: i.select,\n              ...(notNullNotUndefined(i.include) && {\n                include: i.include,\n              }), // only add `include` property if it is defined\n            } as any,\n            db,\n            continuation as any,\n            onError\n          )\n        }\n      },\n      onError\n    )\n  }\n\n  private _delete<T extends DeleteInput<Select, WhereUnique, Include>>(\n    i: SelectSubset<T, DeleteInput<Select, WhereUnique, Include>>,\n    db: DB,\n    continuation: (res: Kind<GetPayload, T>) => void,\n    onError: (err: any) => void\n  ) {\n    const data = this._transformer.transformDelete(\n      validate(i, this.deleteSchema),\n      this._fields\n    )\n    // Check that the record exists\n    this._findUniqueWithoutAutoSelect(\n      data as any,\n      db,\n      (record) => {\n        // Delete it and return the deleted record\n        const deleteQuery = this._builder.delete(data)\n        db.run(\n          deleteQuery,\n          () => continuation(record as Kind<GetPayload, T>),\n          onError\n        )\n      },\n      onError,\n      'Delete'\n    )\n  }\n\n  private _deleteMany<T extends DeleteManyInput<Where>>(\n    i: SelectSubset<T, DeleteManyInput<Where>> | undefined,\n    db: DB,\n    continuation: (res: BatchPayload) => void,\n    onError: (err: any) => void\n  ) {\n    const data = this._transformer.transformDeleteMany(\n      validate(i ?? {}, this.deleteManySchema),\n      this._fields\n    )\n    const sql = this._builder.deleteMany(data)\n    db.run(\n      sql,\n      (_, { rowsAffected }) => {\n        continuation({ count: rowsAffected })\n      },\n      onError\n    )\n  }\n\n  private makeLiveResult<T>(\n    runner: () => Promise<T>,\n    i: SyncInput<Include, unknown>\n  ): LiveResultContext<T> {\n    const tables = [...this.getIncludedTables(i)].map(\n      (x) => x._qualifiedTableName\n    )\n\n    const result = <LiveResultContext<T>>(() => {\n      return runner().then((res) => {\n        return new LiveResult(res, tables)\n      })\n    })\n\n    result.subscribe = createQueryResultSubscribeFunction(\n      this._notifier,\n      result,\n      tables\n    )\n    result.sourceQuery = i\n    return result\n  }\n\n  setReplicationTransform(i: ReplicatedRowTransformer<T>): void {\n    // forbid transforming relation keys to avoid breaking\n    // referential integrity\n\n    // the column could be the FK column when it is an outgoing FK\n    // or it could be a PK column when it is an incoming FK\n    const fkCols = this._dbDescription\n      .getOutgoingRelations(this.tableName)\n      .map((r) => r.fromField)\n\n    // Incoming relations don't have the `fromField` and `toField` filled in\n    // so we need to fetch the `toField` from the opposite relation\n    // which is effectively a column in this table to which the FK points\n    const pkCols = this._dbDescription\n      .getIncomingRelations(this.tableName)\n      .map((r) => r.getOppositeRelation(this._dbDescription).toField)\n\n    // Merge all columns that are part of a FK relation.\n    // Remove duplicate columns in case a column has both an outgoing FK and an incoming FK.\n    const immutableFields = Array.from(new Set(fkCols.concat(pkCols)))\n\n    this._replicationTransformManager.setTableTransform(\n      this._qualifiedTableName,\n      {\n        transformInbound: (record) =>\n          this._replicationTransformManager.transformTableRecord(\n            record,\n            i.transformInbound,\n            this._fields,\n            this._schema,\n            immutableFields\n          ),\n\n        transformOutbound: (record) =>\n          this._replicationTransformManager.transformTableRecord(\n            record,\n            i.transformOutbound,\n            this._fields,\n            this._schema,\n            immutableFields\n          ),\n      }\n    )\n  }\n\n  clearReplicationTransform(): void {\n    this._replicationTransformManager.clearTableTransform(\n      this._qualifiedTableName\n    )\n  }\n}\n\nexport function unsafeExec(\n  adapter: DatabaseAdapter,\n  sql: Statement\n): Promise<Row[]> {\n  return adapter.query(sql)\n}\n\nexport function rawQuery(\n  adapter: DatabaseAdapter,\n  sql: Statement\n): Promise<Row[]> {\n  // only allow safe queries from the client\n  if (isPotentiallyDangerous(sql.sql)) {\n    throw new InvalidArgumentError(\n      'Cannot use queries that might alter the store - please use read-only queries'\n    )\n  }\n\n  return unsafeExec(adapter, sql)\n}\n\nexport function liveRawQuery(\n  adapter: DatabaseAdapter,\n  notifier: Notifier,\n  sql: Statement\n): LiveResultContext<Row[]> {\n  const result = <LiveResultContext<Row[]>>(async () => {\n    // parse the table names from the query\n    // because this is a raw query so\n    // we cannot trust that it queries this table\n    const tablenames = parseTableNames(sql.sql, adapter.defaultNamespace)\n    const res = await rawQuery(adapter, sql)\n    return new LiveResult(res, tablenames)\n  })\n\n  result.subscribe = createQueryResultSubscribeFunction(\n    notifier,\n    result,\n    parseTableNames(sql.sql, adapter.defaultNamespace)\n  )\n  result.sourceQuery = sql\n  return result\n}\n\n/** Compile Prisma-like where-clause object into a SQL where clause that the server can understand. */\nfunction makeSqlWhereClause(where: string | Record<string, any>): string {\n  if (typeof where === 'string') return where\n\n  const statements = Object.entries(where)\n    .flatMap(([key, value]) => makeFilter(value, key, 'this.'))\n    .map(interpolateSqlArgsForPostgres)\n\n  if (statements.length < 2) return statements[0] ?? ''\n  else return statements.map((x) => '(' + x + ')').join(' AND ')\n}\n\n/** Interpolate SQL arguments into a string that PostgreSQL can understand. */\nfunction interpolateSqlArgsForPostgres({\n  sql,\n  args,\n}: {\n  sql: string\n  args?: unknown[]\n}) {\n  return interpolateSqlArgs({ sql, args: args?.map(quoteValueForPostgres) })\n}\n\n/** Quote a JS value to be inserted in a PostgreSQL where query for the server. */\nfunction quoteValueForPostgres(value: unknown): string {\n  if (typeof value === 'string') return `'${value.replaceAll(\"'\", \"''\")}'`\n  if (typeof value === 'number') return value.toString()\n  if (value instanceof Date && !isNaN(value.valueOf()))\n    return `'${value.toISOString()}'`\n  if (typeof value === 'boolean') return value.toString()\n  if (Array.isArray(value))\n    return `(${value.map(quoteValueForPostgres).join(', ')})`\n\n  throw new Error(\n    `Sorry! We currently cannot handle where clauses using value ${value}. You can try serializing it to a string yourself. \\nPlease leave a feature request at https://github.com/electric-sql/electric/issues.`\n  )\n}\n"],"mappings":"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","names":["cont","db"]}