{"version":3,"sources":["../../../src/client/model/model.ts"],"sourcesContent":["import { CreateInput, CreateManyInput } from '../input/createInput'\nimport { SelectSubset } from '../util/types'\nimport { BatchPayload } from '../output/batchPayload'\nimport { FindInput, FindUniqueInput } from '../input/findInput'\nimport { UpdateInput, UpdateManyInput } from '../input/updateInput'\nimport { UpsertInput } from '../input/upsertInput'\nimport { DeleteInput, DeleteManyInput } from '../input/deleteInput'\nimport { QualifiedTablename } from '../../util/tablename'\nimport { HKT, Kind } from '../util/hkt'\nimport { SyncInput } from '../input/syncInput'\nimport { ShapeSubscription } from '../../satellite/process'\nimport { LiveResultSubscribeFunction } from '../../util/subscribe'\nimport { ReplicatedRowTransformer } from '../../util'\n\n/**\n * Interface that is implemented by Electric clients.\n */\nexport interface Model<\n  Schema extends Record<string, any>,\n  CreateData extends object,\n  UpdateData extends object,\n  Select,\n  Where extends object | undefined,\n  WhereUnique extends object,\n  Include,\n  OrderBy,\n  ScalarFieldEnum,\n  GetPayload extends HKT\n> {\n  sync<T extends SyncInput<Include, Where>>(i?: T): Promise<ShapeSubscription>\n\n  /**\n   * Creates a unique record in the DB.\n   * @param i - The record to create.\n   * @returns The record that was inserted in the DB.\n   */\n  create<T extends CreateInput<CreateData, Select, Include>>(\n    i: SelectSubset<T, CreateInput<CreateData, Select, Include>>\n  ): Promise<Kind<GetPayload, T>>\n\n  /**\n   * Creates several records in the DB.\n   * @param i - The records to create.\n   * @returns An object indicating how many records were inserted in the DB.\n   */\n  createMany<T extends CreateManyInput<CreateData>>(\n    i: SelectSubset<T, CreateManyInput<CreateData>>\n  ): Promise<BatchPayload>\n\n  /**\n   * Searches for a unique record in the DB.\n   * @param i - An object containing a where field and optionally include and select fields.\n   * @returns The record if found, `null` otherwise.\n   *\n   * @throws {@link InvalidArgumentError}\n   * Thrown if the record is not unique.\n   */\n  findUnique<T extends FindUniqueInput<Select, WhereUnique, Include>>(\n    i: SelectSubset<T, FindUniqueInput<Select, WhereUnique, Include>>\n  ): Promise<Kind<GetPayload, T> | null>\n\n  /**\n   * @returns The first record that matches the query, or `null` if no matching record is found.\n   */\n  findFirst<\n    T extends FindInput<Select, Where, Include, OrderBy, ScalarFieldEnum>\n  >(\n    i: SelectSubset<\n      T,\n      FindInput<Select, Where, Include, OrderBy, ScalarFieldEnum>\n    >\n  ): Promise<Kind<GetPayload, T> | null>\n\n  /**\n   * Fetches all records that match the query.\n   * To fetch only a selection of records use\n   * the `take` and `skip` arguments.\n   *\n   * @returns All records that match the query.\n   */\n  findMany<\n    T extends FindInput<Select, Where, Include, OrderBy, ScalarFieldEnum>\n  >(\n    i: SelectSubset<\n      T,\n      FindInput<Select, Where, Include, OrderBy, ScalarFieldEnum>\n    >\n  ): Promise<Array<Kind<GetPayload, T>>>\n\n  // Live queries\n  // The queries' return types are slightly different\n  // as their result is wrapped inside a `LiveResult`\n  // object that contains additional information about the table names.\n\n  /**\n   * Same as {@link Model#findUnique} but wraps the result in a {@link LiveResult} object.\n   */\n  liveUnique<T extends FindUniqueInput<Select, WhereUnique, Include>>(\n    i: SelectSubset<T, FindUniqueInput<Select, WhereUnique, Include>>\n  ): LiveResultContext<Kind<GetPayload, T> | null>\n\n  /**\n   * Same as {@link Model#findFirst} but wraps the result in a {@link LiveResult} object.\n   */\n  liveFirst<\n    T extends FindInput<Select, Where, Include, OrderBy, ScalarFieldEnum>\n  >(\n    i: SelectSubset<\n      T,\n      FindInput<Select, Where, Include, OrderBy, ScalarFieldEnum>\n    >\n  ): LiveResultContext<Kind<GetPayload, T> | null>\n\n  /**\n   * Same as {@link Model#findMany} but wraps the result in a {@link LiveResult} object.\n   */\n  liveMany<\n    T extends FindInput<Select, Where, Include, OrderBy, ScalarFieldEnum>\n  >(\n    i: SelectSubset<\n      T,\n      FindInput<Select, Where, Include, OrderBy, ScalarFieldEnum>\n    >\n  ): LiveResultContext<Array<Kind<GetPayload, T>>>\n\n  /**\n   * Updates a single record that is uniquely identified by the provided argument.\n   *\n   * @param i - An object that contains the data to update and uniquely identifies the record to update in the DB.\n   * @returns The updated record.\n   *\n   * @throws {@link InvalidArgumentError}\n   * Thrown if the record does not exist or is not unique.\n   */\n  update<T extends UpdateInput<UpdateData, Select, WhereUnique, Include>>(\n    i: SelectSubset<T, UpdateInput<UpdateData, Select, WhereUnique, Include>>\n  ): Promise<Kind<GetPayload, T>>\n\n  /**\n   * Updates all the records that match the query.\n   *\n   * @param i - An object identifying the records to update and containing the data to update.\n   * @returns An object indicating how many records were updated.\n   */\n  updateMany<T extends UpdateManyInput<UpdateData, Where>>(\n    i: SelectSubset<T, UpdateManyInput<UpdateData, Where>>\n  ): Promise<BatchPayload>\n\n  /**\n   * Inserts a record if it does not exist,\n   * otherwise it updates the existing record.\n   *\n   * @param i - Object containing the data to create and the data to update in case it exists.\n   * @returns The record that was created or updated.\n   *\n   * @throws {@link InvalidArgumentError}\n   * Thrown if the record is not unique.\n   */\n  upsert<\n    T extends UpsertInput<CreateData, UpdateData, Select, WhereUnique, Include>\n  >(\n    i: SelectSubset<\n      T,\n      UpsertInput<CreateData, UpdateData, Select, WhereUnique, Include>\n    >\n  ): Promise<Kind<GetPayload, T>>\n\n  /**\n   * Deletes the record that is uniquely identified by the provided argument.\n   *\n   * @param i - Object that uniquely identifies a single record.\n   * @returns The deleted record.\n   *\n   * @throws {@link InvalidArgumentError}\n   * Thrown if the record does not exist or is not unique.\n   */\n  delete<T extends DeleteInput<Select, WhereUnique, Include>>(\n    i: SelectSubset<T, DeleteInput<Select, WhereUnique, Include>>\n  ): Promise<Kind<GetPayload, T>>\n\n  /**\n   * Deletes all records that match the provided argument.\n   *\n   * @param i - Object that selects zero or more records to delete.\n   * @returns An object indicating how many records were deleted.\n   */\n  deleteMany<T extends DeleteManyInput<Where>>(\n    i: SelectSubset<T, DeleteManyInput<Where>>\n  ): Promise<BatchPayload>\n\n  /**\n   * Puts transforms in place such that any data being replicated\n   * to or from this table is first handled appropriately while\n   * retaining type consistency.\n   *\n   * Can be used to encrypt sensitive fields before they are\n   * replicated outside of their secure local source.\n   *\n   * NOTE: usage is discouraged, but ensure transforms are\n   * set before replication is initiated using {@link sync}\n   * to avoid partially transformed tables.\n   *\n   * @param i - Object that determines transforms to apply\n   */\n  setReplicationTransform(i: ReplicatedRowTransformer<Schema>): void\n\n  /**\n   * Clears any replication transforms set using {@link setReplicationTransform}\n   */\n  clearReplicationTransform(): void\n}\n\nexport interface LiveResultContext<T> {\n  (): Promise<LiveResult<T>>\n  subscribe: LiveResultSubscribeFunction<T>\n  sourceQuery?: Record<string, any> | undefined\n}\n\n/**\n * A live result wrapping the `result` as well as the concerned table names.\n * The table names are used to subscribe to changes to those tables\n * in order to re-run the live query when one of the tables change.\n */\nexport class LiveResult<T> {\n  constructor(public result: T, public tablenames: QualifiedTablename[]) {}\n}\n\n/**\n * A live result update wrapping either the `results` or any `error` from the query,\n * as well as an `updatedAt` timestamp indicating the retrieval time of this result\n */\nexport interface LiveResultUpdate<T> {\n  results?: T\n  error?: unknown\n  updatedAt?: Date\n}\n"],"mappings":"AA+NO,MAAM,WAAc;AAAA,EACzB,YAAmB,QAAkB,YAAkC;AAApD;AAAkB;AAAA,EAAmC;AAC1E;","names":[]}