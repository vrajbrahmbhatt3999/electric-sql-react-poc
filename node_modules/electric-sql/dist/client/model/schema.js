import mapValues from "lodash.mapvalues";
import partition from "lodash.partition";
import groupBy from "lodash.groupby";
class Relation {
  constructor(relationField, fromField, toField, relatedTable, relationName, relatedObjects) {
    this.relationField = relationField;
    this.fromField = fromField;
    this.toField = toField;
    this.relatedTable = relatedTable;
    this.relationName = relationName;
    this.relatedObjects = relatedObjects;
  }
  isIncomingRelation() {
    return this.fromField === "" && this.toField === "";
  }
  isOutgoingRelation() {
    return !this.isIncomingRelation();
  }
  getOppositeRelation(dbDescription) {
    return dbDescription.getRelation(this.relatedTable, this.relationName);
  }
}
class DbSchema {
  /**
   * @param tables Description of the database tables
   * @param migrations Bundled SQLite migrations
   * @param pgMigrations Bundled Postgres migrations
   */
  constructor(tables, migrations, pgMigrations) {
    this.tables = tables;
    this.migrations = migrations;
    this.pgMigrations = pgMigrations;
    this.extendedTables = this.extend(tables);
    this.incomingRelationsIndex = this.indexIncomingRelations();
  }
  extendedTables;
  // index mapping fields to an array of relations that map to that field
  incomingRelationsIndex;
  extend(tbls) {
    return mapValues(tbls, (descr) => {
      const [incoming, outgoing] = partition(
        descr.relations,
        (r) => r.isIncomingRelation()
      );
      return {
        ...descr,
        incomingRelations: incoming,
        outgoingRelations: outgoing
      };
    });
  }
  indexIncomingRelations() {
    const tableNames = Object.keys(this.extendedTables);
    const buildRelationIndex = (tableName) => {
      const inRelations = this.getIncomingRelations(tableName);
      return groupBy(inRelations, (relation) => {
        return relation.getOppositeRelation(this).toField;
      });
    };
    const obj = {};
    tableNames.forEach((tableName) => {
      obj[tableName] = buildRelationIndex(tableName);
    });
    return obj;
  }
  hasTable(table) {
    return Object.keys(this.extendedTables).includes(table);
  }
  getTableDescription(table) {
    return this.extendedTables[table];
  }
  getFields(table) {
    return this.extendedTables[table].fields;
  }
  getFieldNames(table) {
    return Array.from(this.getFields(table).keys());
  }
  hasRelationForField(table, field) {
    return this.getRelations(table).some((r) => r.relationField === field);
  }
  getRelationName(table, field) {
    return this.getRelations(table).find((r) => r.relationField === field).relationName;
  }
  getRelation(table, relation) {
    return this.getRelations(table).find((r) => r.relationName === relation);
  }
  getRelatedTable(table, field) {
    const relationName = this.getRelationName(table, field);
    const relation = this.getRelation(table, relationName);
    return relation.relatedTable;
  }
  getForeignKey(table, field) {
    const relationName = this.getRelationName(table, field);
    const relation = this.getRelation(table, relationName);
    if (relation.isOutgoingRelation()) {
      return relation.fromField;
    }
    const oppositeRelation = relation.getOppositeRelation(this);
    return oppositeRelation.fromField;
  }
  // Profile.post <-> Post.profile (from: profileId, to: id)
  getRelations(table) {
    return this.extendedTables[table].relations;
  }
  getOutgoingRelations(table) {
    return this.extendedTables[table].outgoingRelations;
  }
  getIncomingRelations(table) {
    return this.extendedTables[table].incomingRelations;
  }
  getRelationsPointingAtField(table, field) {
    const index = this.incomingRelationsIndex[table];
    const relations = index[field];
    if (typeof relations === "undefined")
      return [];
    else
      return relations;
  }
}
export {
  DbSchema,
  Relation
};
//# sourceMappingURL=schema.js.map