import { ElectricNamespace } from '../../electric/namespace.js';
import { rawQuery, liveRawQuery, unsafeExec, Table } from './table.js';
import { ReplicationTransformManager } from './transforms.js';
import { InputTransformer } from '../conversions/input.js';
import { sqliteConverter } from '../conversions/sqlite.js';
import { postgresConverter } from '../conversions/postgres.js';
class ElectricClient extends ElectricNamespace {
  constructor(db, dbName, adapter, notifier, satellite, registry) {
    super(dbName, adapter, notifier, registry);
    this.db = db;
    this.satellite = satellite;
    this.satellite = satellite;
    this.sync = {
      syncStatus: this.satellite.syncStatus.bind(this.satellite),
      unsubscribe: this.satellite.unsubscribe.bind(this.satellite)
    };
  }
  sync;
  /**
   * Connects to the Electric sync service.
   * This method is idempotent, it is safe to call it multiple times.
   * @param token - The JWT token to use to connect to the Electric sync service.
   *                This token is required on first connection but can be left out when reconnecting
   *                in which case the last seen token is reused.
   */
  async connect(token) {
    if (token === void 0 && !this.satellite.hasToken()) {
      throw new Error("A token is required the first time you connect.");
    }
    if (token !== void 0) {
      this.satellite.setToken(token);
    }
    await this.satellite.connectWithBackoff();
  }
  disconnect() {
    this.satellite.clientDisconnect();
  }
  // Builds the DAL namespace from a `dbDescription` object
  static create(dbName, dbDescription, adapter, notifier, satellite, registry, dialect) {
    const tables = dbDescription.extendedTables;
    const converter = dialect === "SQLite" ? sqliteConverter : postgresConverter;
    const replicationTransformManager = new ReplicationTransformManager(
      satellite,
      converter
    );
    const inputTransformer = new InputTransformer(converter);
    const createTable = (tableName) => {
      return new Table(
        tableName,
        adapter,
        notifier,
        satellite,
        replicationTransformManager,
        dbDescription,
        inputTransformer,
        dialect
      );
    };
    const dal = Object.fromEntries(
      Object.keys(tables).map((tableName) => {
        return [tableName, createTable(tableName)];
      })
    );
    Object.keys(dal).forEach((tableName) => {
      dal[tableName].setTables(new Map(Object.entries(dal)));
    });
    const db = {
      ...dal,
      unsafeExec: unsafeExec.bind(null, adapter),
      rawQuery: rawQuery.bind(null, adapter),
      liveRawQuery: liveRawQuery.bind(null, adapter, notifier),
      raw: unsafeExec.bind(null, adapter),
      liveRaw: liveRawQuery.bind(null, adapter, notifier)
    };
    return new ElectricClient(
      db,
      dbName,
      adapter,
      notifier,
      satellite,
      registry
    );
  }
}
export {
  ElectricClient
};
//# sourceMappingURL=client.js.map