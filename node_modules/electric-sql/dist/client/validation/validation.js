import * as z from "zod";
import { InvalidArgumentError } from './errors/invalidArgumentError.js';
import { isObject } from '../../util/index.js';
import { InvalidRecordTransformationError } from './errors/invalidRecordTransformationError.js';
function deepOmit(obj) {
  Object.keys(obj).forEach((key) => {
    const v = obj[key];
    if (v === void 0)
      delete obj[key];
    else if (isObject(v))
      deepOmit(v);
  });
}
function validate(i, schema) {
  const parsedObject = schema.parse(i);
  deepOmit(parsedObject);
  return parsedObject;
}
function parseNestedCreate(relationField) {
  const createRelatedObjSchema = z.object({
    create: z.any().optional()
  }).strict();
  try {
    return createRelatedObjSchema.parse(relationField);
  } catch (err) {
    if (err instanceof z.ZodError && err.issues.some((e) => e.code === "unrecognized_keys"))
      throw new InvalidArgumentError(
        "Unsupported operation. Currently, only nested `create` operation is supported on create query."
      );
    else
      throw err;
  }
}
function parseNestedUpdate(relationField) {
  const updateRelatedObjSchema = z.object({
    update: z.any().optional(),
    updateMany: z.any().optional()
    //create?: object,
    //upsert?: object,
    //delete?: boolean
  }).strict();
  try {
    return updateRelatedObjSchema.parse(relationField);
  } catch (err) {
    if (err instanceof z.ZodError && err.issues.some((e) => e.code === "unrecognized_keys"))
      throw new InvalidArgumentError(
        "Unsupported operation. Currently, only nested `update` and `updateMany` operations are supported on an update query."
      );
    else
      throw err;
  }
}
function omitCountFromSelectAndIncludeSchema(s) {
  const schema = s;
  const omitCount = (s2) => {
    return s2.unwrap().omit({ _count: true }).optional();
  };
  const obj = {
    select: omitCount(schema.shape.select)
  };
  if (schema.shape.include) {
    obj["include"] = omitCount(schema.shape.include);
  }
  return schema.merge(z.object(obj));
}
function validateRecordTransformation(originalRecord, transformedRecord, immutableFields) {
  const modifiedImmutableFields = immutableFields.some(
    (key) => originalRecord[key] !== transformedRecord[key]
  );
  if (modifiedImmutableFields) {
    throw new InvalidRecordTransformationError(
      `Record transformation modified immutable fields: ${immutableFields.filter((key) => originalRecord[key] !== transformedRecord[key]).join(", ")}`
    );
  }
  return transformedRecord;
}
export {
  omitCountFromSelectAndIncludeSchema,
  parseNestedCreate,
  parseNestedUpdate,
  validate,
  validateRecordTransformation
};
//# sourceMappingURL=validation.js.map