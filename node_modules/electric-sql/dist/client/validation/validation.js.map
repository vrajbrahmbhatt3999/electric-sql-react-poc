{"version":3,"sources":["../../../src/client/validation/validation.ts"],"sourcesContent":["import * as z from 'zod'\nimport { InvalidArgumentError } from './errors/invalidArgumentError'\nimport { DbRecord as DataRecord, isObject } from '../../util'\nimport { InvalidRecordTransformationError } from './errors/invalidRecordTransformationError'\n\nfunction deepOmit(obj: Record<string, any>) {\n  Object.keys(obj).forEach((key) => {\n    const v = obj[key]\n    if (v === undefined) delete obj[key]\n    else if (isObject(v)) deepOmit(v)\n  })\n}\n\nexport function validate<I>(i: I, schema: z.ZodTypeAny): I {\n  const parsedObject = schema.parse(i)\n  // Zod allows users to pass `undefined` as the value for optional fields.\n  // However, `undefined` is not a valid SQL value and squel.js will not turn `undefined` into `NULL`.\n  // Hence, we have to do an additional pass over the `parsedObject` to remove fields whose value is `undefined`.\n  deepOmit(parsedObject)\n  return parsedObject\n}\n\nexport function parseNestedCreate(relationField: any): { create?: any } {\n  const createRelatedObjSchema = z\n    .object({\n      create: z.any().optional(),\n    })\n    .strict()\n\n  try {\n    return createRelatedObjSchema.parse(relationField)\n  } catch (err) {\n    if (\n      err instanceof z.ZodError &&\n      err.issues.some((e) => e.code === 'unrecognized_keys')\n    )\n      throw new InvalidArgumentError(\n        'Unsupported operation. Currently, only nested `create` operation is supported on create query.'\n      )\n    else throw err\n  }\n}\n\nexport function parseNestedUpdate(relationField: any): {\n  update?: any\n  updateMany?: any\n} {\n  const updateRelatedObjSchema = z\n    .object({\n      update: z.any().optional(),\n      updateMany: z.any().optional(),\n      //create?: object,\n      //upsert?: object,\n      //delete?: boolean\n    })\n    .strict()\n\n  try {\n    return updateRelatedObjSchema.parse(relationField)\n  } catch (err) {\n    if (\n      err instanceof z.ZodError &&\n      err.issues.some((e) => e.code === 'unrecognized_keys')\n    )\n      throw new InvalidArgumentError(\n        'Unsupported operation. Currently, only nested `update` and `updateMany` operations are supported on an update query.'\n      )\n    else throw err\n  }\n}\n\n/**\n * Takes a schema for an object containing an optional `select` property\n * which has an optional `_count` property and removes the `_count` property.\n * @param s Schema for an object containing an optional `select` property.\n */\nexport function omitCountFromSelectAndIncludeSchema<T extends z.ZodTypeAny>(\n  s: T\n): T {\n  const schema = s as unknown as z.AnyZodObject\n  const omitCount = (s: any) => {\n    return s\n      .unwrap() // `select` and `include` are optional fields, unwrap its schema out of the optional\n      .omit({ _count: true }) // remove `_count` field\n      .optional() // wrap it back into an optional\n  }\n  const obj: { select: any; include?: any } = {\n    select: omitCount(schema.shape.select),\n  }\n  if (schema.shape.include) {\n    obj['include'] = omitCount(schema.shape.include)\n  }\n  return schema.merge(z.object(obj)) as unknown as T\n}\n\n/**\n * Validates that the given record transformation did not change any of the specified {@link immutableFields}.\n * @param originalRecord the source record\n * @param trnasformedRecord the transformed record\n * @param immutableFields the fields that should not have been modified\n * @returns the transformed record, validated such that no immutable fields are changed\n *\n * @throws {@link InvalidRecordTransformationError}\n * Thrown if record transformation changed any of the specified {@link immutableFields}\n */\nexport function validateRecordTransformation<T extends DataRecord>(\n  originalRecord: Readonly<T>,\n  transformedRecord: Readonly<T>,\n  immutableFields: string[]\n): T {\n  const modifiedImmutableFields = immutableFields.some(\n    (key) => originalRecord[key] !== transformedRecord[key]\n  )\n  if (modifiedImmutableFields) {\n    throw new InvalidRecordTransformationError(\n      `Record transformation modified immutable fields: ${immutableFields\n        .filter((key) => originalRecord[key] !== transformedRecord[key])\n        .join(', ')}`\n    )\n  }\n\n  return transformedRecord\n}\n"],"mappings":"AAAA,YAAY,OAAO;AACnB,SAAS,4BAA4B;AACrC,SAAiC,gBAAgB;AACjD,SAAS,wCAAwC;AAEjD,SAAS,SAAS,KAA0B;AAC1C,SAAO,KAAK,GAAG,EAAE,QAAQ,CAAC,QAAQ;AAChC,UAAM,IAAI,IAAI,GAAG;AACjB,QAAI,MAAM;AAAW,aAAO,IAAI,GAAG;AAAA,aAC1B,SAAS,CAAC;AAAG,eAAS,CAAC;AAAA,EAClC,CAAC;AACH;AAEO,SAAS,SAAY,GAAM,QAAyB;AACzD,QAAM,eAAe,OAAO,MAAM,CAAC;AAInC,WAAS,YAAY;AACrB,SAAO;AACT;AAEO,SAAS,kBAAkB,eAAsC;AACtE,QAAM,yBAAyB,EAC5B,OAAO;AAAA,IACN,QAAQ,EAAE,IAAI,EAAE,SAAS;AAAA,EAC3B,CAAC,EACA,OAAO;AAEV,MAAI;AACF,WAAO,uBAAuB,MAAM,aAAa;AAAA,EACnD,SAAS,KAAK;AACZ,QACE,eAAe,EAAE,YACjB,IAAI,OAAO,KAAK,CAAC,MAAM,EAAE,SAAS,mBAAmB;AAErD,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA;AACG,YAAM;AAAA,EACb;AACF;AAEO,SAAS,kBAAkB,eAGhC;AACA,QAAM,yBAAyB,EAC5B,OAAO;AAAA,IACN,QAAQ,EAAE,IAAI,EAAE,SAAS;AAAA,IACzB,YAAY,EAAE,IAAI,EAAE,SAAS;AAAA;AAAA;AAAA;AAAA,EAI/B,CAAC,EACA,OAAO;AAEV,MAAI;AACF,WAAO,uBAAuB,MAAM,aAAa;AAAA,EACnD,SAAS,KAAK;AACZ,QACE,eAAe,EAAE,YACjB,IAAI,OAAO,KAAK,CAAC,MAAM,EAAE,SAAS,mBAAmB;AAErD,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA;AACG,YAAM;AAAA,EACb;AACF;AAOO,SAAS,oCACd,GACG;AACH,QAAM,SAAS;AACf,QAAM,YAAY,CAACA,OAAW;AAC5B,WAAOA,GACJ,OAAO,EACP,KAAK,EAAE,QAAQ,KAAK,CAAC,EACrB,SAAS;AAAA,EACd;AACA,QAAM,MAAsC;AAAA,IAC1C,QAAQ,UAAU,OAAO,MAAM,MAAM;AAAA,EACvC;AACA,MAAI,OAAO,MAAM,SAAS;AACxB,QAAI,SAAS,IAAI,UAAU,OAAO,MAAM,OAAO;AAAA,EACjD;AACA,SAAO,OAAO,MAAM,EAAE,OAAO,GAAG,CAAC;AACnC;AAYO,SAAS,6BACd,gBACA,mBACA,iBACG;AACH,QAAM,0BAA0B,gBAAgB;AAAA,IAC9C,CAAC,QAAQ,eAAe,GAAG,MAAM,kBAAkB,GAAG;AAAA,EACxD;AACA,MAAI,yBAAyB;AAC3B,UAAM,IAAI;AAAA,MACR,oDAAoD,gBACjD,OAAO,CAAC,QAAQ,eAAe,GAAG,MAAM,kBAAkB,GAAG,CAAC,EAC9D,KAAK,IAAI,CAAC;AAAA,IACf;AAAA,EACF;AAEA,SAAO;AACT;","names":["s"]}