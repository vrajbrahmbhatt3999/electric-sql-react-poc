{"version":3,"sources":["../../../../src/client/conversions/datatypes/date.ts"],"sourcesContent":["import { PgDateType } from '../types'\n\n// Serialises a `Date` object into a SQLite compatible date string\nexport function serialiseDate(v: Date, pgType: PgDateType): string {\n  switch (pgType) {\n    case PgDateType.PG_TIMESTAMP:\n      // Returns local timestamp\n      return ignoreTimeZone(v).toISOString().replace('T', ' ').replace('Z', '')\n\n    case PgDateType.PG_TIMESTAMPTZ:\n      // Returns UTC timestamp\n      return v.toISOString().replace('T', ' ')\n\n    case PgDateType.PG_DATE:\n      // Returns the local date\n      return extractDateAndTime(ignoreTimeZone(v)).date\n\n    case PgDateType.PG_TIME:\n      // Returns the local time\n      return extractDateAndTime(ignoreTimeZone(v)).time\n\n    case PgDateType.PG_TIMETZ:\n      // Returns UTC time\n      return extractDateAndTime(v).time\n  }\n}\n\n// Deserialises a SQLite compatible date string into a `Date` object\nexport function deserialiseDate(v: string, pgType: PgDateType): Date {\n  const parse = (v: any) => {\n    const millis = Date.parse(v)\n    if (isNaN(millis))\n      throw new Error(`Could not parse date, invalid format: ${v}`)\n    else return new Date(millis)\n  }\n\n  switch (pgType) {\n    case PgDateType.PG_TIMESTAMP:\n    case PgDateType.PG_TIMESTAMPTZ:\n    case PgDateType.PG_DATE:\n      return parse(v)\n\n    case PgDateType.PG_TIME:\n      // interpret as local time\n      return parse(`1970-01-01 ${v}`)\n\n    case PgDateType.PG_TIMETZ:\n      // interpret as UTC time\n      return parse(`1970-01-01 ${v}+00`)\n  }\n}\n\n/**\n * Corrects the provided `Date` such that\n * the current date is set as UTC date.\n * e.g. if it is 3PM in GMT+2 then it is 1PM UTC.\n *      This function would return a date in which it is 3PM UTC.\n */\nfunction ignoreTimeZone(v: Date): Date {\n  // `v.toISOString` returns the UTC time but we want the time in this timezone\n  // so we get the timezone offset and subtract it from the current time in order to\n  // compensate for the timezone correction done by `toISOString`\n  const offsetInMs = 1000 * 60 * v.getTimezoneOffset()\n  return new Date(v.getTime() - offsetInMs)\n}\n\ntype ExtractedDateTime = { date: string; time: string }\nfunction extractDateAndTime(v: Date): ExtractedDateTime {\n  const regex = /([0-9-]*)T([0-9:.]*)Z/g\n  const [_, date, time] = regex.exec(v.toISOString()) as unknown as [\n    string,\n    string,\n    string\n  ]\n  return { date, time }\n}\n"],"mappings":"AAAA,SAAS,kBAAkB;AAGpB,SAAS,cAAc,GAAS,QAA4B;AACjE,UAAQ,QAAQ;AAAA,IACd,KAAK,WAAW;AAEd,aAAO,eAAe,CAAC,EAAE,YAAY,EAAE,QAAQ,KAAK,GAAG,EAAE,QAAQ,KAAK,EAAE;AAAA,IAE1E,KAAK,WAAW;AAEd,aAAO,EAAE,YAAY,EAAE,QAAQ,KAAK,GAAG;AAAA,IAEzC,KAAK,WAAW;AAEd,aAAO,mBAAmB,eAAe,CAAC,CAAC,EAAE;AAAA,IAE/C,KAAK,WAAW;AAEd,aAAO,mBAAmB,eAAe,CAAC,CAAC,EAAE;AAAA,IAE/C,KAAK,WAAW;AAEd,aAAO,mBAAmB,CAAC,EAAE;AAAA,EACjC;AACF;AAGO,SAAS,gBAAgB,GAAW,QAA0B;AACnE,QAAM,QAAQ,CAACA,OAAW;AACxB,UAAM,SAAS,KAAK,MAAMA,EAAC;AAC3B,QAAI,MAAM,MAAM;AACd,YAAM,IAAI,MAAM,yCAAyCA,EAAC,EAAE;AAAA;AACzD,aAAO,IAAI,KAAK,MAAM;AAAA,EAC7B;AAEA,UAAQ,QAAQ;AAAA,IACd,KAAK,WAAW;AAAA,IAChB,KAAK,WAAW;AAAA,IAChB,KAAK,WAAW;AACd,aAAO,MAAM,CAAC;AAAA,IAEhB,KAAK,WAAW;AAEd,aAAO,MAAM,cAAc,CAAC,EAAE;AAAA,IAEhC,KAAK,WAAW;AAEd,aAAO,MAAM,cAAc,CAAC,KAAK;AAAA,EACrC;AACF;AAQA,SAAS,eAAe,GAAe;AAIrC,QAAM,aAAa,MAAO,KAAK,EAAE,kBAAkB;AACnD,SAAO,IAAI,KAAK,EAAE,QAAQ,IAAI,UAAU;AAC1C;AAGA,SAAS,mBAAmB,GAA4B;AACtD,QAAM,QAAQ;AACd,QAAM,CAAC,GAAG,MAAM,IAAI,IAAI,MAAM,KAAK,EAAE,YAAY,CAAC;AAKlD,SAAO,EAAE,MAAM,KAAK;AACtB;","names":["v"]}