import { PgDateType } from '../types.js';
function serialiseDate(v, pgType) {
  switch (pgType) {
    case PgDateType.PG_TIMESTAMP:
      return ignoreTimeZone(v).toISOString().replace("T", " ").replace("Z", "");
    case PgDateType.PG_TIMESTAMPTZ:
      return v.toISOString().replace("T", " ");
    case PgDateType.PG_DATE:
      return extractDateAndTime(ignoreTimeZone(v)).date;
    case PgDateType.PG_TIME:
      return extractDateAndTime(ignoreTimeZone(v)).time;
    case PgDateType.PG_TIMETZ:
      return extractDateAndTime(v).time;
  }
}
function deserialiseDate(v, pgType) {
  const parse = (v2) => {
    const millis = Date.parse(v2);
    if (isNaN(millis))
      throw new Error(`Could not parse date, invalid format: ${v2}`);
    else
      return new Date(millis);
  };
  switch (pgType) {
    case PgDateType.PG_TIMESTAMP:
    case PgDateType.PG_TIMESTAMPTZ:
    case PgDateType.PG_DATE:
      return parse(v);
    case PgDateType.PG_TIME:
      return parse(`1970-01-01 ${v}`);
    case PgDateType.PG_TIMETZ:
      return parse(`1970-01-01 ${v}+00`);
  }
}
function ignoreTimeZone(v) {
  const offsetInMs = 1e3 * 60 * v.getTimezoneOffset();
  return new Date(v.getTime() - offsetInMs);
}
function extractDateAndTime(v) {
  const regex = /([0-9-]*)T([0-9:.]*)Z/g;
  const [_, date, time] = regex.exec(v.toISOString());
  return { date, time };
}
export {
  deserialiseDate,
  serialiseDate
};
//# sourceMappingURL=date.js.map