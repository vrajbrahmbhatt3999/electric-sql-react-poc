import { FieldName, Fields } from '../model/schema.js';
import { Converter } from './converter.js';
import { PgType } from './types.js';
export declare enum Transformation {
    Encode = 0,// encode values from JS to SQLite/Postgres
    Decode = 1
}
type UpdateInput = {
    data: object;
    where: object;
};
type UpdateManyInput = {
    data: object;
    where?: object;
};
type CreateInput = {
    data: object;
};
type CreateManyInput = {
    data: Array<object>;
};
type WhereUniqueInput = {
    where: object;
};
type WhereInput = {
    where?: object;
};
type Swap<T, Input, Props extends keyof Input> = Omit<T, Props> & Pick<Input, Props>;
export declare class InputTransformer {
    converter: Converter;
    constructor(converter: Converter);
    /**
     * Takes the data input of a `create` operation and
     * converts the JS values to their corresponding SQLite/PG values.
     * e.g. JS `Date` objects are converted into strings.
     * @param i The validated input of the `create` operation.
     * @param fields The table's fields.
     * @returns The transformed input.
     */
    transformCreate<T extends CreateInput>(i: T, fields: Fields): Swap<T, CreateInput, 'data'>;
    /**
     * Takes the data input of a `createMany` operation and
     * converts the JS values to their corresponding SQLite/PG values.
     * e.g. JS `Date` objects are converted into strings.
     * @param i The validated input of the `createMany` operation.
     * @param fields The table's fields.
     * @returns The transformed input.
     */
    transformCreateMany<T extends CreateManyInput>(i: T, fields: Fields): Swap<T, CreateManyInput, 'data'>;
    /**
     * Takes the data input of an `update` operation and
     * converts the JS values to their corresponding SQLite/PG values.
     * e.g. JS `Date` objects are converted into strings.
     * @param i The validated input of the `update` operation.
     * @param fields The table's fields.
     * @returns The transformed input.
     */
    transformUpdate<T extends UpdateInput>(i: T, fields: Fields): Swap<T, UpdateInput, 'data' | 'where'>;
    /**
     * Takes the data input of an `updateMany` operation and
     * converts the JS values to their corresponding SQLite/PG values.
     * @param i The validated input of the `updateMany` operation.
     * @param fields The table's fields.
     * @returns The transformed input.
     */
    transformUpdateMany<T extends UpdateManyInput>(i: T, fields: Fields): UpdateManyInput;
    /**
     * Takes the data input of a `delete` operation and
     * converts the JS values to their corresponding SQLite/PG values.
     */
    transformDelete: <T extends WhereUniqueInput>(i: T, fields: Fields) => Swap<T, WhereUniqueInput, 'where'>;
    /**
     * Takes the data input of a `deleteMany` operation and
     * converts the JS values to their corresponding SQLite/PG values.
     * @param i The validated input of the `deleteMany` operation.
     * @param fields The table's fields.
     * @returns The transformed input.
     */
    transformDeleteMany: <T extends WhereInput>(i: T, fields: Fields) => Swap<T, WhereInput, 'where'>;
    /**
     * Takes the data input of a `findUnique` operation and
     * converts the JS values to their corresponding SQLite/PG values.
     */
    transformFindUnique: <T extends WhereUniqueInput>(i: T, fields: Fields) => Swap<T, WhereUniqueInput, 'where'>;
    /**
     * Takes the data input of a `findFirst` or `findMany` operation and
     * converts the JS values to their corresponding SQLite/PG values.
     */
    transformFindNonUnique: <T extends WhereInput>(i: T, fields: Fields) => Swap<T, WhereInput, 'where'>;
    /**
     * Takes the data input of an operation containing a required `where` clause and
     * converts the JS values of the `where` clause to their corresponding SQLite/PG values.
     * @param i The validated input of the `where` clause.
     * @param fields The table's fields.
     * @returns The transformed input.
     */
    transformWhereUniqueInput<T extends WhereUniqueInput>(i: T, fields: Fields): Swap<T, WhereUniqueInput, 'where'>;
    /**
     * Takes the data input of an operation containing an optional `where` clause and
     * converts the JS values of the `where` clause to their corresponding SQLite/PG values.
     * @param i The validated input of the `where` clause.
     * @param fields The table's fields.
     * @returns The transformed input.
     */
    transformWhereInput<T extends WhereInput>(i: T, fields: Fields): Swap<T, WhereInput, 'where'>;
    transformWhere(o: object, fields: Fields): object;
    transformBooleanConnectors(o: {
        AND?: object | object[];
        OR?: object | object[];
        NOT?: object | object[];
    }, fields: Fields): object;
    /**
     * Iterates over the properties of a `where` object
     * in order to transform the values to SQLite/PG compatible values
     * based on additional type information about the fields.
     * @param o The `where` object to transform.
     * @param fields Type information about the fields.
     * @returns A `where` object with the values converted to SQLite/PG.
     */
    transformWhereFields(o: object, fields: Fields): object;
    /**
     * Transforms a value that may contain filters.
     * e.g. `where` clauses of a query allow to pass a value directly or an object containing filters.
     *      If it is an object of filters, we need to transform the values that are nested in those filters.
     * @param field The name of the field we are transforming.
     * @param value The value for that field.
     * @param fields Type information about the fields of this table.
     * @returns The transformed value.
     */
    transformFieldsAllowingFilters(field: FieldName, value: any, fields: Fields): any;
    /**
     * Transforms an object containing filters
     * @example For example:
     * ```
     * {
     *   lt: Date('2023-09-12'),
     *   notIn: [ Date('2023-09-09'), Date('2023-09-01') ],
     *   not: {
     *     lt: Date('2022-09-01')
     *   }
     * }
     * ```
     * @param field The name of the field we are transforming.
     * @param o The object containing the filters.
     * @param pgType Type of this field.
     * @param fields Type information about the fields of this table.
     * @returns A transformed filter object.
     */
    transformFilterObject(field: FieldName, o: any, pgType: PgType, fields: Fields): any;
}
/**
 * Iterates over the properties of the object `o`
 * in order to transform their values to SQLite/PG compatible values
 * based on additional type information about the fields.
 * @param o The object to transform.
 * @param fields Type information about the fields.
 * @param transformation Which transformation to execute.
 * @returns An object with the values converted to SQLite/PG.
 */
export declare function transformFields(o: object, fields: Fields, converter: Converter, transformation?: Transformation): object;
export declare function isFilterObject(value: any): boolean;
export {};
