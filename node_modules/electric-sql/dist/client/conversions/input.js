import mapValues from "lodash.mapvalues";
import { isDataObject } from './converter.js';
import { InvalidArgumentError } from '../validation/errors/invalidArgumentError.js';
import { mapObject } from '../util/functions.js';
import { isObject } from '../../util/index.js';
var Transformation = /* @__PURE__ */ ((Transformation2) => {
  Transformation2[Transformation2["Encode"] = 0] = "Encode";
  Transformation2[Transformation2["Decode"] = 1] = "Decode";
  return Transformation2;
})(Transformation || {});
class InputTransformer {
  constructor(converter) {
    this.converter = converter;
  }
  /**
   * Takes the data input of a `create` operation and
   * converts the JS values to their corresponding SQLite/PG values.
   * e.g. JS `Date` objects are converted into strings.
   * @param i The validated input of the `create` operation.
   * @param fields The table's fields.
   * @returns The transformed input.
   */
  transformCreate(i, fields) {
    return {
      ...i,
      data: transformFields(i.data, fields, this.converter)
    };
  }
  /**
   * Takes the data input of a `createMany` operation and
   * converts the JS values to their corresponding SQLite/PG values.
   * e.g. JS `Date` objects are converted into strings.
   * @param i The validated input of the `createMany` operation.
   * @param fields The table's fields.
   * @returns The transformed input.
   */
  transformCreateMany(i, fields) {
    return {
      ...i,
      data: i.data.map((o) => transformFields(o, fields, this.converter))
    };
  }
  /**
   * Takes the data input of an `update` operation and
   * converts the JS values to their corresponding SQLite/PG values.
   * e.g. JS `Date` objects are converted into strings.
   * @param i The validated input of the `update` operation.
   * @param fields The table's fields.
   * @returns The transformed input.
   */
  transformUpdate(i, fields) {
    return {
      ...i,
      data: transformFields(i.data, fields, this.converter),
      where: this.transformWhere(i.where, fields)
    };
  }
  /**
   * Takes the data input of an `updateMany` operation and
   * converts the JS values to their corresponding SQLite/PG values.
   * @param i The validated input of the `updateMany` operation.
   * @param fields The table's fields.
   * @returns The transformed input.
   */
  transformUpdateMany(i, fields) {
    const whereObj = this.transformWhereInput(i, fields);
    return {
      ...whereObj,
      data: transformFields(i.data, fields, this.converter)
    };
  }
  /**
   * Takes the data input of a `delete` operation and
   * converts the JS values to their corresponding SQLite/PG values.
   */
  transformDelete = this.transformWhereUniqueInput;
  /**
   * Takes the data input of a `deleteMany` operation and
   * converts the JS values to their corresponding SQLite/PG values.
   * @param i The validated input of the `deleteMany` operation.
   * @param fields The table's fields.
   * @returns The transformed input.
   */
  transformDeleteMany = this.transformWhereInput;
  /**
   * Takes the data input of a `findUnique` operation and
   * converts the JS values to their corresponding SQLite/PG values.
   */
  transformFindUnique = this.transformWhereUniqueInput;
  /**
   * Takes the data input of a `findFirst` or `findMany` operation and
   * converts the JS values to their corresponding SQLite/PG values.
   */
  transformFindNonUnique = this.transformWhereInput;
  /**
   * Takes the data input of an operation containing a required `where` clause and
   * converts the JS values of the `where` clause to their corresponding SQLite/PG values.
   * @param i The validated input of the `where` clause.
   * @param fields The table's fields.
   * @returns The transformed input.
   */
  transformWhereUniqueInput(i, fields) {
    return {
      ...i,
      where: this.transformWhere(i.where, fields)
    };
  }
  /**
   * Takes the data input of an operation containing an optional `where` clause and
   * converts the JS values of the `where` clause to their corresponding SQLite/PG values.
   * @param i The validated input of the `where` clause.
   * @param fields The table's fields.
   * @returns The transformed input.
   */
  transformWhereInput(i, fields) {
    const whereObj = i.where ? { where: this.transformWhere(i.where, fields) } : {};
    return {
      ...i,
      ...whereObj
    };
  }
  transformWhere(o, fields) {
    const transformedFields = this.transformWhereFields(o, fields);
    const transformedBooleanConnectors = this.transformBooleanConnectors(
      o,
      fields
    );
    return {
      ...o,
      ...transformedFields,
      ...transformedBooleanConnectors
    };
  }
  transformBooleanConnectors(o, fields) {
    const makeArray = (v) => Array.isArray(v) ? v : [v];
    const andObj = o.AND ? { AND: makeArray(o.AND).map((x) => this.transformWhere(x, fields)) } : {};
    const orObj = o.OR ? { OR: makeArray(o.OR).map((x) => this.transformWhere(x, fields)) } : {};
    const notObj = o.NOT ? { NOT: makeArray(o.NOT).map((x) => this.transformWhere(x, fields)) } : {};
    return {
      ...andObj,
      ...orObj,
      ...notObj
    };
  }
  /**
   * Iterates over the properties of a `where` object
   * in order to transform the values to SQLite/PG compatible values
   * based on additional type information about the fields.
   * @param o The `where` object to transform.
   * @param fields Type information about the fields.
   * @returns A `where` object with the values converted to SQLite/PG.
   */
  transformWhereFields(o, fields) {
    const objWithoutRelatedFields = keepTableFieldsOnly(o, fields);
    const transformedObj = mapObject(
      objWithoutRelatedFields,
      (field, value) => {
        return this.transformFieldsAllowingFilters(field, value, fields);
      }
    );
    return {
      ...o,
      ...transformedObj
    };
  }
  /**
   * Transforms a value that may contain filters.
   * e.g. `where` clauses of a query allow to pass a value directly or an object containing filters.
   *      If it is an object of filters, we need to transform the values that are nested in those filters.
   * @param field The name of the field we are transforming.
   * @param value The value for that field.
   * @param fields Type information about the fields of this table.
   * @returns The transformed value.
   */
  transformFieldsAllowingFilters(field, value, fields) {
    const pgType = fields.get(field);
    if (!pgType)
      throw new InvalidArgumentError(`Unknown field ${field}`);
    if (isFilterObject(value)) {
      return this.transformFilterObject(field, value, pgType, fields);
    }
    return this.converter.encode(value, pgType);
  }
  /**
   * Transforms an object containing filters
   * @example For example:
   * ```
   * {
   *   lt: Date('2023-09-12'),
   *   notIn: [ Date('2023-09-09'), Date('2023-09-01') ],
   *   not: {
   *     lt: Date('2022-09-01')
   *   }
   * }
   * ```
   * @param field The name of the field we are transforming.
   * @param o The object containing the filters.
   * @param pgType Type of this field.
   * @param fields Type information about the fields of this table.
   * @returns A transformed filter object.
   */
  transformFilterObject(field, o, pgType, fields) {
    const simpleFilters = /* @__PURE__ */ new Set(["equals", "lt", "lte", "gt", "gte"]);
    const arrayFilters = /* @__PURE__ */ new Set(["in", "notIn"]);
    const simpleFilterObj = filterKeys(o, simpleFilters);
    const transformedSimpleFilterObj = mapValues(
      simpleFilterObj,
      (v) => this.converter.encode(v, pgType)
    );
    const arrayFilterObj = filterKeys(o, arrayFilters);
    const transformedArrayFilterObj = mapValues(
      arrayFilterObj,
      (arr) => arr.map((v) => this.converter.encode(v, pgType))
    );
    const notFilterObj = filterKeys(o, /* @__PURE__ */ new Set(["not"]));
    const transformedNotFilterObj = mapValues(notFilterObj, (v) => {
      return this.transformFieldsAllowingFilters(field, v, fields);
    });
    return {
      ...o,
      ...transformedSimpleFilterObj,
      ...transformedArrayFilterObj,
      ...transformedNotFilterObj
    };
  }
}
function transformFields(o, fields, converter, transformation = 0 /* Encode */) {
  const copied = { ...o };
  Object.entries(o).forEach(([field, value]) => {
    const pgType = fields.get(field);
    if (pgType === void 0)
      return;
    const transformedValue = transformation === 0 /* Encode */ ? converter.encode(value, pgType) : converter.decode(value, pgType);
    copied[field] = transformedValue;
  });
  return copied;
}
function isFilterObject(value) {
  return isObject(value) && !isDataObject(value);
}
function keepTableFieldsOnly(o, fields) {
  return filterKeys(o, fields);
}
function filterKeys(o, keys) {
  return Object.fromEntries(
    Object.entries(o).filter((entry) => keys.has(entry[0]))
  );
}
export {
  InputTransformer,
  Transformation,
  isFilterObject,
  transformFields
};
//# sourceMappingURL=input.js.map