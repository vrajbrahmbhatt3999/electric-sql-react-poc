{"version":3,"sources":["../../../src/client/conversions/input.ts"],"sourcesContent":["import mapValues from 'lodash.mapvalues'\nimport { FieldName, Fields } from '../model/schema'\nimport { Converter, isDataObject } from './converter'\nimport { InvalidArgumentError } from '../validation/errors/invalidArgumentError'\nimport { mapObject } from '../util/functions'\nimport { PgType } from './types'\nimport { isObject } from '../../util'\n\nexport enum Transformation {\n  Encode, // encode values from JS to SQLite/Postgres\n  Decode, // decode values from SQLite/Postgres to JS\n}\n\ntype UpdateInput = { data: object; where: object }\ntype UpdateManyInput = { data: object; where?: object }\ntype CreateInput = { data: object }\ntype CreateManyInput = { data: Array<object> }\ntype WhereUniqueInput = { where: object }\ntype WhereInput = { where?: object }\n\ntype Swap<T, Input, Props extends keyof Input> = Omit<T, Props> &\n  Pick<Input, Props>\n\nexport class InputTransformer {\n  constructor(public converter: Converter) {}\n\n  /**\n   * Takes the data input of a `create` operation and\n   * converts the JS values to their corresponding SQLite/PG values.\n   * e.g. JS `Date` objects are converted into strings.\n   * @param i The validated input of the `create` operation.\n   * @param fields The table's fields.\n   * @returns The transformed input.\n   */\n  transformCreate<T extends CreateInput>(\n    i: T,\n    fields: Fields\n  ): Swap<T, CreateInput, 'data'> {\n    return {\n      ...i,\n      data: transformFields(i.data, fields, this.converter),\n    }\n  }\n\n  /**\n   * Takes the data input of a `createMany` operation and\n   * converts the JS values to their corresponding SQLite/PG values.\n   * e.g. JS `Date` objects are converted into strings.\n   * @param i The validated input of the `createMany` operation.\n   * @param fields The table's fields.\n   * @returns The transformed input.\n   */\n  transformCreateMany<T extends CreateManyInput>(\n    i: T,\n    fields: Fields\n  ): Swap<T, CreateManyInput, 'data'> {\n    return {\n      ...i,\n      data: i.data.map((o) => transformFields(o, fields, this.converter)),\n    }\n  }\n\n  /**\n   * Takes the data input of an `update` operation and\n   * converts the JS values to their corresponding SQLite/PG values.\n   * e.g. JS `Date` objects are converted into strings.\n   * @param i The validated input of the `update` operation.\n   * @param fields The table's fields.\n   * @returns The transformed input.\n   */\n  transformUpdate<T extends UpdateInput>(\n    i: T,\n    fields: Fields\n  ): Swap<T, UpdateInput, 'data' | 'where'> {\n    return {\n      ...i,\n      data: transformFields(i.data, fields, this.converter),\n      where: this.transformWhere(i.where, fields),\n    }\n  }\n\n  /**\n   * Takes the data input of an `updateMany` operation and\n   * converts the JS values to their corresponding SQLite/PG values.\n   * @param i The validated input of the `updateMany` operation.\n   * @param fields The table's fields.\n   * @returns The transformed input.\n   */\n  transformUpdateMany<T extends UpdateManyInput>(\n    i: T,\n    fields: Fields\n  ): UpdateManyInput {\n    const whereObj = this.transformWhereInput(i, fields)\n    return {\n      ...whereObj,\n      data: transformFields(i.data, fields, this.converter),\n    }\n  }\n\n  /**\n   * Takes the data input of a `delete` operation and\n   * converts the JS values to their corresponding SQLite/PG values.\n   */\n  transformDelete = this.transformWhereUniqueInput\n\n  /**\n   * Takes the data input of a `deleteMany` operation and\n   * converts the JS values to their corresponding SQLite/PG values.\n   * @param i The validated input of the `deleteMany` operation.\n   * @param fields The table's fields.\n   * @returns The transformed input.\n   */\n  transformDeleteMany = this.transformWhereInput\n\n  /**\n   * Takes the data input of a `findUnique` operation and\n   * converts the JS values to their corresponding SQLite/PG values.\n   */\n  transformFindUnique = this.transformWhereUniqueInput\n\n  /**\n   * Takes the data input of a `findFirst` or `findMany` operation and\n   * converts the JS values to their corresponding SQLite/PG values.\n   */\n  transformFindNonUnique = this.transformWhereInput\n\n  /**\n   * Takes the data input of an operation containing a required `where` clause and\n   * converts the JS values of the `where` clause to their corresponding SQLite/PG values.\n   * @param i The validated input of the `where` clause.\n   * @param fields The table's fields.\n   * @returns The transformed input.\n   */\n  transformWhereUniqueInput<T extends WhereUniqueInput>(\n    i: T,\n    fields: Fields\n  ): Swap<T, WhereUniqueInput, 'where'> {\n    return {\n      ...i,\n      where: this.transformWhere(i.where, fields),\n    }\n  }\n\n  /**\n   * Takes the data input of an operation containing an optional `where` clause and\n   * converts the JS values of the `where` clause to their corresponding SQLite/PG values.\n   * @param i The validated input of the `where` clause.\n   * @param fields The table's fields.\n   * @returns The transformed input.\n   */\n  transformWhereInput<T extends WhereInput>(\n    i: T,\n    fields: Fields\n  ): Swap<T, WhereInput, 'where'> {\n    const whereObj = i.where\n      ? { where: this.transformWhere(i.where, fields) }\n      : {}\n    return {\n      ...i,\n      ...whereObj,\n    }\n  }\n\n  transformWhere(o: object, fields: Fields): object {\n    const transformedFields = this.transformWhereFields(o, fields)\n    const transformedBooleanConnectors = this.transformBooleanConnectors(\n      o,\n      fields\n    )\n    return {\n      ...o,\n      ...transformedFields,\n      ...transformedBooleanConnectors,\n    }\n  }\n\n  transformBooleanConnectors(\n    o: {\n      AND?: object | object[]\n      OR?: object | object[]\n      NOT?: object | object[]\n    },\n    fields: Fields\n  ): object {\n    // Within a `where` object, boolean connectors AND/OR/NOT will contain\n    // a nested `where` object or an array of nested `where` objects\n    // if it is a single `where` object we wrap it in an array\n    // and we map `transformWhere` to recursively handle all nested objects\n    const makeArray = (v: any) => (Array.isArray(v) ? v : [v])\n    const andObj = o.AND\n      ? { AND: makeArray(o.AND).map((x) => this.transformWhere(x, fields)) }\n      : {}\n    const orObj = o.OR\n      ? { OR: makeArray(o.OR).map((x) => this.transformWhere(x, fields)) }\n      : {}\n    const notObj = o.NOT\n      ? { NOT: makeArray(o.NOT).map((x) => this.transformWhere(x, fields)) }\n      : {}\n\n    // we use spread syntax such that the filter is not included if it is undefined\n    // we cannot set it to undefined because then it appears in `hasOwnProperty`\n    // and the query builder will try to write `undefined` to the database.\n    return {\n      ...andObj,\n      ...orObj,\n      ...notObj,\n    }\n  }\n\n  /**\n   * Iterates over the properties of a `where` object\n   * in order to transform the values to SQLite/PG compatible values\n   * based on additional type information about the fields.\n   * @param o The `where` object to transform.\n   * @param fields Type information about the fields.\n   * @returns A `where` object with the values converted to SQLite/PG.\n   */\n  transformWhereFields(o: object, fields: Fields): object {\n    // only transform fields that are part of this table and not related fields\n    // as those will be transformed later when the query on the related field is processed.\n    const objWithoutRelatedFields = keepTableFieldsOnly(o, fields)\n    const transformedObj = mapObject(\n      objWithoutRelatedFields,\n      (field, value) => {\n        // each field can be the value itself or an object containing filters like `lt`, `gt`, etc.\n        return this.transformFieldsAllowingFilters(field, value, fields)\n      }\n    )\n\n    return {\n      ...o,\n      ...transformedObj,\n    }\n  }\n\n  /**\n   * Transforms a value that may contain filters.\n   * e.g. `where` clauses of a query allow to pass a value directly or an object containing filters.\n   *      If it is an object of filters, we need to transform the values that are nested in those filters.\n   * @param field The name of the field we are transforming.\n   * @param value The value for that field.\n   * @param fields Type information about the fields of this table.\n   * @returns The transformed value.\n   */\n  transformFieldsAllowingFilters(\n    field: FieldName,\n    value: any,\n    fields: Fields\n  ): any {\n    const pgType = fields.get(field)\n\n    if (!pgType) throw new InvalidArgumentError(`Unknown field ${field}`)\n\n    if (isFilterObject(value)) {\n      // transform the values that are nested in those filters\n      return this.transformFilterObject(field, value, pgType, fields)\n    }\n\n    return this.converter.encode(value, pgType)\n  }\n\n  /**\n   * Transforms an object containing filters\n   * @example For example:\n   * ```\n   * {\n   *   lt: Date('2023-09-12'),\n   *   notIn: [ Date('2023-09-09'), Date('2023-09-01') ],\n   *   not: {\n   *     lt: Date('2022-09-01')\n   *   }\n   * }\n   * ```\n   * @param field The name of the field we are transforming.\n   * @param o The object containing the filters.\n   * @param pgType Type of this field.\n   * @param fields Type information about the fields of this table.\n   * @returns A transformed filter object.\n   */\n  transformFilterObject(\n    field: FieldName,\n    o: any,\n    pgType: PgType,\n    fields: Fields\n  ) {\n    const simpleFilters = new Set(['equals', 'lt', 'lte', 'gt', 'gte']) // filters whose value is an optional value of type `pgType`\n    const arrayFilters = new Set(['in', 'notIn']) // filters whose value is an optional array of values of type `pgType`\n\n    // Handle the simple filters\n    const simpleFilterObj = filterKeys(o, simpleFilters)\n    const transformedSimpleFilterObj = mapValues(simpleFilterObj, (v: any) =>\n      this.converter.encode(v, pgType)\n    )\n\n    // Handle the array filters\n    const arrayFilterObj = filterKeys(o, arrayFilters)\n    const transformedArrayFilterObj = mapValues(arrayFilterObj, (arr) =>\n      arr.map((v: any) => this.converter.encode(v, pgType))\n    )\n\n    // Handle `not` filter\n    // `not` is a special one as it accepts a value or a nested object of filters\n    // hence it is just like the properties of a `where` object which accept values or filters\n    const notFilterObj = filterKeys(o, new Set(['not']))\n    const transformedNotFilterObj = mapValues(notFilterObj, (v) => {\n      // each field can be the value itself or an object containing filters like `lt`, `gt`, etc.\n      return this.transformFieldsAllowingFilters(field, v, fields)\n    })\n\n    return {\n      ...o,\n      ...transformedSimpleFilterObj,\n      ...transformedArrayFilterObj,\n      ...transformedNotFilterObj,\n    }\n  }\n}\n\n/**\n * Iterates over the properties of the object `o`\n * in order to transform their values to SQLite/PG compatible values\n * based on additional type information about the fields.\n * @param o The object to transform.\n * @param fields Type information about the fields.\n * @param transformation Which transformation to execute.\n * @returns An object with the values converted to SQLite/PG.\n */\nexport function transformFields(\n  o: object,\n  fields: Fields,\n  converter: Converter,\n  transformation: Transformation = Transformation.Encode\n): object {\n  // only transform fields that are part of this table and not related fields\n  // as those will be transformed later when the query on the related field is processed.\n  const copied: Record<string, any> = { ...o }\n  Object.entries(o).forEach(([field, value]) => {\n    const pgType = fields.get(field)\n    // Skip anything that's not an actual column on the table\n    if (pgType === undefined) return\n\n    const transformedValue =\n      transformation === Transformation.Encode\n        ? converter.encode(value, pgType)\n        : converter.decode(value, pgType)\n\n    copied[field] = transformedValue\n  })\n\n  return copied\n}\n\nexport function isFilterObject(value: any): boolean {\n  // if it is an object it can only be a data object or a filter object\n  return isObject(value) && !isDataObject(value)\n}\n\n/**\n * Filters out all properties that are not fields (i.e. columns) of this table.\n * e.g. it removes related fields or filters like `lt`, `equals`, etc.\n * @param o The object to filter.\n * @param fields The fields of the table to which this object belongs.\n * @returns A filtered object.\n */\nfunction keepTableFieldsOnly(o: object, fields: Fields) {\n  return filterKeys(o, fields)\n}\n\n/**\n * Filters the object to retain only keys that are in `keys`.\n * @param o The object to filter.\n * @param keys Object that allows checking if a key is present.\n * @returns A filtered object.\n */\nfunction filterKeys(o: object, keys: { has: (x: string) => boolean }) {\n  return Object.fromEntries(\n    Object.entries(o).filter((entry) => keys.has(entry[0]))\n  )\n}\n"],"mappings":"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","names":["Transformation"]}