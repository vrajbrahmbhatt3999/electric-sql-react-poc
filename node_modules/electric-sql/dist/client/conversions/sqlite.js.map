{"version":3,"sources":["../../../src/client/conversions/sqlite.ts"],"sourcesContent":["import { InvalidArgumentError } from '../validation/errors/invalidArgumentError'\nimport { Converter } from './converter'\nimport { deserialiseBoolean, serialiseBoolean } from './datatypes/boolean'\nimport { deserialiseBlob, serialiseBlob } from './datatypes/blob'\nimport { deserialiseDate, serialiseDate } from './datatypes/date'\nimport { deserialiseJSON, serialiseJSON } from './datatypes/json'\nimport { PgBasicType, PgDateType, PgType, isPgDateType } from './types'\n\n/**\n * This module takes care of converting TypeScript values for Postgres-specific types to a SQLite storeable value and back.\n * These conversions are needed when the developer uses the DAL such that we can convert those JS values to SQLite values\n * and such that values that are read from the SQLite DB can be converted into JS values.\n * For example, a `Date` value representing a Postgres timestamp can be converted to a string that can be stored in SQLite.\n * When reading from the SQLite database, the string can be parsed back into a `Date` object.\n */\n\nfunction toSqlite(v: any, pgType: PgType): any {\n  if (v === null) {\n    // don't transform null values\n    return v\n  } else if (isPgDateType(pgType)) {\n    if (!(v instanceof Date))\n      throw new InvalidArgumentError(\n        `Unexpected value ${v}. Expected a Date object.`\n      )\n\n    return serialiseDate(v, pgType as PgDateType)\n  } else if (pgType === PgBasicType.PG_BOOL) {\n    return serialiseBoolean(v)\n  } else if (Number.isNaN(v)) {\n    // Since SQLite does not support `NaN` we serialise `NaN` into the string`'NaN'`\n    // and deserialise it back to `NaN` when reading from the DB.\n    // cf. https://github.com/WiseLibs/better-sqlite3/issues/1088\n    return 'NaN'\n  } else if (\n    pgType === PgBasicType.PG_FLOAT4 ||\n    pgType === PgBasicType.PG_REAL\n  ) {\n    return Math.fround(v)\n  } else if (\n    pgType === PgBasicType.PG_JSON ||\n    pgType === PgBasicType.PG_JSONB\n  ) {\n    return serialiseJSON(v)\n  } else if (pgType === PgBasicType.PG_BYTEA) {\n    return serialiseBlob(v)\n  } else {\n    return v\n  }\n}\n\nfunction fromSqlite(v: any, pgType: PgType): any {\n  if (v === null) {\n    // don't transform null values\n    return v\n  } else if (isPgDateType(pgType)) {\n    // it's a serialised date\n    return deserialiseDate(v, pgType as PgDateType)\n  } else if (pgType === PgBasicType.PG_BOOL) {\n    // it's a serialised boolean\n    return deserialiseBoolean(v)\n  } else if (\n    v === 'NaN' &&\n    (pgType === PgBasicType.PG_FLOAT8 ||\n      pgType === PgBasicType.PG_FLOAT4 ||\n      pgType === PgBasicType.PG_REAL)\n  ) {\n    // it's a serialised NaN\n    return NaN\n  } else if (\n    pgType === PgBasicType.PG_FLOAT4 ||\n    pgType === PgBasicType.PG_REAL\n  ) {\n    // convert to float4 in case someone would have written a bigger value to SQLite directly\n    return Math.fround(v)\n  } else if (pgType === PgBasicType.PG_INT8) {\n    // always return BigInts for PG_INT8 values\n    // because some drivers (e.g. wa-sqlite) return a regular JS number if the value fits into a JS number\n    // but we know that it should be a BigInt based on the column type\n    return BigInt(v)\n  } else if (\n    pgType === PgBasicType.PG_JSON ||\n    pgType === PgBasicType.PG_JSONB\n  ) {\n    // it's serialised JSON\n    return deserialiseJSON(v)\n  } else if (pgType === PgBasicType.PG_BYTEA) {\n    return deserialiseBlob(v)\n  } else {\n    return v\n  }\n}\n\nexport const sqliteConverter: Converter = {\n  encode: toSqlite,\n  decode: fromSqlite,\n}\n"],"mappings":"AAAA,SAAS,4BAA4B;AAErC,SAAS,oBAAoB,wBAAwB;AACrD,SAAS,iBAAiB,qBAAqB;AAC/C,SAAS,iBAAiB,qBAAqB;AAC/C,SAAS,iBAAiB,qBAAqB;AAC/C,SAAS,aAAiC,oBAAoB;AAU9D,SAAS,SAAS,GAAQ,QAAqB;AAC7C,MAAI,MAAM,MAAM;AAEd,WAAO;AAAA,EACT,WAAW,aAAa,MAAM,GAAG;AAC/B,QAAI,EAAE,aAAa;AACjB,YAAM,IAAI;AAAA,QACR,oBAAoB,CAAC;AAAA,MACvB;AAEF,WAAO,cAAc,GAAG,MAAoB;AAAA,EAC9C,WAAW,WAAW,YAAY,SAAS;AACzC,WAAO,iBAAiB,CAAC;AAAA,EAC3B,WAAW,OAAO,MAAM,CAAC,GAAG;AAI1B,WAAO;AAAA,EACT,WACE,WAAW,YAAY,aACvB,WAAW,YAAY,SACvB;AACA,WAAO,KAAK,OAAO,CAAC;AAAA,EACtB,WACE,WAAW,YAAY,WACvB,WAAW,YAAY,UACvB;AACA,WAAO,cAAc,CAAC;AAAA,EACxB,WAAW,WAAW,YAAY,UAAU;AAC1C,WAAO,cAAc,CAAC;AAAA,EACxB,OAAO;AACL,WAAO;AAAA,EACT;AACF;AAEA,SAAS,WAAW,GAAQ,QAAqB;AAC/C,MAAI,MAAM,MAAM;AAEd,WAAO;AAAA,EACT,WAAW,aAAa,MAAM,GAAG;AAE/B,WAAO,gBAAgB,GAAG,MAAoB;AAAA,EAChD,WAAW,WAAW,YAAY,SAAS;AAEzC,WAAO,mBAAmB,CAAC;AAAA,EAC7B,WACE,MAAM,UACL,WAAW,YAAY,aACtB,WAAW,YAAY,aACvB,WAAW,YAAY,UACzB;AAEA,WAAO;AAAA,EACT,WACE,WAAW,YAAY,aACvB,WAAW,YAAY,SACvB;AAEA,WAAO,KAAK,OAAO,CAAC;AAAA,EACtB,WAAW,WAAW,YAAY,SAAS;AAIzC,WAAO,OAAO,CAAC;AAAA,EACjB,WACE,WAAW,YAAY,WACvB,WAAW,YAAY,UACvB;AAEA,WAAO,gBAAgB,CAAC;AAAA,EAC1B,WAAW,WAAW,YAAY,UAAU;AAC1C,WAAO,gBAAgB,CAAC;AAAA,EAC1B,OAAO;AACL,WAAO;AAAA,EACT;AACF;AAEO,MAAM,kBAA6B;AAAA,EACxC,QAAQ;AAAA,EACR,QAAQ;AACV;","names":[]}