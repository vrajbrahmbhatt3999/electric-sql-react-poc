{"version":3,"sources":["../../src/satellite/merge.ts"],"sourcesContent":["import {\n  OplogColumnChanges,\n  Tag,\n  OplogEntryChanges,\n  ShadowEntryChanges,\n  OplogEntry,\n  PendingChanges,\n  localOperationsToTableChanges,\n  remoteOperationsToTableChanges,\n  generateTag,\n  OPTYPES,\n} from './oplog'\nimport { difference, union } from '../util/sets'\nimport { RelationsCache, Row } from '../util'\n\n/**\n * Merge server-sent operation with local pending oplog to arrive at the same row state the server is at.\n * @param localOrigin string specifying the local origin\n * @param local local oplog entries\n * @param incomingOrigin string specifying the upstream origin\n * @param incoming incoming oplog entries\n * @returns Changes to be made to the shadow tables\n */\nexport function mergeEntries(\n  localOrigin: string,\n  local: OplogEntry[],\n  incomingOrigin: string,\n  incoming: OplogEntry[],\n  relations: RelationsCache\n): PendingChanges {\n  const localTableChanges = localOperationsToTableChanges(\n    local,\n    (timestamp: Date) => {\n      return generateTag(localOrigin, timestamp)\n    },\n    relations\n  )\n  const incomingTableChanges = remoteOperationsToTableChanges(\n    incoming,\n    relations\n  )\n\n  for (const [tablename, incomingMapping] of Object.entries(\n    incomingTableChanges\n  )) {\n    const localMapping = localTableChanges[tablename]\n\n    if (localMapping === undefined) {\n      continue\n    }\n\n    for (const [primaryKey, incomingChanges] of Object.entries(\n      incomingMapping\n    )) {\n      const localInfo = localMapping[primaryKey]\n      if (localInfo === undefined) {\n        continue\n      }\n      const [_, localChanges] = localInfo\n\n      let changes: OplogColumnChanges\n\n      if (incomingChanges.optype === 'GONE') {\n        changes = localChanges.changes\n      } else {\n        changes = mergeChangesLastWriteWins(\n          localOrigin,\n          localChanges.changes,\n          incomingOrigin,\n          incomingChanges.changes,\n          incomingChanges.fullRow\n        )\n      }\n\n      let optype\n\n      const tags = mergeOpTags(localChanges, incomingChanges)\n      if (tags.length === 0) {\n        optype = OPTYPES.delete\n      } else {\n        optype = OPTYPES.upsert\n      }\n\n      Object.assign(incomingChanges, { changes, optype, tags })\n    }\n  }\n\n  return incomingTableChanges\n}\n\n/**\n * Merge two sets of changes, using the timestamp to arbitrate conflicts\n * so that the last write wins.\n *\n * @remarks\n *\n * The `fullRow` is mutated to reflect the outcome of LWW.\n * For columns that have no changes in `second` we assign the\n * column value from `first`.\n *\n * @param firstOrigin - Origin of the first changes\n * @param first - Changes\n * @param secondOrigin - Origin of the second changes\n * @param second - Changes\n * @param fullRow - The complete row after changes in `second`\n * @returns The merged changes\n */\nexport const mergeChangesLastWriteWins = (\n  firstOrigin: string,\n  first: OplogColumnChanges,\n  secondOrigin: string,\n  second: OplogColumnChanges,\n  fullRow: Row\n): OplogColumnChanges => {\n  const allKeys = Object.keys(first).concat(Object.keys(second))\n  const uniqueKeys = Array.from(new Set(allKeys))\n\n  const initialValue: OplogColumnChanges = {}\n\n  return uniqueKeys.reduce((acc, key) => {\n    const firstValue = first[key]\n    const secondValue = second[key]\n\n    if (firstValue === undefined && secondValue === undefined) {\n      return acc\n    }\n\n    if (firstValue === undefined) {\n      acc[key] = secondValue\n    } else if (secondValue === undefined) {\n      acc[key] = firstValue\n    } else {\n      if (firstValue.timestamp === secondValue.timestamp) {\n        // origin lexicographic ordered on timestamp equality\n        acc[key] = firstOrigin > secondOrigin ? firstValue : secondValue\n      } else {\n        acc[key] =\n          firstValue.timestamp > secondValue.timestamp\n            ? firstValue\n            : secondValue\n      }\n    }\n\n    // update value of this key in the full row with the value picked by LWW\n    // if the value was modified in `first` but not in `second`\n    // acc[key] will contain the value of that column in `first`\n    fullRow[key] = acc[key].value\n\n    return acc\n  }, initialValue)\n}\n\nfunction mergeOpTags(\n  local: OplogEntryChanges,\n  remote: ShadowEntryChanges\n): Tag[] {\n  // When the server sends a GONE message, it means we need to delete this row from our side as no further\n  // updates will come through. Server doesn't keep track of seen tags, however, so we make the GONE operation\n  // have a higher priority than anything else.\n\n  // TODO: Does deleting on GONE make sense at all?\n  if (remote.optype === 'GONE') return []\n\n  return calculateTags(local.tag, remote.tags, local.clearTags)\n}\n\nfunction calculateTags(tag: Tag | null, tags: Tag[], clear: Tag[]): Tag[] {\n  if (tag === null) {\n    return difference(tags, clear)\n  } else {\n    return union([tag], difference(tags, clear))\n  }\n}\n"],"mappings":"AAAA;AAAA,EAOE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AACP,SAAS,YAAY,aAAa;AAW3B,SAAS,aACd,aACA,OACA,gBACA,UACA,WACgB;AAChB,QAAM,oBAAoB;AAAA,IACxB;AAAA,IACA,CAAC,cAAoB;AACnB,aAAO,YAAY,aAAa,SAAS;AAAA,IAC3C;AAAA,IACA;AAAA,EACF;AACA,QAAM,uBAAuB;AAAA,IAC3B;AAAA,IACA;AAAA,EACF;AAEA,aAAW,CAAC,WAAW,eAAe,KAAK,OAAO;AAAA,IAChD;AAAA,EACF,GAAG;AACD,UAAM,eAAe,kBAAkB,SAAS;AAEhD,QAAI,iBAAiB,QAAW;AAC9B;AAAA,IACF;AAEA,eAAW,CAAC,YAAY,eAAe,KAAK,OAAO;AAAA,MACjD;AAAA,IACF,GAAG;AACD,YAAM,YAAY,aAAa,UAAU;AACzC,UAAI,cAAc,QAAW;AAC3B;AAAA,MACF;AACA,YAAM,CAAC,GAAG,YAAY,IAAI;AAE1B,UAAI;AAEJ,UAAI,gBAAgB,WAAW,QAAQ;AACrC,kBAAU,aAAa;AAAA,MACzB,OAAO;AACL,kBAAU;AAAA,UACR;AAAA,UACA,aAAa;AAAA,UACb;AAAA,UACA,gBAAgB;AAAA,UAChB,gBAAgB;AAAA,QAClB;AAAA,MACF;AAEA,UAAI;AAEJ,YAAM,OAAO,YAAY,cAAc,eAAe;AACtD,UAAI,KAAK,WAAW,GAAG;AACrB,iBAAS,QAAQ;AAAA,MACnB,OAAO;AACL,iBAAS,QAAQ;AAAA,MACnB;AAEA,aAAO,OAAO,iBAAiB,EAAE,SAAS,QAAQ,KAAK,CAAC;AAAA,IAC1D;AAAA,EACF;AAEA,SAAO;AACT;AAmBO,MAAM,4BAA4B,CACvC,aACA,OACA,cACA,QACA,YACuB;AACvB,QAAM,UAAU,OAAO,KAAK,KAAK,EAAE,OAAO,OAAO,KAAK,MAAM,CAAC;AAC7D,QAAM,aAAa,MAAM,KAAK,IAAI,IAAI,OAAO,CAAC;AAE9C,QAAM,eAAmC,CAAC;AAE1C,SAAO,WAAW,OAAO,CAAC,KAAK,QAAQ;AACrC,UAAM,aAAa,MAAM,GAAG;AAC5B,UAAM,cAAc,OAAO,GAAG;AAE9B,QAAI,eAAe,UAAa,gBAAgB,QAAW;AACzD,aAAO;AAAA,IACT;AAEA,QAAI,eAAe,QAAW;AAC5B,UAAI,GAAG,IAAI;AAAA,IACb,WAAW,gBAAgB,QAAW;AACpC,UAAI,GAAG,IAAI;AAAA,IACb,OAAO;AACL,UAAI,WAAW,cAAc,YAAY,WAAW;AAElD,YAAI,GAAG,IAAI,cAAc,eAAe,aAAa;AAAA,MACvD,OAAO;AACL,YAAI,GAAG,IACL,WAAW,YAAY,YAAY,YAC/B,aACA;AAAA,MACR;AAAA,IACF;AAKA,YAAQ,GAAG,IAAI,IAAI,GAAG,EAAE;AAExB,WAAO;AAAA,EACT,GAAG,YAAY;AACjB;AAEA,SAAS,YACP,OACA,QACO;AAMP,MAAI,OAAO,WAAW;AAAQ,WAAO,CAAC;AAEtC,SAAO,cAAc,MAAM,KAAK,OAAO,MAAM,MAAM,SAAS;AAC9D;AAEA,SAAS,cAAc,KAAiB,MAAa,OAAqB;AACxE,MAAI,QAAQ,MAAM;AAChB,WAAO,WAAW,MAAM,KAAK;AAAA,EAC/B,OAAO;AACL,WAAO,MAAM,CAAC,GAAG,GAAG,WAAW,MAAM,KAAK,CAAC;AAAA,EAC7C;AACF;","names":[]}