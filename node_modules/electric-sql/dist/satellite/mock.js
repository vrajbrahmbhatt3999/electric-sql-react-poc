import { sleepAsync } from '../util/timer.js';
import {
  SatelliteError,
  SatelliteErrorCode,
  ReplicationStatus,
  DataChangeType
} from '../util/types.js';
import { satelliteDefaults } from './config.js';
import { BaseRegistry } from './registry.js';
import {
  DEFAULT_LOG_POS,
  subsDataErrorToSatelliteError,
  AsyncEventEmitter,
  genUUID
} from '../util/index.js';
import { base64, bytesToNumber } from '../util/encoders/index.js';
import { generateTag } from './oplog.js';
import {
  SUBSCRIPTION_DELIVERED,
  SUBSCRIPTION_ERROR
} from './shapes/types.js';
import {
  SatSubsDataError,
  SatSubsDataError_Code,
  SatSubsDataError_ShapeReqError,
  SatSubsDataError_ShapeReqError_Code
} from '../_generated/protocol/satellite.js';
import { getTableNamesForShapes } from './shapes/shapeManager.js';
const MOCK_BEHIND_WINDOW_LSN = 42;
const MOCK_INTERNAL_ERROR = 27;
class MockSatelliteProcess {
  dbName;
  adapter;
  migrator;
  notifier;
  socketFactory;
  opts;
  token;
  connectivityState;
  constructor(dbName, adapter, migrator, notifier, socketFactory, opts) {
    this.dbName = dbName;
    this.adapter = adapter;
    this.migrator = migrator;
    this.notifier = notifier;
    this.socketFactory = socketFactory;
    this.opts = opts;
    this.connectivityState = { status: "disconnected" };
  }
  syncStatus(_key) {
    return void 0;
  }
  subscribe(_shapeDefinitions) {
    return Promise.resolve({
      key: "test",
      synced: Promise.resolve()
    });
  }
  unsubscribe(_shapeUuid) {
    throw new Error("Method not implemented.");
  }
  async start() {
    await sleepAsync(50);
  }
  setToken(token) {
    this.token = token;
  }
  hasToken() {
    return this.token !== void 0;
  }
  async connect() {
    await sleepAsync(50);
  }
  async connectWithBackoff() {
    await this.connect();
  }
  disconnect() {
  }
  clientDisconnect() {
  }
  authenticate(_token) {
    return Promise.resolve();
  }
  async stop() {
    await sleepAsync(50);
  }
  setReplicationTransform(_tableName, _transform) {
  }
  clearReplicationTransform(_tableName) {
  }
}
class MockRegistry extends BaseRegistry {
  shouldFailToStart = false;
  setShouldFailToStart(shouldFail) {
    this.shouldFailToStart = shouldFail;
  }
  async startProcess(dbName, _dbDescription, adapter, migrator, notifier, socketFactory, _config, overrides) {
    if (this.shouldFailToStart) {
      throw new Error("Failed to start satellite process");
    }
    const namespace = migrator.queryBuilder.defaultNamespace;
    const opts = { ...satelliteDefaults(namespace), ...overrides };
    const satellites = this.satellites;
    if (satellites[dbName] !== void 0) {
      return satellites[dbName];
    }
    const satellite = new MockSatelliteProcess(
      dbName,
      adapter,
      migrator,
      notifier,
      socketFactory,
      opts
    );
    this.satellites[dbName] = satellite;
    await satellite.start();
    return satellite;
  }
}
class MockSatelliteClient extends AsyncEventEmitter {
  isDown = false;
  replicating = false;
  disconnected = true;
  inboundAck = DEFAULT_LOG_POS;
  outboundSent = DEFAULT_LOG_POS;
  outboundTransactionsEnqueued = [];
  // to clear any pending timeouts
  timeouts = [];
  relations = {};
  relationsCb;
  transactionsCb;
  additionalDataCb;
  outboundStartedCallback;
  relationData = {};
  goneBatches = {};
  deliverFirst = false;
  doSkipNextEmit = false;
  startReplicationDelayMs = null;
  replicationTransforms = /* @__PURE__ */ new Map();
  setStartReplicationDelayMs(delayMs) {
    this.startReplicationDelayMs = delayMs;
  }
  setRelations(relations) {
    this.relations = relations;
    if (this.relationsCb) {
      Object.values(relations).forEach(this.relationsCb);
    }
  }
  setRelationData(tablename, record) {
    if (!this.relationData[tablename]) {
      this.relationData[tablename] = [];
    }
    const data = this.relationData[tablename];
    data.push(record);
  }
  setGoneBatch(subscriptionId, batch) {
    this.goneBatches[subscriptionId] = batch.map((x) => ({
      type: DataChangeType.GONE,
      tags: [],
      relation: this.relations[x.tablename],
      oldRecord: x.record
    }));
  }
  enableDeliverFirst() {
    this.deliverFirst = true;
  }
  skipNextEmit() {
    this.doSkipNextEmit = true;
  }
  subscribe(subscriptionId, shapes) {
    const data = [];
    const shapeReqToUuid = {};
    for (const shape of shapes) {
      const tables = getTableNamesForShapes([shape.definition], "main");
      for (const { tablename } of tables) {
        if (tablename === "failure" || tablename === "Items") {
          return Promise.resolve({
            subscriptionId,
            error: new SatelliteError(SatelliteErrorCode.TABLE_NOT_FOUND)
          });
        } else if (tablename === "another" || tablename === "User") {
          return new Promise((resolve) => {
            this.sendErrorAfterTimeout(subscriptionId, 1);
            resolve({
              subscriptionId
            });
          });
        } else {
          shapeReqToUuid[shape.requestId] = genUUID();
          const records = this.relationData[tablename] ?? [];
          for (const record of records) {
            const dataChange = {
              relation: this.relations[tablename],
              record,
              tags: [generateTag("remote", /* @__PURE__ */ new Date())]
            };
            data.push(dataChange);
          }
        }
      }
    }
    return new Promise((resolve) => {
      const emit = () => {
        this.enqueueEmit(SUBSCRIPTION_DELIVERED, {
          subscriptionId,
          lsn: base64.toBytes("MTIz"),
          // base64.encode("123")
          data,
          shapeReqToUuid
        });
      };
      const resolveProm = () => {
        resolve({
          subscriptionId
        });
      };
      if (this.deliverFirst) {
        emit();
        setTimeout(resolveProm, 1);
      } else {
        if (!this.doSkipNextEmit)
          setTimeout(emit, 1);
        else
          this.doSkipNextEmit = false;
        resolveProm();
      }
    });
  }
  unsubscribe(subIds) {
    const gone = [];
    for (const id of subIds) {
      gone.push(...this.goneBatches[id] ?? []);
      delete this.goneBatches[id];
    }
    setTimeout(
      () => this.enqueueEmit(
        "goneBatch",
        base64.toBytes(base64.encode("124")),
        subIds,
        gone
      ),
      1
    );
    return Promise.resolve({});
  }
  subscribeToSubscriptionEvents(successCallback, errorCallback) {
    this.on(SUBSCRIPTION_DELIVERED, successCallback);
    this.on(SUBSCRIPTION_ERROR, errorCallback);
  }
  unsubscribeToSubscriptionEvents(successCallback, errorCallback) {
    this.removeListener(SUBSCRIPTION_DELIVERED, successCallback);
    this.removeListener(SUBSCRIPTION_ERROR, errorCallback);
  }
  subscribeToGoneBatch(callback) {
    this.on("goneBatch", callback);
  }
  unsubscribeToGoneBatch(callback) {
    this.off("goneBatch", callback);
  }
  subscribeToError(cb) {
    this.on("error", cb);
  }
  emitSocketClosedError(ev) {
    this.enqueueEmit("error", new SatelliteError(ev, "socket closed"));
  }
  unsubscribeToError(cb) {
    this.removeListener("error", cb);
  }
  isConnected() {
    return !this.disconnected;
  }
  getOutboundReplicationStatus() {
    return this.isConnected() && this.replicating ? ReplicationStatus.ACTIVE : ReplicationStatus.STOPPED;
  }
  async shutdown() {
    await this.waitForProcessing();
    this.isDown = true;
  }
  getLastSentLsn() {
    return this.outboundSent;
  }
  connect() {
    if (this.isDown) {
      throw new SatelliteError(SatelliteErrorCode.UNEXPECTED_STATE, "FAKE DOWN");
    }
    this.disconnected = false;
    return Promise.resolve();
  }
  disconnect() {
    this.disconnected = true;
    for (const t of this.timeouts) {
      clearTimeout(t);
    }
    return Promise.resolve();
  }
  authenticate(_authState) {
    return Promise.resolve({});
  }
  async startReplication(lsn) {
    if (this.startReplicationDelayMs) {
      await sleepAsync(this.startReplicationDelayMs);
    }
    this.replicating = true;
    this.inboundAck = lsn;
    const t = setTimeout(() => this.enqueueEmit("outbound_started"), 100);
    this.timeouts.push(t);
    if (lsn && bytesToNumber(lsn) == MOCK_BEHIND_WINDOW_LSN) {
      return {
        error: new SatelliteError(
          SatelliteErrorCode.BEHIND_WINDOW,
          "MOCK BEHIND_WINDOW_LSN ERROR"
        )
      };
    }
    if (lsn && bytesToNumber(lsn) == MOCK_INTERNAL_ERROR) {
      return {
        error: new SatelliteError(
          SatelliteErrorCode.INTERNAL,
          "MOCK INTERNAL_ERROR"
        )
      };
    }
    return Promise.resolve({});
  }
  stopReplication() {
    this.replicating = false;
    return Promise.resolve({});
  }
  subscribeToRelations(callback) {
    this.relationsCb = callback;
  }
  unsubscribeToRelations() {
    this.relationsCb = void 0;
  }
  subscribeToTransactions(callback) {
    this.transactionsCb = callback;
  }
  unsubscribeToTransactions() {
    this.transactionsCb = void 0;
  }
  subscribeToAdditionalData(callback) {
    this.additionalDataCb = callback;
  }
  unsubscribeToAdditionalData(_cb) {
    this.additionalDataCb = void 0;
  }
  enqueueTransaction(transaction) {
    if (!this.replicating) {
      throw new SatelliteError(
        SatelliteErrorCode.REPLICATION_NOT_STARTED,
        "enqueuing a transaction while outbound replication has not started"
      );
    }
    this.outboundTransactionsEnqueued.push(transaction);
    this.outboundSent = transaction.lsn;
  }
  subscribeToOutboundStarted(callback) {
    this.on("outbound_started", callback);
    this.outboundStartedCallback = callback;
  }
  unsubscribeToOutboundStarted() {
    if (!this.outboundStartedCallback)
      return;
    this.removeListener("outbound_started", this.outboundStartedCallback);
    this.outboundStartedCallback = void 0;
  }
  sendErrorAfterTimeout(subscriptionId, timeout) {
    setTimeout(() => {
      const satSubsError = SatSubsDataError.fromPartial({
        code: SatSubsDataError_Code.SHAPE_DELIVERY_ERROR,
        message: "there were shape errors",
        subscriptionId,
        shapeRequestError: [
          SatSubsDataError_ShapeReqError.fromPartial({
            code: SatSubsDataError_ShapeReqError_Code.SHAPE_SIZE_LIMIT_EXCEEDED,
            message: "Requested shape for table 'another' exceeds the maximum allowed shape size"
          })
        ]
      });
      const satError = subsDataErrorToSatelliteError(satSubsError);
      this.enqueueEmit(SUBSCRIPTION_ERROR, satError, subscriptionId);
    }, timeout);
  }
  setReplicationTransform(tableName, transform) {
    this.replicationTransforms.set(tableName.tablename, transform);
  }
  clearReplicationTransform(tableName) {
    this.replicationTransforms.delete(tableName.tablename);
  }
}
export {
  MOCK_BEHIND_WINDOW_LSN,
  MOCK_INTERNAL_ERROR,
  MockRegistry,
  MockSatelliteClient,
  MockSatelliteProcess
};
//# sourceMappingURL=mock.js.map