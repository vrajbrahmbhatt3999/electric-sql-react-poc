import {
  satelliteDefaults,
  validateConfig
} from './config.js';
import { SatelliteProcess } from './process.js';
import { SatelliteClient } from './client.js';
class BaseRegistry {
  satellites;
  startingPromises;
  stoppingPromises;
  constructor() {
    this.satellites = {};
    this.startingPromises = {};
    this.stoppingPromises = {};
  }
  async ensureStarted(dbName, dbDescription, adapter, migrator, notifier, socketFactory, config, opts) {
    const stoppingPromises = this.stoppingPromises;
    const stopping = stoppingPromises[dbName];
    if (stopping !== void 0) {
      return stopping.then(
        () => this.ensureStarted(
          dbName,
          dbDescription,
          adapter,
          migrator,
          notifier,
          socketFactory,
          config,
          opts
        )
      );
    }
    const startingPromises = this.startingPromises;
    const starting = startingPromises[dbName];
    if (starting !== void 0) {
      return starting;
    }
    const satellites = this.satellites;
    const satellite = satellites[dbName];
    if (satellite !== void 0) {
      return satellite;
    }
    const startingPromise = this.startProcess(
      dbName,
      dbDescription,
      adapter,
      migrator,
      notifier,
      socketFactory,
      config
    ).then((satellite2) => {
      satellites[dbName] = satellite2;
      return satellite2;
    }).finally(() => {
      delete startingPromises[dbName];
    });
    startingPromises[dbName] = startingPromise;
    return startingPromise;
  }
  async ensureAlreadyStarted(dbName) {
    const starting = this.startingPromises[dbName];
    if (starting !== void 0) {
      return starting;
    }
    const satellite = this.satellites[dbName];
    if (satellite !== void 0) {
      return satellite;
    }
    throw new Error(`Satellite not running for db: ${dbName}`);
  }
  stop(dbName, shouldIncludeStarting = true) {
    if (shouldIncludeStarting) {
      const stop = this.stop.bind(this);
      const startingPromises = this.startingPromises;
      const starting = startingPromises[dbName];
      if (starting !== void 0) {
        return starting.then((_satellite) => stop(dbName));
      }
    }
    const stoppingPromises = this.stoppingPromises;
    const stopping = stoppingPromises[dbName];
    if (stopping !== void 0) {
      return stopping;
    }
    const satellites = this.satellites;
    const satellite = satellites[dbName];
    if (satellite !== void 0) {
      const stoppingPromise = satellite.stop(true).then(() => {
        delete satellites[dbName];
        delete stoppingPromises[dbName];
      });
      stoppingPromises[dbName] = stoppingPromise;
      return stoppingPromise;
    } else {
      return Promise.resolve();
    }
  }
  async stopAll(shouldIncludeStarting = true) {
    const stop = this.stop.bind(this);
    const running = Object.keys(this.satellites).map((dbName) => stop(dbName));
    const stopping = Object.values(this.stoppingPromises);
    let promisesToStop = running.concat(stopping);
    if (shouldIncludeStarting) {
      const starting = Object.entries(this.startingPromises).map(
        ([dbName, started]) => started.then(() => stop(dbName))
      );
      promisesToStop = promisesToStop.concat(starting);
    }
    await Promise.all(promisesToStop);
  }
}
class GlobalRegistry extends BaseRegistry {
  async startProcess(dbName, dbDescription, adapter, migrator, notifier, socketFactory, config) {
    const foundErrors = validateConfig(config);
    if (foundErrors.length > 0) {
      throw Error(`invalid config: ${foundErrors}`);
    }
    const satelliteClientOpts = {
      host: config.replication.host,
      port: config.replication.port,
      ssl: config.replication.ssl,
      timeout: config.replication.timeout,
      dialect: config.replication.dialect
    };
    const client = new SatelliteClient(
      dbDescription,
      socketFactory,
      satelliteClientOpts
    );
    const satelliteOpts = {
      ...satelliteDefaults(config.namespace),
      connectionBackOffOptions: config.connectionBackOffOptions,
      fkChecks: config.fkChecks,
      debug: config.debug
    };
    const satellite = new SatelliteProcess(
      dbName,
      adapter,
      migrator,
      notifier,
      client,
      satelliteOpts
    );
    await satellite.start(config.auth);
    return satellite;
  }
}
const globalRegistry = new GlobalRegistry();
export {
  BaseRegistry,
  GlobalRegistry,
  globalRegistry
};
//# sourceMappingURL=registry.js.map