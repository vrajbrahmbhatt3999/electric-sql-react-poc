{"version":3,"sources":["../../src/satellite/registry.ts"],"sourcesContent":["import { InternalElectricConfig, HydratedConfig } from '../config/index'\nimport { DatabaseAdapter } from '../electric/adapter'\nimport { Migrator } from '../migrators/index'\nimport { Notifier } from '../notifiers/index'\nimport { DbName } from '../util/types'\n\nimport { Satellite, Registry } from './index'\nimport {\n  SatelliteClientOpts,\n  SatelliteOpts,\n  SatelliteOverrides,\n  satelliteDefaults,\n  validateConfig,\n} from './config'\nimport { SatelliteProcess } from './process'\nimport { SocketFactory } from '../sockets'\nimport { SatelliteClient } from './client'\nimport { DbSchema } from '../client/model'\n\nexport abstract class BaseRegistry implements Registry {\n  satellites: {\n    [key: DbName]: Satellite\n  }\n\n  startingPromises: {\n    [key: DbName]: Promise<Satellite>\n  }\n  stoppingPromises: {\n    [key: DbName]: Promise<void>\n  }\n\n  constructor() {\n    this.satellites = {}\n    this.startingPromises = {}\n    this.stoppingPromises = {}\n  }\n\n  abstract startProcess(\n    dbName: DbName,\n    dbDescription: DbSchema<any>,\n    adapter: DatabaseAdapter,\n    migrator: Migrator,\n    notifier: Notifier,\n    socketFactory: SocketFactory,\n    config: InternalElectricConfig,\n    opts?: SatelliteOverrides\n  ): Promise<Satellite>\n\n  async ensureStarted(\n    dbName: DbName,\n    dbDescription: DbSchema<any>,\n    adapter: DatabaseAdapter,\n    migrator: Migrator,\n    notifier: Notifier,\n    socketFactory: SocketFactory,\n    config: InternalElectricConfig,\n    opts?: SatelliteOverrides\n  ): Promise<Satellite> {\n    // If we're in the process of stopping the satellite process for this\n    // dbName, then we wait for the process to be stopped and then we\n    // call this function again to retry starting it.\n    const stoppingPromises = this.stoppingPromises\n    const stopping = stoppingPromises[dbName]\n    if (stopping !== undefined) {\n      return stopping.then(() =>\n        this.ensureStarted(\n          dbName,\n          dbDescription,\n          adapter,\n          migrator,\n          notifier,\n          socketFactory,\n          config,\n          opts\n        )\n      )\n    }\n\n    // If we're in the process of starting the satellite process for this\n    // dbName, then we short circuit and return that process. Note that\n    // this assumes that the previous call to start the process for this\n    // dbName would have passed in functionally equivalent `dbAdapter`,\n    // `fs` and `notifier` arguments. Which is *probably* a safe assumption\n    // in the case where this might happen, which is multiple components\n    // in the same app opening a connection to the same db at the same time.\n    const startingPromises = this.startingPromises\n    const starting = startingPromises[dbName]\n    if (starting !== undefined) {\n      return starting\n    }\n\n    // If we already have a satellite process running for this db, then\n    // return it.\n    const satellites = this.satellites\n    const satellite = satellites[dbName]\n    if (satellite !== undefined) {\n      return satellite\n    }\n\n    // Otherwise we need to fire it up!\n    const startingPromise = this.startProcess(\n      dbName,\n      dbDescription,\n      adapter,\n      migrator,\n      notifier,\n      socketFactory,\n      config\n    )\n      .then((satellite) => {\n        satellites[dbName] = satellite\n\n        return satellite\n      })\n      .finally(() => {\n        // Clean up the starting promise, whether it resolved or rejected.\n        delete startingPromises[dbName]\n      })\n\n    startingPromises[dbName] = startingPromise\n    return startingPromise\n  }\n\n  async ensureAlreadyStarted(dbName: DbName): Promise<Satellite> {\n    const starting = this.startingPromises[dbName]\n    if (starting !== undefined) {\n      return starting\n    }\n\n    const satellite = this.satellites[dbName]\n    if (satellite !== undefined) {\n      return satellite\n    }\n\n    throw new Error(`Satellite not running for db: ${dbName}`)\n  }\n\n  stop(dbName: DbName, shouldIncludeStarting = true): Promise<void> {\n    // If in the process of starting, wait for it to start and then stop it.\n    if (shouldIncludeStarting) {\n      const stop = this.stop.bind(this)\n      const startingPromises = this.startingPromises\n      const starting = startingPromises[dbName]\n      if (starting !== undefined) {\n        return starting.then((_satellite) => stop(dbName))\n      }\n    }\n\n    // If already stopping then return that promise.\n    const stoppingPromises = this.stoppingPromises\n    const stopping = stoppingPromises[dbName]\n    if (stopping !== undefined) {\n      return stopping\n    }\n\n    // Otherwise, if running then stop.\n    const satellites = this.satellites\n    const satellite = satellites[dbName]\n    if (satellite !== undefined) {\n      const stoppingPromise = satellite.stop(true).then(() => {\n        delete satellites[dbName]\n        delete stoppingPromises[dbName]\n      })\n\n      stoppingPromises[dbName] = stoppingPromise\n      return stoppingPromise\n    } else {\n      return Promise.resolve()\n    }\n  }\n\n  async stopAll(shouldIncludeStarting = true): Promise<void> {\n    const stop = this.stop.bind(this)\n\n    const running = Object.keys(this.satellites).map((dbName) => stop(dbName))\n    const stopping = Object.values(this.stoppingPromises)\n\n    let promisesToStop = running.concat(stopping)\n    if (shouldIncludeStarting) {\n      const starting = Object.entries(this.startingPromises).map(\n        ([dbName, started]) => started.then(() => stop(dbName))\n      )\n\n      promisesToStop = promisesToStop.concat(starting)\n    }\n\n    await Promise.all(promisesToStop)\n  }\n}\n\nexport class GlobalRegistry extends BaseRegistry {\n  async startProcess(\n    dbName: DbName,\n    dbDescription: DbSchema<any>,\n    adapter: DatabaseAdapter,\n    migrator: Migrator,\n    notifier: Notifier,\n    socketFactory: SocketFactory,\n    config: HydratedConfig\n  ): Promise<Satellite> {\n    const foundErrors = validateConfig(config)\n    if (foundErrors.length > 0) {\n      throw Error(`invalid config: ${foundErrors}`)\n    }\n\n    const satelliteClientOpts: SatelliteClientOpts = {\n      host: config.replication.host,\n      port: config.replication.port,\n      ssl: config.replication.ssl,\n      timeout: config.replication.timeout,\n      dialect: config.replication.dialect,\n    }\n\n    const client = new SatelliteClient(\n      dbDescription,\n      socketFactory,\n      satelliteClientOpts\n    )\n\n    const satelliteOpts: SatelliteOpts = {\n      ...satelliteDefaults(config.namespace),\n      connectionBackOffOptions: config.connectionBackOffOptions,\n      fkChecks: config.fkChecks,\n      debug: config.debug,\n    }\n\n    const satellite = new SatelliteProcess(\n      dbName,\n      adapter,\n      migrator,\n      notifier,\n      client,\n      satelliteOpts\n    )\n    await satellite.start(config.auth)\n\n    return satellite\n  }\n}\n\nexport const globalRegistry = new GlobalRegistry()\n"],"mappings":"AAOA;AAAA,EAIE;AAAA,EACA;AAAA,OACK;AACP,SAAS,wBAAwB;AAEjC,SAAS,uBAAuB;AAGzB,MAAe,aAAiC;AAAA,EACrD;AAAA,EAIA;AAAA,EAGA;AAAA,EAIA,cAAc;AACZ,SAAK,aAAa,CAAC;AACnB,SAAK,mBAAmB,CAAC;AACzB,SAAK,mBAAmB,CAAC;AAAA,EAC3B;AAAA,EAaA,MAAM,cACJ,QACA,eACA,SACA,UACA,UACA,eACA,QACA,MACoB;AAIpB,UAAM,mBAAmB,KAAK;AAC9B,UAAM,WAAW,iBAAiB,MAAM;AACxC,QAAI,aAAa,QAAW;AAC1B,aAAO,SAAS;AAAA,QAAK,MACnB,KAAK;AAAA,UACH;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAAA,IACF;AASA,UAAM,mBAAmB,KAAK;AAC9B,UAAM,WAAW,iBAAiB,MAAM;AACxC,QAAI,aAAa,QAAW;AAC1B,aAAO;AAAA,IACT;AAIA,UAAM,aAAa,KAAK;AACxB,UAAM,YAAY,WAAW,MAAM;AACnC,QAAI,cAAc,QAAW;AAC3B,aAAO;AAAA,IACT;AAGA,UAAM,kBAAkB,KAAK;AAAA,MAC3B;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,EACG,KAAK,CAACA,eAAc;AACnB,iBAAW,MAAM,IAAIA;AAErB,aAAOA;AAAA,IACT,CAAC,EACA,QAAQ,MAAM;AAEb,aAAO,iBAAiB,MAAM;AAAA,IAChC,CAAC;AAEH,qBAAiB,MAAM,IAAI;AAC3B,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,qBAAqB,QAAoC;AAC7D,UAAM,WAAW,KAAK,iBAAiB,MAAM;AAC7C,QAAI,aAAa,QAAW;AAC1B,aAAO;AAAA,IACT;AAEA,UAAM,YAAY,KAAK,WAAW,MAAM;AACxC,QAAI,cAAc,QAAW;AAC3B,aAAO;AAAA,IACT;AAEA,UAAM,IAAI,MAAM,iCAAiC,MAAM,EAAE;AAAA,EAC3D;AAAA,EAEA,KAAK,QAAgB,wBAAwB,MAAqB;AAEhE,QAAI,uBAAuB;AACzB,YAAM,OAAO,KAAK,KAAK,KAAK,IAAI;AAChC,YAAM,mBAAmB,KAAK;AAC9B,YAAM,WAAW,iBAAiB,MAAM;AACxC,UAAI,aAAa,QAAW;AAC1B,eAAO,SAAS,KAAK,CAAC,eAAe,KAAK,MAAM,CAAC;AAAA,MACnD;AAAA,IACF;AAGA,UAAM,mBAAmB,KAAK;AAC9B,UAAM,WAAW,iBAAiB,MAAM;AACxC,QAAI,aAAa,QAAW;AAC1B,aAAO;AAAA,IACT;AAGA,UAAM,aAAa,KAAK;AACxB,UAAM,YAAY,WAAW,MAAM;AACnC,QAAI,cAAc,QAAW;AAC3B,YAAM,kBAAkB,UAAU,KAAK,IAAI,EAAE,KAAK,MAAM;AACtD,eAAO,WAAW,MAAM;AACxB,eAAO,iBAAiB,MAAM;AAAA,MAChC,CAAC;AAED,uBAAiB,MAAM,IAAI;AAC3B,aAAO;AAAA,IACT,OAAO;AACL,aAAO,QAAQ,QAAQ;AAAA,IACzB;AAAA,EACF;AAAA,EAEA,MAAM,QAAQ,wBAAwB,MAAqB;AACzD,UAAM,OAAO,KAAK,KAAK,KAAK,IAAI;AAEhC,UAAM,UAAU,OAAO,KAAK,KAAK,UAAU,EAAE,IAAI,CAAC,WAAW,KAAK,MAAM,CAAC;AACzE,UAAM,WAAW,OAAO,OAAO,KAAK,gBAAgB;AAEpD,QAAI,iBAAiB,QAAQ,OAAO,QAAQ;AAC5C,QAAI,uBAAuB;AACzB,YAAM,WAAW,OAAO,QAAQ,KAAK,gBAAgB,EAAE;AAAA,QACrD,CAAC,CAAC,QAAQ,OAAO,MAAM,QAAQ,KAAK,MAAM,KAAK,MAAM,CAAC;AAAA,MACxD;AAEA,uBAAiB,eAAe,OAAO,QAAQ;AAAA,IACjD;AAEA,UAAM,QAAQ,IAAI,cAAc;AAAA,EAClC;AACF;AAEO,MAAM,uBAAuB,aAAa;AAAA,EAC/C,MAAM,aACJ,QACA,eACA,SACA,UACA,UACA,eACA,QACoB;AACpB,UAAM,cAAc,eAAe,MAAM;AACzC,QAAI,YAAY,SAAS,GAAG;AAC1B,YAAM,MAAM,mBAAmB,WAAW,EAAE;AAAA,IAC9C;AAEA,UAAM,sBAA2C;AAAA,MAC/C,MAAM,OAAO,YAAY;AAAA,MACzB,MAAM,OAAO,YAAY;AAAA,MACzB,KAAK,OAAO,YAAY;AAAA,MACxB,SAAS,OAAO,YAAY;AAAA,MAC5B,SAAS,OAAO,YAAY;AAAA,IAC9B;AAEA,UAAM,SAAS,IAAI;AAAA,MACjB;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,UAAM,gBAA+B;AAAA,MACnC,GAAG,kBAAkB,OAAO,SAAS;AAAA,MACrC,0BAA0B,OAAO;AAAA,MACjC,UAAU,OAAO;AAAA,MACjB,OAAO,OAAO;AAAA,IAChB;AAEA,UAAM,YAAY,IAAI;AAAA,MACpB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,UAAM,UAAU,MAAM,OAAO,IAAI;AAEjC,WAAO;AAAA,EACT;AACF;AAEO,MAAM,iBAAiB,IAAI,eAAe;","names":["satellite"]}