import Long from "long";
import { QualifiedTablename } from '../util/tablename.js';
import { union } from '../util/sets.js';
import {
  numberToBytes,
  blobToHexString,
  hexStringToBlob
} from '../util/encoders/index.js';
const OPTYPES = {
  insert: "INSERT",
  update: "UPDATE",
  delete: "DELETE",
  upsert: "UPSERT",
  compensation: "COMPENSATION",
  gone: "GONE"
};
const shadowTagsDefault = "[]";
const stringToOpType = (opTypeStr) => {
  switch (opTypeStr) {
    case "INSERT":
      return OPTYPES.insert;
    case "UPDATE":
      return OPTYPES.update;
    case "DELETE":
      return OPTYPES.delete;
    case "COMPENSATION":
      return OPTYPES.compensation;
    case "GONE":
      return OPTYPES.gone;
  }
  throw new Error(`unexpected opType string: ${opTypeStr}`);
};
const localEntryToChanges = (entry, tag, relations) => {
  const relation = relations[entry.tablename];
  const result = {
    namespace: entry.namespace,
    tablename: entry.tablename,
    primaryKeyCols: deserialiseRow(entry.primaryKey, relation),
    optype: entry.optype === OPTYPES.delete ? OPTYPES.delete : OPTYPES.upsert,
    changes: {},
    tag: entry.optype === OPTYPES.delete ? null : tag,
    clearTags: decodeTags(entry.clearTags)
  };
  const oldRow = entry.oldRow ? deserialiseRow(entry.oldRow, relation) : {};
  const newRow = entry.newRow ? deserialiseRow(entry.newRow, relation) : {};
  const timestamp = new Date(entry.timestamp).getTime();
  for (const [key, value] of Object.entries(newRow)) {
    if (oldRow[key] !== value) {
      result.changes[key] = { value, timestamp };
    }
  }
  return result;
};
const remoteEntryToChanges = (entry, relations) => {
  const relation = relations[entry.tablename];
  const oldRow = entry.oldRow ? deserialiseRow(entry.oldRow, relation) : {};
  const newRow = entry.newRow ? deserialiseRow(entry.newRow, relation) : {};
  const result = {
    namespace: entry.namespace,
    tablename: entry.tablename,
    primaryKeyCols: deserialiseRow(entry.primaryKey, relation),
    optype: optypeToShadow(entry.optype),
    changes: {},
    // if it is a delete, then `newRow` is empty so the full row is the old row
    fullRow: entry.optype === OPTYPES.delete ? oldRow : newRow,
    tags: decodeTags(entry.clearTags)
  };
  const timestamp = new Date(entry.timestamp).getTime();
  for (const [key, value] of Object.entries(newRow)) {
    if (oldRow[key] !== value) {
      result.changes[key] = { value, timestamp };
    }
  }
  return result;
};
function optypeToShadow(optype) {
  switch (optype) {
    case "DELETE":
      return "DELETE";
    case "GONE":
      return "GONE";
    case "INSERT":
    case "UPDATE":
      return "UPSERT";
    default:
      throw new Error(`Unexpected optype: ${optype}`);
  }
}
const localOperationsToTableChanges = (operations, genTag, relations) => {
  const initialValue = {};
  return operations.reduce((acc, entry) => {
    const entryChanges = localEntryToChanges(
      entry,
      genTag(new Date(entry.timestamp)),
      relations
    );
    const primaryKeyStr = primaryKeyToStr(entryChanges.primaryKeyCols);
    const qualifiedTablename = new QualifiedTablename(
      entryChanges.namespace,
      entryChanges.tablename
    );
    const tablenameStr = qualifiedTablename.toString();
    if (acc[tablenameStr] === void 0) {
      acc[tablenameStr] = {};
    }
    if (acc[tablenameStr][primaryKeyStr] === void 0) {
      acc[tablenameStr][primaryKeyStr] = [entry.timestamp, entryChanges];
    } else {
      const [timestamp, existing] = acc[tablenameStr][primaryKeyStr];
      existing.optype = entryChanges.optype;
      for (const [key, value] of Object.entries(entryChanges.changes)) {
        existing.changes[key] = value;
      }
      if (entryChanges.optype === "DELETE") {
        existing.tag = null;
      } else {
        existing.tag = genTag(new Date(entry.timestamp));
      }
      if (timestamp === entry.timestamp) {
        existing.clearTags = entryChanges.clearTags;
      } else {
        existing.clearTags = union(entryChanges.clearTags, existing.clearTags);
      }
    }
    return acc;
  }, initialValue);
};
const remoteOperationsToTableChanges = (operations, relations) => {
  const initialValue = {};
  return operations.reduce((acc, entry) => {
    const entryChanges = remoteEntryToChanges(entry, relations);
    const primaryKeyStr = primaryKeyToStr(entryChanges.primaryKeyCols);
    const qualifiedTablename = new QualifiedTablename(
      entryChanges.namespace,
      entryChanges.tablename
    );
    const tablenameStr = qualifiedTablename.toString();
    if (acc[tablenameStr] === void 0) {
      acc[tablenameStr] = {};
    }
    if (acc[tablenameStr][primaryKeyStr] === void 0) {
      acc[tablenameStr][primaryKeyStr] = entryChanges;
    } else {
      const existing = acc[tablenameStr][primaryKeyStr];
      existing.optype = entryChanges.optype;
      for (const [key, value] of Object.entries(entryChanges.changes)) {
        existing.changes[key] = value;
        existing.fullRow[key] = value.value;
      }
    }
    return acc;
  }, initialValue);
};
function serialiseRow(row) {
  return JSON.stringify(row, (_key, value) => {
    if (typeof value === "number") {
      if (Number.isNaN(value)) {
        return "NaN";
      } else if (value === Infinity) {
        return "Inf";
      } else if (value === -Infinity) {
        return "-Inf";
      }
    }
    if (typeof value === "bigint") {
      return value.toString();
    }
    if (value instanceof Uint8Array) {
      return blobToHexString(value);
    }
    return value;
  });
}
function deserialiseRow(str, rel) {
  return JSON.parse(str, (key, value) => {
    if (value === null)
      return null;
    const columnType = rel.columns.find((c) => c.name === key)?.type?.toUpperCase();
    if ((columnType === "FLOAT4" || columnType === "FLOAT8" || columnType === "REAL") && typeof value === "string") {
      if (value === "NaN") {
        return NaN;
      } else if (value === "Inf") {
        return Infinity;
      } else if (value === "-Inf") {
        return -Infinity;
      } else {
        return Number(value);
      }
    }
    if (columnType === "INT8" || columnType === "BIGINT") {
      return BigInt(value);
    }
    if ((columnType === "BYTEA" || columnType === "BLOB") && typeof value === "string") {
      return hexStringToBlob(value);
    }
    return value;
  });
}
function extractPK(c) {
  const columnValues = c.record ? c.record : c.oldRecord;
  return primaryKeyToStr(
    c.relation.columns.filter((c2) => c2.primaryKey).reduce((primaryKeyRec, col) => {
      primaryKeyRec[col.name] = columnValues[col.name];
      return primaryKeyRec;
    }, {})
  );
}
const fromTransaction = (transaction, _relations, namespace) => {
  return transaction.changes.map((t) => {
    return {
      namespace,
      tablename: t.relation.table,
      optype: stringToOpType(t.type),
      newRow: serialiseRow(t.record),
      oldRow: serialiseRow(t.oldRecord),
      primaryKey: extractPK(t),
      rowid: -1,
      // not required
      timestamp: new Date(
        transaction.commit_timestamp.toNumber()
      ).toISOString(),
      // TODO: check precision
      clearTags: encodeTags(t.tags)
    };
  });
};
const toTransactions = (opLogEntries, relations) => {
  if (opLogEntries.length === 0) {
    return [];
  }
  const to_commit_timestamp = (timestamp) => Long.UZERO.add(new Date(timestamp).getTime());
  const init = {
    commit_timestamp: to_commit_timestamp(opLogEntries[0].timestamp),
    lsn: numberToBytes(opLogEntries[0].rowid),
    changes: []
  };
  return opLogEntries.reduce(
    (acc, txn) => {
      let currTxn = acc[acc.length - 1];
      const nextTs = to_commit_timestamp(txn.timestamp);
      if (nextTs.notEquals(currTxn.commit_timestamp)) {
        const nextTxn = {
          commit_timestamp: to_commit_timestamp(txn.timestamp),
          lsn: numberToBytes(txn.rowid),
          changes: []
        };
        acc.push(nextTxn);
        currTxn = nextTxn;
      }
      const change = opLogEntryToChange(txn, relations);
      currTxn.changes.push(change);
      currTxn.lsn = numberToBytes(txn.rowid);
      return acc;
    },
    [init]
  );
};
const getShadowPrimaryKey = (oplogEntry) => {
  if ("primaryKey" in oplogEntry) {
    return oplogEntry.primaryKey;
  } else {
    return primaryKeyToStr(oplogEntry.primaryKeyCols);
  }
};
const encodeTags = (tags) => {
  return JSON.stringify(tags);
};
const decodeTags = (tags) => {
  return JSON.parse(tags);
};
const opLogEntryToChange = (entry, relations) => {
  const relation = relations[`${entry.tablename}`];
  let record, oldRecord;
  if (typeof entry.newRow === "string") {
    record = deserialiseRow(entry.newRow, relation);
  }
  if (typeof entry.oldRow === "string") {
    oldRecord = deserialiseRow(entry.oldRow, relation);
  }
  if (typeof relation === "undefined") {
    throw new Error(`Could not find relation for ${entry.tablename}`);
  }
  return {
    type: entry.optype,
    relation,
    record,
    oldRecord,
    tags: decodeTags(entry.clearTags)
  };
};
const primaryKeyToStr = (primaryKeyObj) => {
  const keys = Object.keys(primaryKeyObj).sort();
  const sortedObj = keys.reduce((obj, key) => {
    obj[key] = primaryKeyObj[key];
    return obj;
  }, {});
  return serialiseRow(sortedObj);
};
const generateTag = (instanceId, timestamp) => {
  const milliseconds = typeof timestamp === "number" ? timestamp : timestamp.getTime();
  return instanceId + "@" + milliseconds.toString();
};
export {
  OPTYPES,
  decodeTags,
  encodeTags,
  extractPK,
  fromTransaction,
  generateTag,
  getShadowPrimaryKey,
  localEntryToChanges,
  localOperationsToTableChanges,
  opLogEntryToChange,
  primaryKeyToStr,
  remoteEntryToChanges,
  remoteOperationsToTableChanges,
  shadowTagsDefault,
  stringToOpType,
  toTransactions
};
//# sourceMappingURL=oplog.js.map