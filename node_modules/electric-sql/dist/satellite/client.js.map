{"version":3,"sources":["../../src/satellite/client.ts"],"sourcesContent":["import throttle from 'lodash.throttle'\n\nimport {\n  SatAuthReq,\n  SatAuthResp,\n  SatErrorResp,\n  SatErrorResp_ErrorCode,\n  SatInStartReplicationReq,\n  SatInStartReplicationResp,\n  SatInStopReplicationReq,\n  SatInStopReplicationResp,\n  SatTransOp,\n  SatOpRow,\n  SatOpLog,\n  SatRelation,\n  SatRelationColumn,\n  SatSubsResp,\n  SatSubsReq,\n  SatSubsDataError,\n  SatSubsDataBegin,\n  SatSubsDataEnd,\n  SatShapeDataBegin,\n  SatShapeDataEnd,\n  SatUnsubsReq,\n  SatUnsubsResp,\n  SatUnsubsDataBegin,\n  SatUnsubsDataEnd,\n  Root,\n  RootClientImpl,\n  SatRpcRequest,\n  SatInStartReplicationReq_Dialect,\n} from '../_generated/protocol/satellite'\nimport {\n  getObjFromString,\n  getBufWithMsgTag,\n  getTypeFromCode,\n  SatPbMsg,\n  getFullTypeName,\n  startReplicationErrorToSatelliteError,\n  shapeRequestToSatShapeReq,\n  subsErrorToSatelliteError,\n  msgToString,\n  serverErrorToSatelliteError,\n  HandlerMapping,\n  RpcResponder,\n} from '../util/proto'\nimport { PROTOCOL_VSN, Socket, SocketFactory } from '../sockets/index'\nimport _m0 from 'protobufjs/minimal.js'\nimport {\n  AuthResponse,\n  DataChangeType,\n  LSN,\n  RelationColumn,\n  Replication,\n  ReplicationStatus,\n  SatelliteError,\n  SatelliteErrorCode,\n  DataTransaction,\n  DbRecord,\n  Relation,\n  SchemaChange,\n  StartReplicationResponse,\n  StopReplicationResponse,\n  ErrorCallback,\n  RelationCallback,\n  OutboundStartedCallback,\n  TransactionCallback,\n  ServerTransaction,\n  InboundReplication,\n  SocketCloseReason,\n  AdditionalData,\n  DataInsert,\n  AdditionalDataCallback,\n  DataChange,\n  isDataChange,\n  ReplicatedRowTransformer,\n  DataGone,\n  GoneBatchCallback,\n} from '../util/types'\nimport {\n  base64,\n  sqliteTypeEncoder,\n  sqliteTypeDecoder,\n  bytesToNumber,\n  TypeEncoder,\n  TypeDecoder,\n  pgTypeEncoder,\n  pgTypeDecoder,\n} from '../util/encoders'\nimport { DEFAULT_LOG_POS } from '../util/common'\nimport { Client } from '.'\nimport { SatelliteClientOpts, satelliteClientDefaults } from './config'\nimport Log from 'loglevel'\nimport isequal from 'lodash.isequal'\nimport {\n  SUBSCRIPTION_DELIVERED,\n  SUBSCRIPTION_ERROR,\n  ShapeRequest,\n  SubscribeResponse,\n  SubscriptionDeliveredCallback,\n  SubscriptionErrorCallback,\n  SubscriptionId,\n  UnsubscribeResponse,\n} from './shapes/types'\nimport { SubscriptionsDataCache } from './shapes/cache'\nimport { setMaskBit, getMaskBit } from '../util/bitmaskHelpers'\nimport { RPC, rpcRespond, withRpcRequestLogging } from './RPC'\nimport { Mutex } from 'async-mutex'\nimport { DbSchema } from '../client/model'\nimport { PgBasicType, PgDateType, PgType } from '../client/conversions/types'\nimport { AsyncEventEmitter, QualifiedTablename } from '../util'\nimport { AuthState } from '../auth'\nimport Long from 'long'\n\nconst DEFAULT_ACK_PERIOD = 60000\n\ntype IncomingHandler = (msg: any) => void\n\nconst subscriptionError = [\n  SatelliteErrorCode.UNEXPECTED_SUBSCRIPTION_STATE,\n  SatelliteErrorCode.SUBSCRIPTION_ERROR,\n  SatelliteErrorCode.SUBSCRIPTION_ALREADY_EXISTS,\n  SatelliteErrorCode.SUBSCRIPTION_ID_ALREADY_EXISTS,\n  SatelliteErrorCode.SUBSCRIPTION_NOT_FOUND,\n  SatelliteErrorCode.SHAPE_DELIVERY_ERROR,\n]\n\ntype Events = {\n  error: (error: SatelliteError) => void\n  relation: (relation: Relation) => void\n  transaction: (\n    transaction: ServerTransaction,\n    ackCb: () => void\n  ) => Promise<void>\n  additionalData: (data: AdditionalData, ack: () => void) => Promise<void>\n  outbound_started: () => void\n  [SUBSCRIPTION_DELIVERED]: SubscriptionDeliveredCallback\n  [SUBSCRIPTION_ERROR]: SubscriptionErrorCallback\n  goneBatch: (\n    lsn: LSN,\n    subscriptionIds: SubscriptionId[],\n    changes: DataGone[],\n    ack: () => void\n  ) => Promise<void>\n}\ntype EventEmitter = AsyncEventEmitter<Events>\n\nexport class SatelliteClient implements Client {\n  private opts: Required<SatelliteClientOpts>\n  private dialect: SatInStartReplicationReq_Dialect\n  private encoder: TypeEncoder\n  private decoder: TypeDecoder\n\n  private emitter: EventEmitter\n\n  private socketFactory: SocketFactory\n  private socket?: Socket\n\n  private inbound: InboundReplication\n  private outbound: Replication<DataTransaction>\n\n  // can only handle a single subscription at a time\n  private subscriptionsDataCache: SubscriptionsDataCache\n\n  private replicationTransforms: Map<\n    string,\n    ReplicatedRowTransformer<DbRecord>\n  > = new Map()\n\n  private socketHandler?: (any: any) => void\n  private throttledPushTransaction?: () => void\n\n  private rpcClient: RPC\n  private service: Root\n  private incomingMutex: Mutex = new Mutex()\n  private allowedMutexedRpcResponses: Array<keyof Root> = []\n\n  private dbDescription: DbSchema<any>\n  private isDown = false\n\n  private handlerForMessageType: { [k: string]: IncomingHandler } =\n    Object.fromEntries(\n      Object.entries({\n        SatRelation: (msg) => this.handleRelation(msg),\n        SatOpLog: (msg) => this.handleTransaction(msg),\n        SatErrorResp: (error) => this.handleError(error),\n        SatSubsDataError: (msg) => this.handleSubscriptionError(msg),\n        SatSubsDataBegin: (msg) => this.handleSubscriptionDataBegin(msg),\n        SatSubsDataEnd: (msg) => this.handleSubscriptionDataEnd(msg),\n        SatShapeDataBegin: (msg) => this.handleShapeDataBegin(msg),\n        SatShapeDataEnd: (msg) => this.handleShapeDataEnd(msg),\n        SatRpcResponse: (msg) => this.rpcClient.handleResponse(msg),\n        SatRpcRequest: (msg) => this.handleRpcRequest(msg),\n        SatOpLogAck: (msg) => void msg, // Server doesn't send that\n        SatUnsubsDataBegin: (msg) => this.handleUnsubsDataBegin(msg),\n        SatUnsubsDataEnd: (msg) => this.handleUnsubsDataEnd(msg),\n      } satisfies HandlerMapping).map((e) => [getFullTypeName(e[0]), e[1]])\n    )\n\n  private handlerForRpcRequests: RpcResponder = {\n    startReplication: this.handleStartReq.bind(this),\n    stopReplication: this.handleStopReq.bind(this),\n  }\n\n  /* eslint-disable-next-line @typescript-eslint/ban-types --\n   * This remapping actually is generic from a function to a function of the same type,\n   * but there's no way to express that. It's needed because we're wrapping the original\n   * callback in our own, which makes `.removeListener` not work.\n   */\n  private listenerRemapping: Map<Function, Function> = new Map()\n\n  constructor(\n    dbDescription: DbSchema<any>,\n    socketFactory: SocketFactory,\n    opts: SatelliteClientOpts\n  ) {\n    this.emitter = new AsyncEventEmitter<Events>()\n\n    this.opts = { ...satelliteClientDefaults, ...opts }\n    this.dialect =\n      opts.dialect === 'SQLite'\n        ? SatInStartReplicationReq_Dialect.SQLITE\n        : SatInStartReplicationReq_Dialect.POSTGRES\n    this.encoder = opts.dialect === 'SQLite' ? sqliteTypeEncoder : pgTypeEncoder\n    this.decoder = opts.dialect === 'SQLite' ? sqliteTypeDecoder : pgTypeDecoder\n    this.socketFactory = socketFactory\n\n    this.inbound = this.resetInboundReplication()\n    this.outbound = this.resetReplication()\n    this.dbDescription = dbDescription\n\n    this.subscriptionsDataCache = new SubscriptionsDataCache(\n      dbDescription,\n      this.decoder\n    )\n    this.rpcClient = new RPC(\n      this.sendMessage.bind(this),\n      this.opts.timeout,\n      Log\n    )\n\n    this.service = withRpcRequestLogging(\n      new RootClientImpl(this.rpcClient),\n      Log\n    )\n  }\n\n  private resetReplication<T = any>(\n    last_lsn?: LSN,\n    isReplicating?: ReplicationStatus\n  ): Replication<T> {\n    return {\n      authenticated: false,\n      isReplicating: isReplicating ? isReplicating : ReplicationStatus.STOPPED,\n      relations: new Map(),\n      last_lsn: last_lsn,\n      transactions: [],\n    }\n  }\n\n  private resetInboundReplication(\n    last_lsn?: LSN,\n    isReplicating?: ReplicationStatus\n  ): InboundReplication {\n    return {\n      ...this.resetReplication(last_lsn, isReplicating),\n      lastTxId: undefined,\n      lastAckedTxId: undefined,\n      unackedTxs: 0,\n      maxUnackedTxs: 30,\n      ackPeriod: DEFAULT_ACK_PERIOD,\n      ackTimer: setTimeout(\n        () => this.maybeSendAck('timeout'),\n        DEFAULT_ACK_PERIOD\n      ),\n      additionalData: [],\n      goneBatch: [],\n      receivingUnsubsBatch: false,\n      unseenAdditionalDataRefs: new Set(),\n      seenAdditionalDataSinceLastTx: {\n        dataRefs: [],\n        subscriptions: [],\n        gone: [],\n      },\n    }\n  }\n\n  connect(): Promise<void> {\n    if (this.isDown) {\n      throw new SatelliteError(\n        SatelliteErrorCode.UNEXPECTED_STATE,\n        'client has already shutdown'\n      )\n    }\n    if (this.isConnected()) {\n      this.disconnect()\n    }\n\n    return new Promise<void>((resolve, reject) => {\n      this.socket = new this.socketFactory(PROTOCOL_VSN)\n\n      const onceError = (error: Error) => {\n        this.disconnect()\n        reject(error)\n      }\n\n      const onceConnect = () => {\n        if (!this.socket)\n          throw new SatelliteError(\n            SatelliteErrorCode.UNEXPECTED_STATE,\n            'socket got unassigned somehow'\n          )\n\n        this.socket.removeErrorListener(onceError)\n        this.socketHandler = (message) => this.handleIncoming(message)\n\n        this.socket.onMessage(this.socketHandler)\n        this.socket.onError((error) => {\n          if (this.emitter.listenerCount('error') === 0) {\n            this.disconnect()\n            Log.error(\n              `socket error but no listener is attached: ${error.message}`\n            )\n          }\n          this.emitter.enqueueEmit('error', error)\n        })\n        this.socket.onClose((ev: SocketCloseReason) => {\n          this.disconnect()\n          if (this.emitter.listenerCount('error') === 0) {\n            Log.error(`socket closed but no listener is attached`)\n          }\n          this.emitter.enqueueEmit(\n            'error',\n            new SatelliteError(ev, 'socket closed')\n          )\n        })\n\n        resolve()\n      }\n\n      this.socket.onceError(onceError)\n      this.socket.onceConnect(onceConnect)\n\n      const { host, port, ssl } = this.opts\n      const url = `${ssl ? 'wss' : 'ws'}://${host}:${port}/ws`\n      this.socket.open({ url })\n    })\n  }\n\n  disconnect() {\n    this.outbound = this.resetReplication(this.outbound.last_lsn)\n    this.inbound = this.resetInboundReplication(this.inbound.last_lsn)\n\n    this.socketHandler = undefined\n\n    if (this.socket !== undefined) {\n      this.socket.closeAndRemoveListeners()\n      this.socket = undefined\n    }\n  }\n\n  isConnected(): boolean {\n    return !!this.socketHandler\n  }\n\n  getOutboundReplicationStatus(): ReplicationStatus {\n    return this.outbound.isReplicating\n  }\n\n  async shutdown(): Promise<void> {\n    this.emitter.removeAllListeners()\n    await this.emitter.waitForProcessing()\n    this.disconnect()\n    this.isDown = true\n  }\n\n  startReplication(\n    lsn?: LSN,\n    schemaVersion?: string,\n    subscriptionIds?: string[],\n    observedTransactionData?: Long[]\n  ): Promise<StartReplicationResponse> {\n    if (this.inbound.isReplicating !== ReplicationStatus.STOPPED) {\n      return Promise.reject(\n        new SatelliteError(\n          SatelliteErrorCode.REPLICATION_ALREADY_STARTED,\n          `replication already started`\n        )\n      )\n    }\n\n    // Perform validations and prepare the request\n    let request: SatInStartReplicationReq\n    if (!lsn || lsn.length === 0) {\n      Log.info(`no previous LSN, start replication from scratch`)\n      if (subscriptionIds && subscriptionIds.length > 0) {\n        return Promise.reject(\n          new SatelliteError(\n            SatelliteErrorCode.UNEXPECTED_SUBSCRIPTION_STATE,\n            `Cannot start replication with subscription IDs but without previous LSN.`\n          )\n        )\n      }\n      request = SatInStartReplicationReq.fromPartial({\n        schemaVersion,\n        sqlDialect: this.dialect,\n      })\n    } else {\n      Log.info(\n        `starting replication with lsn: ${base64.fromBytes(\n          lsn\n        )} subscriptions: ${subscriptionIds}`\n      )\n      request = SatInStartReplicationReq.fromPartial({\n        lsn,\n        subscriptionIds,\n        observedTransactionData,\n        sqlDialect: this.dialect,\n      })\n    }\n\n    // Then set the replication state\n    this.inbound = this.resetInboundReplication(lsn, ReplicationStatus.STARTING)\n\n    return this.delayIncomingMessages(\n      async () => {\n        const resp = await this.service.startReplication(request)\n        return this.handleStartResp(resp)\n      },\n      { allowedRpcResponses: ['startReplication'] }\n    )\n  }\n\n  stopReplication(): Promise<StopReplicationResponse> {\n    if (this.inbound.isReplicating !== ReplicationStatus.ACTIVE) {\n      return Promise.reject(\n        new SatelliteError(\n          SatelliteErrorCode.REPLICATION_NOT_STARTED,\n          `replication not active`\n        )\n      )\n    }\n\n    this.inbound.isReplicating = ReplicationStatus.STOPPING\n    const request = SatInStopReplicationReq.fromPartial({})\n    return this.service\n      .stopReplication(request)\n      .then(this.handleStopResp.bind(this))\n  }\n\n  authenticate({ clientId, token }: AuthState): Promise<AuthResponse> {\n    const request = SatAuthReq.fromPartial({\n      id: clientId,\n      token: token,\n      headers: [],\n    })\n    return this.service\n      .authenticate(request)\n      .then(this.handleAuthResp.bind(this))\n  }\n\n  subscribeToTransactions(callback: TransactionCallback) {\n    this.emitter.on('transaction', async (txn, ackCb) => {\n      await callback(txn)\n      ackCb()\n    })\n  }\n\n  unsubscribeToTransactions(callback: TransactionCallback) {\n    // TODO: This doesn't work because we're building a callback in the function above\n    this.emitter.removeListener('transaction', callback)\n  }\n\n  subscribeToAdditionalData(callback: AdditionalDataCallback) {\n    this.emitter.on('additionalData', async (data, ackCb) => {\n      await callback(data)\n      ackCb()\n    })\n  }\n\n  unsubscribeToAdditionalData(_callback: AdditionalDataCallback) {\n    // TODO: real removeListener implementation, because the old one for txns doesn't work\n  }\n\n  subscribeToRelations(callback: RelationCallback) {\n    this.emitter.on('relation', callback)\n  }\n\n  unsubscribeToRelations(callback: RelationCallback) {\n    this.emitter.removeListener('relation', callback)\n  }\n\n  subscribeToGoneBatch(callback: GoneBatchCallback) {\n    this.emitter.on('goneBatch', async (lsn, ids, changes, ack) => {\n      await callback(lsn, ids, changes)\n      ack()\n    })\n  }\n  unsubscribeToGoneBatch(_callback: GoneBatchCallback) {\n    // TODO: real removeListener implementation, because the old one for txns doesn't work\n  }\n\n  enqueueTransaction(transaction: DataTransaction): void {\n    if (this.outbound.isReplicating !== ReplicationStatus.ACTIVE) {\n      throw new SatelliteError(\n        SatelliteErrorCode.REPLICATION_NOT_STARTED,\n        'enqueuing a transaction while outbound replication has not started'\n      )\n    }\n\n    // apply any specified transforms to the data changes\n    transaction.changes = transaction.changes.map((dc) =>\n      this._applyDataChangeTransform(dc, 'outbound')\n    )\n\n    this.outbound.transactions.push(transaction)\n    this.outbound.last_lsn = transaction.lsn\n\n    this.throttledPushTransaction?.()\n  }\n\n  private pushTransactions() {\n    if (this.outbound.isReplicating !== ReplicationStatus.ACTIVE) {\n      throw new SatelliteError(\n        SatelliteErrorCode.REPLICATION_NOT_STARTED,\n        'sending a transaction while outbound replication has not started'\n      )\n    }\n\n    let next: DataTransaction | undefined\n    while ((next = this.outbound.transactions.shift())) {\n      // TODO: divide into SatOpLog array with max size\n      this.sendMissingRelations(next, this.outbound)\n      const satOpLog: SatOpLog = this.transactionToSatOpLog(next)\n\n      this.sendMessage(satOpLog)\n    }\n  }\n\n  subscribeToError(callback: ErrorCallback): void {\n    this.emitter.on('error', callback)\n  }\n\n  unsubscribeToError(callback: ErrorCallback): void {\n    this.emitter.removeListener('error', callback)\n  }\n\n  subscribeToOutboundStarted(callback: OutboundStartedCallback): void {\n    this.emitter.on('outbound_started', callback)\n  }\n\n  unsubscribeToOutboundStarted(callback: OutboundStartedCallback) {\n    this.emitter.removeListener('outbound_started', callback)\n  }\n\n  subscribeToSubscriptionEvents(\n    successCallback: SubscriptionDeliveredCallback,\n    errorCallback: SubscriptionErrorCallback\n  ): void {\n    const newCb: SubscriptionDeliveredCallback = async (data) => {\n      await successCallback(data)\n      this.inbound.seenAdditionalDataSinceLastTx.subscriptions.push(\n        data.subscriptionId\n      )\n      this.maybeSendAck('additionalData')\n    }\n\n    this.listenerRemapping.set(successCallback, newCb)\n\n    // We're remapping this callback to internal emitter to keep event queue correct -\n    // a delivered subscription processing should not interleave with next transaction processing\n    this.emitter.on(SUBSCRIPTION_DELIVERED, newCb)\n    this.subscriptionsDataCache.on(SUBSCRIPTION_DELIVERED, (data) =>\n      this.emitter.enqueueEmit(SUBSCRIPTION_DELIVERED, data)\n    )\n    this.emitter.on(SUBSCRIPTION_ERROR, errorCallback)\n    this.subscriptionsDataCache.on(SUBSCRIPTION_ERROR, (error) =>\n      this.emitter.enqueueEmit(SUBSCRIPTION_ERROR, error)\n    )\n  }\n\n  unsubscribeToSubscriptionEvents(\n    successCallback: SubscriptionDeliveredCallback,\n    errorCallback: SubscriptionErrorCallback\n  ): void {\n    this.emitter.removeListener(\n      SUBSCRIPTION_DELIVERED,\n      (this.listenerRemapping.get(successCallback) as any) || successCallback\n    )\n    this.emitter.removeListener(SUBSCRIPTION_ERROR, errorCallback)\n\n    this.subscriptionsDataCache.removeAllListeners(SUBSCRIPTION_DELIVERED)\n    this.subscriptionsDataCache.removeAllListeners(SUBSCRIPTION_ERROR)\n  }\n\n  async subscribe(\n    subscriptionId: string,\n    shapes: ShapeRequest[]\n  ): Promise<SubscribeResponse> {\n    if (this.inbound.isReplicating !== ReplicationStatus.ACTIVE) {\n      return Promise.reject(\n        new SatelliteError(\n          SatelliteErrorCode.REPLICATION_NOT_STARTED,\n          `replication not active`\n        )\n      )\n    }\n\n    const request = SatSubsReq.fromPartial({\n      subscriptionId,\n      shapeRequests: shapeRequestToSatShapeReq(shapes),\n    })\n\n    this.subscriptionsDataCache.subscriptionRequest(request)\n\n    return this.delayIncomingMessages(\n      async () => {\n        const resp = await this.service.subscribe(request)\n        return this.handleSubscription(resp)\n      },\n      { allowedRpcResponses: ['subscribe'] }\n    )\n  }\n\n  unsubscribe(subscriptionIds: string[]): Promise<UnsubscribeResponse> {\n    if (this.inbound.isReplicating !== ReplicationStatus.ACTIVE) {\n      return Promise.reject(\n        new SatelliteError(\n          SatelliteErrorCode.REPLICATION_NOT_STARTED,\n          `replication not active`\n        )\n      )\n    }\n\n    const request = SatUnsubsReq.create({ subscriptionIds })\n\n    return this.service\n      .unsubscribe(request)\n      .then(this.handleUnsubscribeResponse.bind(this))\n  }\n\n  private sendMissingRelations(\n    transaction: DataTransaction,\n    replication: Replication<DataTransaction>\n  ): void {\n    transaction.changes.forEach((change) => {\n      const relation = change.relation\n      if (\n        // this is a new relation\n        !this.outbound.relations.has(relation.id) ||\n        // or, the relation has changed\n        !isequal(this.outbound.relations.get(relation.id), relation)\n      ) {\n        replication.relations.set(relation.id, relation)\n\n        const satRelation = SatRelation.fromPartial({\n          relationId: relation.id,\n          schemaName: relation.schema, // TODO\n          tableName: relation.table,\n          tableType: relation.tableType,\n          columns: relation.columns.map((c) =>\n            SatRelationColumn.fromPartial({\n              name: c.name,\n              type: c.type,\n              isNullable: c.isNullable,\n            })\n          ),\n        })\n\n        this.sendMessage(satRelation)\n      }\n    })\n  }\n\n  private transactionToSatOpLog(transaction: DataTransaction): SatOpLog {\n    const ops: SatTransOp[] = [\n      SatTransOp.fromPartial({\n        begin: {\n          commitTimestamp: transaction.commit_timestamp.toString(),\n          lsn: transaction.lsn,\n        },\n      }),\n    ]\n\n    transaction.changes.forEach((change) => {\n      let changeOp, oldRecord, record\n      const relation = this.outbound.relations.get(change.relation.id)!\n      const tags = change.tags\n      if (change.oldRecord) {\n        oldRecord = serializeRow(\n          change.oldRecord,\n          relation,\n          this.dbDescription,\n          this.encoder\n        )\n      }\n      if (change.record) {\n        record = serializeRow(\n          change.record,\n          relation,\n          this.dbDescription,\n          this.encoder\n        )\n      }\n      switch (change.type) {\n        case DataChangeType.DELETE:\n          changeOp = SatTransOp.fromPartial({\n            delete: {\n              oldRowData: oldRecord,\n              relationId: relation.id,\n              tags: tags,\n            },\n          })\n          break\n        case DataChangeType.INSERT:\n          changeOp = SatTransOp.fromPartial({\n            insert: {\n              rowData: record,\n              relationId: relation.id,\n              tags: tags,\n            },\n          })\n          break\n        case DataChangeType.UPDATE:\n          changeOp = SatTransOp.fromPartial({\n            update: {\n              rowData: record,\n              oldRowData: oldRecord,\n              relationId: relation.id,\n              tags: tags,\n            },\n          })\n          break\n        case DataChangeType.COMPENSATION:\n          changeOp = SatTransOp.fromPartial({\n            compensation: {\n              pkData: record,\n              relationId: relation.id,\n              tags: tags,\n            },\n          })\n          break\n        case DataChangeType.GONE:\n          throw new SatelliteError(\n            SatelliteErrorCode.PROTOCOL_VIOLATION,\n            'Client is not expected to send GONE messages'\n          )\n      }\n      ops.push(changeOp)\n    })\n\n    ops.push(SatTransOp.fromPartial({ commit: {} }))\n    return SatOpLog.fromPartial({ ops })\n  }\n\n  private handleAuthResp(message: SatAuthResp | SatErrorResp): AuthResponse {\n    let error, serverId\n    if (message.$type === SatAuthResp.$type) {\n      serverId = message.id\n      this.inbound.authenticated = true\n    } else {\n      error = new SatelliteError(\n        SatelliteErrorCode.AUTH_ERROR,\n        `An internal error occurred during authentication`\n      )\n    }\n    return { serverId, error }\n  }\n\n  private handleStartResp(\n    resp: SatInStartReplicationResp\n  ): StartReplicationResponse {\n    if (this.inbound.isReplicating === ReplicationStatus.STARTING) {\n      if (resp.err) {\n        this.inbound.isReplicating = ReplicationStatus.STOPPED\n        return { error: startReplicationErrorToSatelliteError(resp.err) }\n      } else {\n        this.inbound.isReplicating = ReplicationStatus.ACTIVE\n        this.inbound.maxUnackedTxs = resp.unackedWindowSize ?? 30\n      }\n    } else {\n      return {\n        error: new SatelliteError(\n          SatelliteErrorCode.UNEXPECTED_STATE,\n          `unexpected state ${this.inbound.isReplicating} handling 'start' response`\n        ),\n      }\n    }\n    return {}\n  }\n\n  /**\n   * Server may issue RPC requests to the client, and we're handling them here.\n   */\n  private async handleRpcRequest(message: SatRpcRequest) {\n    const responder = rpcRespond(this.sendMessage.bind(this))\n\n    if (message.method === 'startReplication') {\n      const decoded = SatInStartReplicationReq.decode(message.message)\n      responder(\n        message,\n        await this.handlerForRpcRequests[message.method](decoded)\n      )\n    } else if (message.method === 'stopReplication') {\n      const decoded = SatInStopReplicationReq.decode(message.message)\n      responder(\n        message,\n        await this.handlerForRpcRequests[message.method](decoded)\n      )\n    } else {\n      Log.warn(\n        `Server has sent an RPC request with a method that the client does not support: ${message.method}`\n      )\n\n      responder(\n        message,\n        SatErrorResp.create({\n          errorType: SatErrorResp_ErrorCode.INVALID_REQUEST,\n        })\n      )\n    }\n  }\n\n  private async handleStartReq(\n    message: SatInStartReplicationReq\n  ): Promise<SatErrorResp | SatInStartReplicationResp> {\n    Log.info(\n      `Server sent a replication request to start from ${bytesToNumber(\n        message.lsn\n      )}, and options ${JSON.stringify(message.options)}`\n    )\n\n    if (this.outbound.isReplicating === ReplicationStatus.STOPPED) {\n      // Use server-sent LSN as the starting point for replication\n      this.outbound = this.resetReplication(\n        message.lsn,\n        ReplicationStatus.ACTIVE\n      )\n\n      this.throttledPushTransaction = throttle(\n        () => this.pushTransactions(),\n        this.opts.pushPeriod,\n        { leading: true, trailing: true }\n      )\n\n      this.emitter.enqueueEmit('outbound_started')\n      return SatInStartReplicationResp.create()\n    } else {\n      this.emitter.enqueueEmit(\n        'error',\n        new SatelliteError(\n          SatelliteErrorCode.UNEXPECTED_STATE,\n          `unexpected state ${this.outbound.isReplicating} handling 'start' request`\n        )\n      )\n      return SatErrorResp.create({\n        errorType: SatErrorResp_ErrorCode.REPLICATION_FAILED,\n      })\n    }\n  }\n\n  private async handleStopReq(\n    _message: SatInStopReplicationReq\n  ): Promise<SatErrorResp | SatInStopReplicationResp> {\n    if (this.outbound.isReplicating === ReplicationStatus.ACTIVE) {\n      this.outbound.isReplicating = ReplicationStatus.STOPPED\n\n      if (this.throttledPushTransaction) {\n        this.throttledPushTransaction = undefined\n      }\n\n      return SatInStopReplicationResp.create()\n    } else {\n      this.emitter.enqueueEmit(\n        'error',\n        new SatelliteError(\n          SatelliteErrorCode.UNEXPECTED_STATE,\n          `unexpected state ${this.inbound.isReplicating} handling 'stop' request`\n        )\n      )\n\n      return SatErrorResp.create({\n        errorType: SatErrorResp_ErrorCode.REPLICATION_FAILED,\n      })\n    }\n  }\n\n  private handleStopResp(): StopReplicationResponse {\n    if (this.inbound.isReplicating === ReplicationStatus.STOPPING) {\n      this.inbound.isReplicating = ReplicationStatus.STOPPED\n      return {}\n    }\n\n    return {\n      error: new SatelliteError(\n        SatelliteErrorCode.UNEXPECTED_STATE,\n        `unexpected state ${this.inbound.isReplicating} handling 'stop' response`\n      ),\n    }\n  }\n\n  private handleRelation(message: SatRelation) {\n    if (this.inbound.isReplicating !== ReplicationStatus.ACTIVE) {\n      this.emitter.enqueueEmit(\n        'error',\n        new SatelliteError(\n          SatelliteErrorCode.UNEXPECTED_STATE,\n          `unexpected state ${\n            ReplicationStatus[this.inbound.isReplicating]\n          } handling 'relation' message`\n        )\n      )\n      return\n    }\n\n    /* TODO: This makes a generally incorrect assumption that PK columns come in order in the relation\n             It works in most cases, but we need actual PK order information on the protocol\n             for multi-col PKs to work */\n    let pkPosition = 1\n\n    const relation = {\n      id: message.relationId,\n      schema: message.schemaName,\n      table: message.tableName,\n      tableType: message.tableType,\n      columns: message.columns.map((c) => ({\n        name: c.name,\n        type: c.type,\n        isNullable: c.isNullable,\n        primaryKey: c.primaryKey ? pkPosition++ : undefined,\n      })),\n    } satisfies Relation\n\n    this.inbound.relations.set(relation.id, relation)\n    this.emitter.enqueueEmit('relation', relation)\n  }\n\n  private handleTransaction(message: SatOpLog) {\n    if (this.inbound.receivingUnsubsBatch) {\n      this.processUnsubsDataMessage(message)\n    } else if (this.subscriptionsDataCache.isDelivering()) {\n      try {\n        this.subscriptionsDataCache.transaction(message.ops)\n      } catch (e) {\n        Log.info(\n          `Error applying transaction message for subs ${JSON.stringify(e)}`\n        )\n      }\n    } else {\n      this.processOpLogMessage(message)\n    }\n  }\n\n  private handleError(error: SatErrorResp) {\n    this.emitter.enqueueEmit('error', serverErrorToSatelliteError(error))\n  }\n\n  private handleSubscription(msg: SatSubsResp): SubscribeResponse {\n    if (msg.err) {\n      const error = subsErrorToSatelliteError(msg.err)\n      this.subscriptionsDataCache.subscriptionError(msg.subscriptionId)\n      return { subscriptionId: msg.subscriptionId, error }\n    } else {\n      this.subscriptionsDataCache.subscriptionResponse(msg)\n      return { subscriptionId: msg.subscriptionId }\n    }\n  }\n\n  private handleSubscriptionError(msg: SatSubsDataError): void {\n    this.subscriptionsDataCache.subscriptionDataError(msg.subscriptionId, msg)\n  }\n\n  private handleSubscriptionDataBegin(msg: SatSubsDataBegin): void {\n    this.subscriptionsDataCache.subscriptionDataBegin(msg)\n  }\n\n  private handleSubscriptionDataEnd(_msg: SatSubsDataEnd): void {\n    this.subscriptionsDataCache.subscriptionDataEnd(this.inbound.relations)\n  }\n\n  private handleShapeDataBegin(msg: SatShapeDataBegin): void {\n    this.subscriptionsDataCache.shapeDataBegin(msg)\n  }\n\n  private handleShapeDataEnd(_msg: SatShapeDataEnd): void {\n    this.subscriptionsDataCache.shapeDataEnd()\n  }\n\n  // For now, unsubscribe responses doesn't send any information back\n  // It might eventually confirm that the server processed it or was noop.\n  private handleUnsubscribeResponse(_msg: SatUnsubsResp): UnsubscribeResponse {\n    return {}\n  }\n\n  private handleUnsubsDataBegin(msg: SatUnsubsDataBegin): void {\n    this.inbound.receivingUnsubsBatch = msg.subscriptionIds\n    this.inbound.last_lsn = msg.lsn\n  }\n\n  private handleUnsubsDataEnd(_msg: SatUnsubsDataEnd): void {\n    if (!this.inbound.receivingUnsubsBatch)\n      throw new SatelliteError(\n        SatelliteErrorCode.PROTOCOL_VIOLATION,\n        'Received a `SatUnsubsDataEnd` message but not the begin message'\n      )\n\n    // We need to copy the value here so that the callback we're building 8 lines down\n    // will make a closure over array value instead of over `this` and will use current\n    // value instead of whatever is the value of `this.inbound.receivingUnsubsBatch` in\n    // the future.\n    const subscriptionIds = [...this.inbound.receivingUnsubsBatch]\n\n    this.emitter.enqueueEmit(\n      'goneBatch',\n      this.inbound.last_lsn!,\n      subscriptionIds,\n      this.inbound.goneBatch,\n      () => {\n        this.inbound.seenAdditionalDataSinceLastTx.gone.push(...subscriptionIds)\n        this.maybeSendAck('additionalData')\n      }\n    )\n\n    this.inbound.receivingUnsubsBatch = false\n    this.inbound.goneBatch = []\n  }\n\n  private delayIncomingMessages<T>(\n    fn: () => Promise<T>,\n    opts: { allowedRpcResponses: Array<keyof Root> }\n  ): Promise<T> {\n    return this.incomingMutex.runExclusive(async () => {\n      this.allowedMutexedRpcResponses = opts.allowedRpcResponses\n      try {\n        return await fn()\n      } finally {\n        this.allowedMutexedRpcResponses = []\n      }\n    })\n  }\n\n  // TODO: properly handle socket errors; update connectivity state\n  private async handleIncoming(data: Buffer) {\n    try {\n      const message = toMessage(data)\n\n      if (\n        this.incomingMutex.isLocked() &&\n        !(\n          message.$type === 'Electric.Satellite.SatRpcResponse' &&\n          this.allowedMutexedRpcResponses.includes(message.method as keyof Root)\n        )\n      ) {\n        await this.incomingMutex.waitForUnlock()\n      }\n\n      if (Log.getLevel() <= 1) {\n        Log.debug(`[proto] recv: ${msgToString(message)}`)\n      }\n      this.handlerForMessageType[message.$type]?.(message)\n    } catch (error) {\n      if (error instanceof SatelliteError) {\n        // subscription errors are emitted through specific event\n        if (!subscriptionError.includes(error.code)) {\n          this.emitter.enqueueEmit('error', error)\n        }\n      } else {\n        // This is an unexpected runtime error\n        throw error\n      }\n    }\n  }\n\n  private getRelation({ relationId }: { relationId: number }): Relation {\n    const rel = this.inbound.relations.get(relationId)\n    if (!rel) {\n      throw new SatelliteError(\n        SatelliteErrorCode.PROTOCOL_VIOLATION,\n        `missing relation ${relationId} for incoming operation`\n      )\n    }\n    return rel\n  }\n\n  private processUnsubsDataMessage(msg: SatOpLog): void {\n    msg.ops.forEach((op) => {\n      if (!op.gone)\n        throw new SatelliteError(\n          SatelliteErrorCode.PROTOCOL_VIOLATION,\n          'Expected to see only GONE messages in unsubscription data'\n        )\n\n      const rel = this.getRelation(op.gone)\n      this.inbound.goneBatch.push({\n        relation: rel,\n        type: DataChangeType.GONE,\n        oldRecord: deserializeRow(\n          op.gone.pkData!,\n          rel,\n          this.dbDescription,\n          this.decoder\n        ),\n        tags: [],\n      })\n    })\n  }\n\n  private processOpLogMessage(opLogMessage: SatOpLog): void {\n    const replication = this.inbound\n    opLogMessage.ops.map((op) => {\n      if (op.begin) {\n        const transaction: ServerTransaction = {\n          commit_timestamp: op.begin.commitTimestamp,\n          lsn: op.begin.lsn,\n          changes: [],\n          origin: op.begin.origin!,\n          id: op.begin.transactionId!,\n        }\n        replication.incomplete = 'transaction'\n        replication.transactions.push(transaction)\n      }\n\n      if (op.additionalBegin) {\n        replication.incomplete = 'additionalData'\n        replication.additionalData.push({\n          ref: op.additionalBegin.ref,\n          changes: [],\n        })\n      }\n\n      const lastTxnIdx = replication.transactions.length - 1\n      const lastDataIdx = replication.additionalData.length - 1\n      if (op.commit) {\n        if (replication.incomplete !== 'transaction')\n          throw new Error('Unexpected commit message while not waiting for txn')\n\n        const { commit_timestamp, lsn, changes, origin, migrationVersion, id } =\n          replication.transactions[lastTxnIdx]\n\n        // apply any specified transforms to the data changes\n        const transformedChanges = changes.map((change) => {\n          if (!isDataChange(change)) return change\n          return this._applyDataChangeTransform(change, 'inbound')\n        })\n\n        const transaction: ServerTransaction = {\n          commit_timestamp,\n          lsn,\n          changes: transformedChanges,\n          origin,\n          migrationVersion,\n          id,\n          additionalDataRef: op.commit.additionalDataRef.isZero()\n            ? undefined\n            : op.commit.additionalDataRef,\n        }\n        this.emitter.enqueueEmit('transaction', transaction, () => {\n          this.inbound.last_lsn = transaction.lsn\n          this.inbound.lastTxId = transaction.id\n          this.inbound.unackedTxs++\n          this.inbound.seenAdditionalDataSinceLastTx = {\n            dataRefs: [],\n            subscriptions: [],\n            gone: [],\n          }\n          this.maybeSendAck()\n        })\n        replication.transactions.splice(lastTxnIdx)\n        replication.incomplete = undefined\n        if (!op.commit.additionalDataRef.isZero())\n          replication.unseenAdditionalDataRefs.add(\n            op.commit.additionalDataRef.toString()\n          )\n      }\n\n      if (op.additionalCommit) {\n        if (replication.incomplete !== 'additionalData')\n          throw new Error(\n            'Unexpected additionalCommit message while not waiting for additionalData'\n          )\n        const ref = op.additionalCommit!.ref\n\n        // TODO: We need to include these in the ACKs as well\n        this.emitter.enqueueEmit(\n          'additionalData',\n          replication.additionalData[lastDataIdx],\n          () => {\n            this.inbound.seenAdditionalDataSinceLastTx.dataRefs.push(ref)\n            this.maybeSendAck('additionalData')\n          }\n        )\n        replication.additionalData.splice(lastDataIdx)\n        replication.incomplete = undefined\n        replication.unseenAdditionalDataRefs.delete(ref.toString())\n      }\n\n      if (op.insert) {\n        const rel = this.getRelation(op.insert)\n\n        const change: DataInsert = {\n          relation: rel,\n          type: DataChangeType.INSERT,\n          record: deserializeRow(\n            op.insert.rowData!,\n            rel,\n            this.dbDescription,\n            this.decoder\n          ),\n          tags: op.insert.tags,\n        }\n\n        if (replication.incomplete! === 'transaction') {\n          replication.transactions[lastTxnIdx].changes.push(change)\n        } else {\n          replication.additionalData[lastDataIdx].changes.push(change)\n        }\n      }\n\n      if (op.update) {\n        const rel = this.getRelation(op.update)\n\n        const change = {\n          relation: rel,\n          type: DataChangeType.UPDATE,\n          record: deserializeRow(\n            op.update.rowData!,\n            rel,\n            this.dbDescription,\n            this.decoder\n          ),\n          oldRecord: deserializeRow(\n            op.update.oldRowData,\n            rel,\n            this.dbDescription,\n            this.decoder\n          ),\n          tags: op.update.tags,\n        }\n\n        replication.transactions[lastTxnIdx].changes.push(change)\n      }\n\n      if (op.delete) {\n        const rel = this.getRelation(op.delete)\n\n        const change = {\n          relation: rel,\n          type: DataChangeType.DELETE,\n          oldRecord: deserializeRow(\n            op.delete.oldRowData!,\n            rel,\n            this.dbDescription,\n            this.decoder\n          ),\n          tags: op.delete.tags,\n        }\n\n        replication.transactions[lastTxnIdx].changes.push(change)\n      }\n\n      if (op.gone) {\n        const rel = this.getRelation(op.gone)\n\n        const change = {\n          relation: rel,\n          type: DataChangeType.GONE,\n          oldRecord: deserializeRow(\n            op.gone.pkData,\n            rel,\n            this.dbDescription,\n            this.decoder\n          ),\n          tags: [],\n        }\n\n        replication.transactions[lastTxnIdx].changes.push(change)\n      }\n\n      if (op.migrate) {\n        // store the version of this migration transaction\n        // (within 1 transaction, every SatOpMigrate message\n        //  has the same version number)\n        // TODO: in the protocol: move the `version` field to the SatOpBegin message\n        //       or replace the `is_migration` field by an optional `version` field\n        //       --> see issue VAX-718 on linear.\n        const tx = replication.transactions[lastTxnIdx]\n        tx.migrationVersion = op.migrate.version\n\n        const stmts = op.migrate.stmts\n        stmts.forEach((stmt) => {\n          const change: SchemaChange = {\n            table: op.migrate!.table!,\n            migrationType: stmt.type,\n            sql: stmt.sql,\n          }\n          tx.changes.push(change)\n        })\n      }\n    })\n  }\n\n  private sendMessage<T extends SatPbMsg>(request: T) {\n    if (Log.getLevel() <= 1) Log.debug(`[proto] send: ${msgToString(request)}`)\n    if (!this.socket || !this.isConnected()) {\n      throw new SatelliteError(\n        SatelliteErrorCode.UNEXPECTED_STATE,\n        'trying to send message, but client is closed'\n      )\n    }\n    const obj = getObjFromString(request.$type)\n    if (obj === undefined) {\n      throw new SatelliteError(\n        SatelliteErrorCode.UNEXPECTED_MESSAGE_TYPE,\n        `${request.$type})`\n      )\n    }\n\n    const type = getBufWithMsgTag(request)\n    const msg = obj.encode(request, _m0.Writer.create()).finish()\n    const buffer = new Uint8Array(type.length + msg.length)\n    buffer.set(type, 0)\n    buffer.set(msg, 1)\n\n    this.socket.write(buffer)\n  }\n\n  getLastSentLsn(): LSN {\n    return this.outbound.last_lsn ?? DEFAULT_LOG_POS\n  }\n\n  private maybeSendAck(reason?: 'timeout' | 'additionalData') {\n    // Restart the timer regardless\n    if (reason === 'timeout')\n      this.inbound.ackTimer = setTimeout(\n        () => this.maybeSendAck('timeout'),\n        this.inbound.ackPeriod\n      )\n\n    // Cannot ack while offline\n    if (!this.socket || !this.isConnected()) return\n    // or when there's nothing to be ack'd\n    if (this.inbound.lastTxId === undefined) return\n    // Shouldn't ack the same message\n    if (this.inbound.lastAckedTxId?.eq(this.inbound.lastTxId)) return\n\n    // Send acks earlier rather than later to keep the stream continuous -\n    // definitely send at 70% of allowed lag.\n    const boundary = Math.floor(this.inbound.maxUnackedTxs * 0.7)\n\n    // Send the ack if we're over the boundary, or wait to ack until the timer runs\n    // out to avoid making more traffic than required, but we always try to ack on additional data\n    if (\n      this.inbound.unackedTxs >= boundary ||\n      reason === 'timeout' ||\n      reason === 'additionalData'\n    ) {\n      const msg: SatPbMsg = {\n        $type: 'Electric.Satellite.SatOpLogAck',\n        ackTimestamp: Long.UZERO.add(new Date().getTime()),\n        lsn: this.inbound.last_lsn!,\n        transactionId: this.inbound.lastTxId,\n        subscriptionIds:\n          this.inbound.seenAdditionalDataSinceLastTx.subscriptions,\n        additionalDataSourceIds:\n          this.inbound.seenAdditionalDataSinceLastTx.dataRefs,\n        goneSubscriptionIds: this.inbound.seenAdditionalDataSinceLastTx.gone,\n      }\n\n      this.sendMessage(msg)\n      this.inbound.lastAckedTxId = msg.transactionId\n    }\n  }\n\n  public setReplicationTransform(\n    tableName: QualifiedTablename,\n    transform: ReplicatedRowTransformer<DbRecord>\n  ): void {\n    this.replicationTransforms.set(tableName.tablename, transform)\n  }\n\n  public clearReplicationTransform(tableName: QualifiedTablename): void {\n    this.replicationTransforms.delete(tableName.tablename)\n  }\n\n  private _applyDataChangeTransform(\n    dataChange: DataChange,\n    dataFlow: 'inbound' | 'outbound'\n  ): DataChange {\n    const transforms = this.replicationTransforms.get(dataChange.relation.table)\n    if (!transforms) return dataChange\n    const transformToUse =\n      dataFlow === 'inbound'\n        ? transforms.transformInbound\n        : transforms.transformOutbound\n    try {\n      return {\n        ...dataChange,\n        record: dataChange.record && transformToUse(dataChange.record),\n        oldRecord: dataChange.oldRecord && transformToUse(dataChange.oldRecord),\n      }\n    } catch (err: any) {\n      throw new SatelliteError(\n        SatelliteErrorCode.REPLICATION_TRANSFORM_ERROR,\n        err.message\n      )\n    }\n  }\n}\n\n/**\n * Fetches the PG type of the given column in the given table.\n * @param dbDescription Database description object\n * @param table Name of the table\n * @param column Name of the column\n * @returns The PG type of the column\n */\nfunction getColumnType(\n  dbDescription: DbSchema<any>,\n  table: string,\n  column: RelationColumn\n): PgType {\n  if (\n    dbDescription.hasTable(table) &&\n    dbDescription.getFields(table).has(column.name)\n  ) {\n    // The table and column are known in the DB description\n    return dbDescription.getFields(table).get(column.name)!\n  } else {\n    // The table or column is not known.\n    // There must have been a migration that added it to the DB while the app was running.\n    // i.e., it was not known at the time the Electric client for this app was generated\n    //       so it is not present in the bundled DB description.\n    // Thus, we return the column type that is stored in the relation.\n    // Note that it is fine to fetch the column type from the relation\n    // because it was received at runtime and thus will have the PG type\n    // (which would not be the case for bundled relations fetched\n    //  from the endpoint because the endpoint maps PG types to SQLite types).\n    return column.type.toUpperCase() as PgType\n  }\n}\n\nexport function serializeRow(\n  rec: DbRecord,\n  relation: Relation,\n  dbDescription: DbSchema<any>,\n  encoder: TypeEncoder\n): SatOpRow {\n  let recordNumColumn = 0\n  const recordNullBitMask = new Uint8Array(\n    calculateNumBytes(relation.columns.length)\n  )\n  const recordValues = relation!.columns.reduce(\n    (acc: Uint8Array[], c: RelationColumn) => {\n      const columnValue = rec[c.name]\n      if (columnValue !== null && columnValue !== undefined) {\n        const pgColumnType = getColumnType(dbDescription, relation.table, c)\n        acc.push(serializeColumnData(columnValue, pgColumnType, encoder))\n      } else {\n        acc.push(serializeNullData())\n        setMaskBit(recordNullBitMask, recordNumColumn)\n      }\n      recordNumColumn = recordNumColumn + 1\n      return acc\n    },\n    []\n  )\n  return SatOpRow.fromPartial({\n    nullsBitmask: recordNullBitMask,\n    values: recordValues,\n  })\n}\n\nexport function deserializeRow(\n  row: SatOpRow,\n  relation: Relation,\n  dbDescription: DbSchema<any>,\n  decoder: TypeDecoder\n): DbRecord\nexport function deserializeRow(\n  row: SatOpRow | undefined,\n  relation: Relation,\n  dbDescription: DbSchema<any>,\n  decoder: TypeDecoder\n): DbRecord | undefined\nexport function deserializeRow(\n  row: SatOpRow | undefined,\n  relation: Relation,\n  dbDescription: DbSchema<any>,\n  decoder: TypeDecoder\n): DbRecord | undefined {\n  if (row === undefined) {\n    return undefined\n  }\n  return relation.columns.reduce((deserializedRow, c, i) => {\n    if (getMaskBit(row.nullsBitmask, i) === 1) {\n      deserializedRow[c.name] = null\n    } else {\n      const pgColumnType = getColumnType(dbDescription, relation.table, c)\n      deserializedRow[c.name] = deserializeColumnData(\n        row.values[i],\n        pgColumnType,\n        decoder\n      )\n    }\n    return deserializedRow\n  }, {} as DbRecord)\n}\n\nfunction calculateNumBytes(column_num: number): number {\n  const rem = column_num % 8\n  if (rem === 0) {\n    return column_num / 8\n  } else {\n    return 1 + (column_num - rem) / 8\n  }\n}\n\nfunction deserializeColumnData(\n  column: Uint8Array,\n  columnType: PgType,\n  decoder: TypeDecoder\n): boolean | string | number | Uint8Array {\n  switch (columnType) {\n    case PgBasicType.PG_BOOL:\n      return decoder.bool(column)\n    case PgBasicType.PG_INT:\n    case PgBasicType.PG_INT2:\n    case PgBasicType.PG_INT4:\n    case PgBasicType.PG_INTEGER:\n      return Number(decoder.text(column))\n    case PgBasicType.PG_FLOAT4:\n    case PgBasicType.PG_FLOAT8:\n    case PgBasicType.PG_REAL:\n      return decoder.float(column)\n    case PgDateType.PG_TIMETZ:\n      return decoder.timetz(column)\n    case PgBasicType.PG_BYTEA:\n      return decoder.bytea(column)\n    case PgBasicType.PG_JSON:\n    case PgBasicType.PG_JSONB:\n      return decoder.json(column)\n    default:\n      // also covers user-defined enumeration types\n      return decoder.text(column)\n  }\n}\n\n// All values serialized as textual representation\nfunction serializeColumnData(\n  columnValue: boolean | string | number | object,\n  columnType: PgType,\n  encoder: TypeEncoder\n): Uint8Array {\n  switch (columnType) {\n    case PgBasicType.PG_BOOL:\n      return (encoder.bool as any)(columnValue) // the encoder accepts the number or bool\n    case PgDateType.PG_TIMETZ:\n      return encoder.timetz(columnValue as string)\n    case PgBasicType.PG_BYTEA:\n      return encoder.bytea(columnValue as Uint8Array)\n    case PgBasicType.PG_JSON:\n    case PgBasicType.PG_JSONB:\n      return (encoder.json as any)(columnValue)\n    default:\n      return encoder.text(String(columnValue))\n  }\n}\n\nfunction serializeNullData(): Uint8Array {\n  return new Uint8Array()\n}\n\nexport function toMessage(data: Uint8Array): SatPbMsg {\n  const code = data[0]\n  const type = getTypeFromCode(code)\n  const obj = getObjFromString(type)\n  if (obj === undefined) {\n    throw new SatelliteError(\n      SatelliteErrorCode.UNEXPECTED_MESSAGE_TYPE,\n      `${code})`\n    )\n  }\n  return obj.decode(data.subarray(1))\n}\n"],"mappings":"AAAA,OAAO,cAAc;AAErB;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEA;AAAA,EAMA;AAAA,EAKA;AAAA,EAEA;AAAA,OACK;AACP;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OAGK;AACP,SAAS,oBAA2C;AACpD,OAAO,SAAS;AAChB;AAAA,EAEE;AAAA,EAIA;AAAA,EACA;AAAA,EACA;AAAA,EAkBA;AAAA,OAIK;AACP;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAGA;AAAA,EACA;AAAA,OACK;AACP,SAAS,uBAAuB;AAEhC,SAA8B,+BAA+B;AAC7D,OAAO,SAAS;AAChB,OAAO,aAAa;AACpB;AAAA,EACE;AAAA,EACA;AAAA,OAOK;AACP,SAAS,8BAA8B;AACvC,SAAS,YAAY,kBAAkB;AACvC,SAAS,KAAK,YAAY,6BAA6B;AACvD,SAAS,aAAa;AAEtB,SAAS,aAAa,kBAA0B;AAChD,SAAS,yBAA6C;AAEtD,OAAO,UAAU;AAEjB,MAAM,qBAAqB;AAI3B,MAAM,oBAAoB;AAAA,EACxB,mBAAmB;AAAA,EACnB,mBAAmB;AAAA,EACnB,mBAAmB;AAAA,EACnB,mBAAmB;AAAA,EACnB,mBAAmB;AAAA,EACnB,mBAAmB;AACrB;AAsBO,MAAM,gBAAkC;AAAA,EACrC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEA;AAAA,EAEA;AAAA,EACA;AAAA,EAEA;AAAA,EACA;AAAA;AAAA,EAGA;AAAA,EAEA,wBAGJ,oBAAI,IAAI;AAAA,EAEJ;AAAA,EACA;AAAA,EAEA;AAAA,EACA;AAAA,EACA,gBAAuB,IAAI,MAAM;AAAA,EACjC,6BAAgD,CAAC;AAAA,EAEjD;AAAA,EACA,SAAS;AAAA,EAET,wBACN,OAAO;AAAA,IACL,OAAO,QAAQ;AAAA,MACb,aAAa,CAAC,QAAQ,KAAK,eAAe,GAAG;AAAA,MAC7C,UAAU,CAAC,QAAQ,KAAK,kBAAkB,GAAG;AAAA,MAC7C,cAAc,CAAC,UAAU,KAAK,YAAY,KAAK;AAAA,MAC/C,kBAAkB,CAAC,QAAQ,KAAK,wBAAwB,GAAG;AAAA,MAC3D,kBAAkB,CAAC,QAAQ,KAAK,4BAA4B,GAAG;AAAA,MAC/D,gBAAgB,CAAC,QAAQ,KAAK,0BAA0B,GAAG;AAAA,MAC3D,mBAAmB,CAAC,QAAQ,KAAK,qBAAqB,GAAG;AAAA,MACzD,iBAAiB,CAAC,QAAQ,KAAK,mBAAmB,GAAG;AAAA,MACrD,gBAAgB,CAAC,QAAQ,KAAK,UAAU,eAAe,GAAG;AAAA,MAC1D,eAAe,CAAC,QAAQ,KAAK,iBAAiB,GAAG;AAAA,MACjD,aAAa,CAAC,QAAQ;AAAA;AAAA,MACtB,oBAAoB,CAAC,QAAQ,KAAK,sBAAsB,GAAG;AAAA,MAC3D,kBAAkB,CAAC,QAAQ,KAAK,oBAAoB,GAAG;AAAA,IACzD,CAA0B,EAAE,IAAI,CAAC,MAAM,CAAC,gBAAgB,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;AAAA,EACtE;AAAA,EAEM,wBAAsC;AAAA,IAC5C,kBAAkB,KAAK,eAAe,KAAK,IAAI;AAAA,IAC/C,iBAAiB,KAAK,cAAc,KAAK,IAAI;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,oBAA6C,oBAAI,IAAI;AAAA,EAE7D,YACE,eACA,eACA,MACA;AACA,SAAK,UAAU,IAAI,kBAA0B;AAE7C,SAAK,OAAO,EAAE,GAAG,yBAAyB,GAAG,KAAK;AAClD,SAAK,UACH,KAAK,YAAY,WACb,iCAAiC,SACjC,iCAAiC;AACvC,SAAK,UAAU,KAAK,YAAY,WAAW,oBAAoB;AAC/D,SAAK,UAAU,KAAK,YAAY,WAAW,oBAAoB;AAC/D,SAAK,gBAAgB;AAErB,SAAK,UAAU,KAAK,wBAAwB;AAC5C,SAAK,WAAW,KAAK,iBAAiB;AACtC,SAAK,gBAAgB;AAErB,SAAK,yBAAyB,IAAI;AAAA,MAChC;AAAA,MACA,KAAK;AAAA,IACP;AACA,SAAK,YAAY,IAAI;AAAA,MACnB,KAAK,YAAY,KAAK,IAAI;AAAA,MAC1B,KAAK,KAAK;AAAA,MACV;AAAA,IACF;AAEA,SAAK,UAAU;AAAA,MACb,IAAI,eAAe,KAAK,SAAS;AAAA,MACjC;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,iBACN,UACA,eACgB;AAChB,WAAO;AAAA,MACL,eAAe;AAAA,MACf,eAAe,gBAAgB,gBAAgB,kBAAkB;AAAA,MACjE,WAAW,oBAAI,IAAI;AAAA,MACnB;AAAA,MACA,cAAc,CAAC;AAAA,IACjB;AAAA,EACF;AAAA,EAEQ,wBACN,UACA,eACoB;AACpB,WAAO;AAAA,MACL,GAAG,KAAK,iBAAiB,UAAU,aAAa;AAAA,MAChD,UAAU;AAAA,MACV,eAAe;AAAA,MACf,YAAY;AAAA,MACZ,eAAe;AAAA,MACf,WAAW;AAAA,MACX,UAAU;AAAA,QACR,MAAM,KAAK,aAAa,SAAS;AAAA,QACjC;AAAA,MACF;AAAA,MACA,gBAAgB,CAAC;AAAA,MACjB,WAAW,CAAC;AAAA,MACZ,sBAAsB;AAAA,MACtB,0BAA0B,oBAAI,IAAI;AAAA,MAClC,+BAA+B;AAAA,QAC7B,UAAU,CAAC;AAAA,QACX,eAAe,CAAC;AAAA,QAChB,MAAM,CAAC;AAAA,MACT;AAAA,IACF;AAAA,EACF;AAAA,EAEA,UAAyB;AACvB,QAAI,KAAK,QAAQ;AACf,YAAM,IAAI;AAAA,QACR,mBAAmB;AAAA,QACnB;AAAA,MACF;AAAA,IACF;AACA,QAAI,KAAK,YAAY,GAAG;AACtB,WAAK,WAAW;AAAA,IAClB;AAEA,WAAO,IAAI,QAAc,CAAC,SAAS,WAAW;AAC5C,WAAK,SAAS,IAAI,KAAK,cAAc,YAAY;AAEjD,YAAM,YAAY,CAAC,UAAiB;AAClC,aAAK,WAAW;AAChB,eAAO,KAAK;AAAA,MACd;AAEA,YAAM,cAAc,MAAM;AACxB,YAAI,CAAC,KAAK;AACR,gBAAM,IAAI;AAAA,YACR,mBAAmB;AAAA,YACnB;AAAA,UACF;AAEF,aAAK,OAAO,oBAAoB,SAAS;AACzC,aAAK,gBAAgB,CAAC,YAAY,KAAK,eAAe,OAAO;AAE7D,aAAK,OAAO,UAAU,KAAK,aAAa;AACxC,aAAK,OAAO,QAAQ,CAAC,UAAU;AAC7B,cAAI,KAAK,QAAQ,cAAc,OAAO,MAAM,GAAG;AAC7C,iBAAK,WAAW;AAChB,gBAAI;AAAA,cACF,6CAA6C,MAAM,OAAO;AAAA,YAC5D;AAAA,UACF;AACA,eAAK,QAAQ,YAAY,SAAS,KAAK;AAAA,QACzC,CAAC;AACD,aAAK,OAAO,QAAQ,CAAC,OAA0B;AAC7C,eAAK,WAAW;AAChB,cAAI,KAAK,QAAQ,cAAc,OAAO,MAAM,GAAG;AAC7C,gBAAI,MAAM,2CAA2C;AAAA,UACvD;AACA,eAAK,QAAQ;AAAA,YACX;AAAA,YACA,IAAI,eAAe,IAAI,eAAe;AAAA,UACxC;AAAA,QACF,CAAC;AAED,gBAAQ;AAAA,MACV;AAEA,WAAK,OAAO,UAAU,SAAS;AAC/B,WAAK,OAAO,YAAY,WAAW;AAEnC,YAAM,EAAE,MAAM,MAAM,IAAI,IAAI,KAAK;AACjC,YAAM,MAAM,GAAG,MAAM,QAAQ,IAAI,MAAM,IAAI,IAAI,IAAI;AACnD,WAAK,OAAO,KAAK,EAAE,IAAI,CAAC;AAAA,IAC1B,CAAC;AAAA,EACH;AAAA,EAEA,aAAa;AACX,SAAK,WAAW,KAAK,iBAAiB,KAAK,SAAS,QAAQ;AAC5D,SAAK,UAAU,KAAK,wBAAwB,KAAK,QAAQ,QAAQ;AAEjE,SAAK,gBAAgB;AAErB,QAAI,KAAK,WAAW,QAAW;AAC7B,WAAK,OAAO,wBAAwB;AACpC,WAAK,SAAS;AAAA,IAChB;AAAA,EACF;AAAA,EAEA,cAAuB;AACrB,WAAO,CAAC,CAAC,KAAK;AAAA,EAChB;AAAA,EAEA,+BAAkD;AAChD,WAAO,KAAK,SAAS;AAAA,EACvB;AAAA,EAEA,MAAM,WAA0B;AAC9B,SAAK,QAAQ,mBAAmB;AAChC,UAAM,KAAK,QAAQ,kBAAkB;AACrC,SAAK,WAAW;AAChB,SAAK,SAAS;AAAA,EAChB;AAAA,EAEA,iBACE,KACA,eACA,iBACA,yBACmC;AACnC,QAAI,KAAK,QAAQ,kBAAkB,kBAAkB,SAAS;AAC5D,aAAO,QAAQ;AAAA,QACb,IAAI;AAAA,UACF,mBAAmB;AAAA,UACnB;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAGA,QAAI;AACJ,QAAI,CAAC,OAAO,IAAI,WAAW,GAAG;AAC5B,UAAI,KAAK,iDAAiD;AAC1D,UAAI,mBAAmB,gBAAgB,SAAS,GAAG;AACjD,eAAO,QAAQ;AAAA,UACb,IAAI;AAAA,YACF,mBAAmB;AAAA,YACnB;AAAA,UACF;AAAA,QACF;AAAA,MACF;AACA,gBAAU,yBAAyB,YAAY;AAAA,QAC7C;AAAA,QACA,YAAY,KAAK;AAAA,MACnB,CAAC;AAAA,IACH,OAAO;AACL,UAAI;AAAA,QACF,kCAAkC,OAAO;AAAA,UACvC;AAAA,QACF,CAAC,mBAAmB,eAAe;AAAA,MACrC;AACA,gBAAU,yBAAyB,YAAY;AAAA,QAC7C;AAAA,QACA;AAAA,QACA;AAAA,QACA,YAAY,KAAK;AAAA,MACnB,CAAC;AAAA,IACH;AAGA,SAAK,UAAU,KAAK,wBAAwB,KAAK,kBAAkB,QAAQ;AAE3E,WAAO,KAAK;AAAA,MACV,YAAY;AACV,cAAM,OAAO,MAAM,KAAK,QAAQ,iBAAiB,OAAO;AACxD,eAAO,KAAK,gBAAgB,IAAI;AAAA,MAClC;AAAA,MACA,EAAE,qBAAqB,CAAC,kBAAkB,EAAE;AAAA,IAC9C;AAAA,EACF;AAAA,EAEA,kBAAoD;AAClD,QAAI,KAAK,QAAQ,kBAAkB,kBAAkB,QAAQ;AAC3D,aAAO,QAAQ;AAAA,QACb,IAAI;AAAA,UACF,mBAAmB;AAAA,UACnB;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,SAAK,QAAQ,gBAAgB,kBAAkB;AAC/C,UAAM,UAAU,wBAAwB,YAAY,CAAC,CAAC;AACtD,WAAO,KAAK,QACT,gBAAgB,OAAO,EACvB,KAAK,KAAK,eAAe,KAAK,IAAI,CAAC;AAAA,EACxC;AAAA,EAEA,aAAa,EAAE,UAAU,MAAM,GAAqC;AAClE,UAAM,UAAU,WAAW,YAAY;AAAA,MACrC,IAAI;AAAA,MACJ;AAAA,MACA,SAAS,CAAC;AAAA,IACZ,CAAC;AACD,WAAO,KAAK,QACT,aAAa,OAAO,EACpB,KAAK,KAAK,eAAe,KAAK,IAAI,CAAC;AAAA,EACxC;AAAA,EAEA,wBAAwB,UAA+B;AACrD,SAAK,QAAQ,GAAG,eAAe,OAAO,KAAK,UAAU;AACnD,YAAM,SAAS,GAAG;AAClB,YAAM;AAAA,IACR,CAAC;AAAA,EACH;AAAA,EAEA,0BAA0B,UAA+B;AAEvD,SAAK,QAAQ,eAAe,eAAe,QAAQ;AAAA,EACrD;AAAA,EAEA,0BAA0B,UAAkC;AAC1D,SAAK,QAAQ,GAAG,kBAAkB,OAAO,MAAM,UAAU;AACvD,YAAM,SAAS,IAAI;AACnB,YAAM;AAAA,IACR,CAAC;AAAA,EACH;AAAA,EAEA,4BAA4B,WAAmC;AAAA,EAE/D;AAAA,EAEA,qBAAqB,UAA4B;AAC/C,SAAK,QAAQ,GAAG,YAAY,QAAQ;AAAA,EACtC;AAAA,EAEA,uBAAuB,UAA4B;AACjD,SAAK,QAAQ,eAAe,YAAY,QAAQ;AAAA,EAClD;AAAA,EAEA,qBAAqB,UAA6B;AAChD,SAAK,QAAQ,GAAG,aAAa,OAAO,KAAK,KAAK,SAAS,QAAQ;AAC7D,YAAM,SAAS,KAAK,KAAK,OAAO;AAChC,UAAI;AAAA,IACN,CAAC;AAAA,EACH;AAAA,EACA,uBAAuB,WAA8B;AAAA,EAErD;AAAA,EAEA,mBAAmB,aAAoC;AACrD,QAAI,KAAK,SAAS,kBAAkB,kBAAkB,QAAQ;AAC5D,YAAM,IAAI;AAAA,QACR,mBAAmB;AAAA,QACnB;AAAA,MACF;AAAA,IACF;AAGA,gBAAY,UAAU,YAAY,QAAQ;AAAA,MAAI,CAAC,OAC7C,KAAK,0BAA0B,IAAI,UAAU;AAAA,IAC/C;AAEA,SAAK,SAAS,aAAa,KAAK,WAAW;AAC3C,SAAK,SAAS,WAAW,YAAY;AAErC,SAAK,2BAA2B;AAAA,EAClC;AAAA,EAEQ,mBAAmB;AACzB,QAAI,KAAK,SAAS,kBAAkB,kBAAkB,QAAQ;AAC5D,YAAM,IAAI;AAAA,QACR,mBAAmB;AAAA,QACnB;AAAA,MACF;AAAA,IACF;AAEA,QAAI;AACJ,WAAQ,OAAO,KAAK,SAAS,aAAa,MAAM,GAAI;AAElD,WAAK,qBAAqB,MAAM,KAAK,QAAQ;AAC7C,YAAM,WAAqB,KAAK,sBAAsB,IAAI;AAE1D,WAAK,YAAY,QAAQ;AAAA,IAC3B;AAAA,EACF;AAAA,EAEA,iBAAiB,UAA+B;AAC9C,SAAK,QAAQ,GAAG,SAAS,QAAQ;AAAA,EACnC;AAAA,EAEA,mBAAmB,UAA+B;AAChD,SAAK,QAAQ,eAAe,SAAS,QAAQ;AAAA,EAC/C;AAAA,EAEA,2BAA2B,UAAyC;AAClE,SAAK,QAAQ,GAAG,oBAAoB,QAAQ;AAAA,EAC9C;AAAA,EAEA,6BAA6B,UAAmC;AAC9D,SAAK,QAAQ,eAAe,oBAAoB,QAAQ;AAAA,EAC1D;AAAA,EAEA,8BACE,iBACA,eACM;AACN,UAAM,QAAuC,OAAO,SAAS;AAC3D,YAAM,gBAAgB,IAAI;AAC1B,WAAK,QAAQ,8BAA8B,cAAc;AAAA,QACvD,KAAK;AAAA,MACP;AACA,WAAK,aAAa,gBAAgB;AAAA,IACpC;AAEA,SAAK,kBAAkB,IAAI,iBAAiB,KAAK;AAIjD,SAAK,QAAQ,GAAG,wBAAwB,KAAK;AAC7C,SAAK,uBAAuB;AAAA,MAAG;AAAA,MAAwB,CAAC,SACtD,KAAK,QAAQ,YAAY,wBAAwB,IAAI;AAAA,IACvD;AACA,SAAK,QAAQ,GAAG,oBAAoB,aAAa;AACjD,SAAK,uBAAuB;AAAA,MAAG;AAAA,MAAoB,CAAC,UAClD,KAAK,QAAQ,YAAY,oBAAoB,KAAK;AAAA,IACpD;AAAA,EACF;AAAA,EAEA,gCACE,iBACA,eACM;AACN,SAAK,QAAQ;AAAA,MACX;AAAA,MACC,KAAK,kBAAkB,IAAI,eAAe,KAAa;AAAA,IAC1D;AACA,SAAK,QAAQ,eAAe,oBAAoB,aAAa;AAE7D,SAAK,uBAAuB,mBAAmB,sBAAsB;AACrE,SAAK,uBAAuB,mBAAmB,kBAAkB;AAAA,EACnE;AAAA,EAEA,MAAM,UACJ,gBACA,QAC4B;AAC5B,QAAI,KAAK,QAAQ,kBAAkB,kBAAkB,QAAQ;AAC3D,aAAO,QAAQ;AAAA,QACb,IAAI;AAAA,UACF,mBAAmB;AAAA,UACnB;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,UAAM,UAAU,WAAW,YAAY;AAAA,MACrC;AAAA,MACA,eAAe,0BAA0B,MAAM;AAAA,IACjD,CAAC;AAED,SAAK,uBAAuB,oBAAoB,OAAO;AAEvD,WAAO,KAAK;AAAA,MACV,YAAY;AACV,cAAM,OAAO,MAAM,KAAK,QAAQ,UAAU,OAAO;AACjD,eAAO,KAAK,mBAAmB,IAAI;AAAA,MACrC;AAAA,MACA,EAAE,qBAAqB,CAAC,WAAW,EAAE;AAAA,IACvC;AAAA,EACF;AAAA,EAEA,YAAY,iBAAyD;AACnE,QAAI,KAAK,QAAQ,kBAAkB,kBAAkB,QAAQ;AAC3D,aAAO,QAAQ;AAAA,QACb,IAAI;AAAA,UACF,mBAAmB;AAAA,UACnB;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,UAAM,UAAU,aAAa,OAAO,EAAE,gBAAgB,CAAC;AAEvD,WAAO,KAAK,QACT,YAAY,OAAO,EACnB,KAAK,KAAK,0BAA0B,KAAK,IAAI,CAAC;AAAA,EACnD;AAAA,EAEQ,qBACN,aACA,aACM;AACN,gBAAY,QAAQ,QAAQ,CAAC,WAAW;AACtC,YAAM,WAAW,OAAO;AACxB;AAAA;AAAA,QAEE,CAAC,KAAK,SAAS,UAAU,IAAI,SAAS,EAAE;AAAA,QAExC,CAAC,QAAQ,KAAK,SAAS,UAAU,IAAI,SAAS,EAAE,GAAG,QAAQ;AAAA,QAC3D;AACA,oBAAY,UAAU,IAAI,SAAS,IAAI,QAAQ;AAE/C,cAAM,cAAc,YAAY,YAAY;AAAA,UAC1C,YAAY,SAAS;AAAA,UACrB,YAAY,SAAS;AAAA;AAAA,UACrB,WAAW,SAAS;AAAA,UACpB,WAAW,SAAS;AAAA,UACpB,SAAS,SAAS,QAAQ;AAAA,YAAI,CAAC,MAC7B,kBAAkB,YAAY;AAAA,cAC5B,MAAM,EAAE;AAAA,cACR,MAAM,EAAE;AAAA,cACR,YAAY,EAAE;AAAA,YAChB,CAAC;AAAA,UACH;AAAA,QACF,CAAC;AAED,aAAK,YAAY,WAAW;AAAA,MAC9B;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEQ,sBAAsB,aAAwC;AACpE,UAAM,MAAoB;AAAA,MACxB,WAAW,YAAY;AAAA,QACrB,OAAO;AAAA,UACL,iBAAiB,YAAY,iBAAiB,SAAS;AAAA,UACvD,KAAK,YAAY;AAAA,QACnB;AAAA,MACF,CAAC;AAAA,IACH;AAEA,gBAAY,QAAQ,QAAQ,CAAC,WAAW;AACtC,UAAI,UAAU,WAAW;AACzB,YAAM,WAAW,KAAK,SAAS,UAAU,IAAI,OAAO,SAAS,EAAE;AAC/D,YAAM,OAAO,OAAO;AACpB,UAAI,OAAO,WAAW;AACpB,oBAAY;AAAA,UACV,OAAO;AAAA,UACP;AAAA,UACA,KAAK;AAAA,UACL,KAAK;AAAA,QACP;AAAA,MACF;AACA,UAAI,OAAO,QAAQ;AACjB,iBAAS;AAAA,UACP,OAAO;AAAA,UACP;AAAA,UACA,KAAK;AAAA,UACL,KAAK;AAAA,QACP;AAAA,MACF;AACA,cAAQ,OAAO,MAAM;AAAA,QACnB,KAAK,eAAe;AAClB,qBAAW,WAAW,YAAY;AAAA,YAChC,QAAQ;AAAA,cACN,YAAY;AAAA,cACZ,YAAY,SAAS;AAAA,cACrB;AAAA,YACF;AAAA,UACF,CAAC;AACD;AAAA,QACF,KAAK,eAAe;AAClB,qBAAW,WAAW,YAAY;AAAA,YAChC,QAAQ;AAAA,cACN,SAAS;AAAA,cACT,YAAY,SAAS;AAAA,cACrB;AAAA,YACF;AAAA,UACF,CAAC;AACD;AAAA,QACF,KAAK,eAAe;AAClB,qBAAW,WAAW,YAAY;AAAA,YAChC,QAAQ;AAAA,cACN,SAAS;AAAA,cACT,YAAY;AAAA,cACZ,YAAY,SAAS;AAAA,cACrB;AAAA,YACF;AAAA,UACF,CAAC;AACD;AAAA,QACF,KAAK,eAAe;AAClB,qBAAW,WAAW,YAAY;AAAA,YAChC,cAAc;AAAA,cACZ,QAAQ;AAAA,cACR,YAAY,SAAS;AAAA,cACrB;AAAA,YACF;AAAA,UACF,CAAC;AACD;AAAA,QACF,KAAK,eAAe;AAClB,gBAAM,IAAI;AAAA,YACR,mBAAmB;AAAA,YACnB;AAAA,UACF;AAAA,MACJ;AACA,UAAI,KAAK,QAAQ;AAAA,IACnB,CAAC;AAED,QAAI,KAAK,WAAW,YAAY,EAAE,QAAQ,CAAC,EAAE,CAAC,CAAC;AAC/C,WAAO,SAAS,YAAY,EAAE,IAAI,CAAC;AAAA,EACrC;AAAA,EAEQ,eAAe,SAAmD;AACxE,QAAI,OAAO;AACX,QAAI,QAAQ,UAAU,YAAY,OAAO;AACvC,iBAAW,QAAQ;AACnB,WAAK,QAAQ,gBAAgB;AAAA,IAC/B,OAAO;AACL,cAAQ,IAAI;AAAA,QACV,mBAAmB;AAAA,QACnB;AAAA,MACF;AAAA,IACF;AACA,WAAO,EAAE,UAAU,MAAM;AAAA,EAC3B;AAAA,EAEQ,gBACN,MAC0B;AAC1B,QAAI,KAAK,QAAQ,kBAAkB,kBAAkB,UAAU;AAC7D,UAAI,KAAK,KAAK;AACZ,aAAK,QAAQ,gBAAgB,kBAAkB;AAC/C,eAAO,EAAE,OAAO,sCAAsC,KAAK,GAAG,EAAE;AAAA,MAClE,OAAO;AACL,aAAK,QAAQ,gBAAgB,kBAAkB;AAC/C,aAAK,QAAQ,gBAAgB,KAAK,qBAAqB;AAAA,MACzD;AAAA,IACF,OAAO;AACL,aAAO;AAAA,QACL,OAAO,IAAI;AAAA,UACT,mBAAmB;AAAA,UACnB,oBAAoB,KAAK,QAAQ,aAAa;AAAA,QAChD;AAAA,MACF;AAAA,IACF;AACA,WAAO,CAAC;AAAA,EACV;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,iBAAiB,SAAwB;AACrD,UAAM,YAAY,WAAW,KAAK,YAAY,KAAK,IAAI,CAAC;AAExD,QAAI,QAAQ,WAAW,oBAAoB;AACzC,YAAM,UAAU,yBAAyB,OAAO,QAAQ,OAAO;AAC/D;AAAA,QACE;AAAA,QACA,MAAM,KAAK,sBAAsB,QAAQ,MAAM,EAAE,OAAO;AAAA,MAC1D;AAAA,IACF,WAAW,QAAQ,WAAW,mBAAmB;AAC/C,YAAM,UAAU,wBAAwB,OAAO,QAAQ,OAAO;AAC9D;AAAA,QACE;AAAA,QACA,MAAM,KAAK,sBAAsB,QAAQ,MAAM,EAAE,OAAO;AAAA,MAC1D;AAAA,IACF,OAAO;AACL,UAAI;AAAA,QACF,kFAAkF,QAAQ,MAAM;AAAA,MAClG;AAEA;AAAA,QACE;AAAA,QACA,aAAa,OAAO;AAAA,UAClB,WAAW,uBAAuB;AAAA,QACpC,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAAA,EAEA,MAAc,eACZ,SACmD;AACnD,QAAI;AAAA,MACF,mDAAmD;AAAA,QACjD,QAAQ;AAAA,MACV,CAAC,iBAAiB,KAAK,UAAU,QAAQ,OAAO,CAAC;AAAA,IACnD;AAEA,QAAI,KAAK,SAAS,kBAAkB,kBAAkB,SAAS;AAE7D,WAAK,WAAW,KAAK;AAAA,QACnB,QAAQ;AAAA,QACR,kBAAkB;AAAA,MACpB;AAEA,WAAK,2BAA2B;AAAA,QAC9B,MAAM,KAAK,iBAAiB;AAAA,QAC5B,KAAK,KAAK;AAAA,QACV,EAAE,SAAS,MAAM,UAAU,KAAK;AAAA,MAClC;AAEA,WAAK,QAAQ,YAAY,kBAAkB;AAC3C,aAAO,0BAA0B,OAAO;AAAA,IAC1C,OAAO;AACL,WAAK,QAAQ;AAAA,QACX;AAAA,QACA,IAAI;AAAA,UACF,mBAAmB;AAAA,UACnB,oBAAoB,KAAK,SAAS,aAAa;AAAA,QACjD;AAAA,MACF;AACA,aAAO,aAAa,OAAO;AAAA,QACzB,WAAW,uBAAuB;AAAA,MACpC,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EAEA,MAAc,cACZ,UACkD;AAClD,QAAI,KAAK,SAAS,kBAAkB,kBAAkB,QAAQ;AAC5D,WAAK,SAAS,gBAAgB,kBAAkB;AAEhD,UAAI,KAAK,0BAA0B;AACjC,aAAK,2BAA2B;AAAA,MAClC;AAEA,aAAO,yBAAyB,OAAO;AAAA,IACzC,OAAO;AACL,WAAK,QAAQ;AAAA,QACX;AAAA,QACA,IAAI;AAAA,UACF,mBAAmB;AAAA,UACnB,oBAAoB,KAAK,QAAQ,aAAa;AAAA,QAChD;AAAA,MACF;AAEA,aAAO,aAAa,OAAO;AAAA,QACzB,WAAW,uBAAuB;AAAA,MACpC,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EAEQ,iBAA0C;AAChD,QAAI,KAAK,QAAQ,kBAAkB,kBAAkB,UAAU;AAC7D,WAAK,QAAQ,gBAAgB,kBAAkB;AAC/C,aAAO,CAAC;AAAA,IACV;AAEA,WAAO;AAAA,MACL,OAAO,IAAI;AAAA,QACT,mBAAmB;AAAA,QACnB,oBAAoB,KAAK,QAAQ,aAAa;AAAA,MAChD;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,eAAe,SAAsB;AAC3C,QAAI,KAAK,QAAQ,kBAAkB,kBAAkB,QAAQ;AAC3D,WAAK,QAAQ;AAAA,QACX;AAAA,QACA,IAAI;AAAA,UACF,mBAAmB;AAAA,UACnB,oBACE,kBAAkB,KAAK,QAAQ,aAAa,CAC9C;AAAA,QACF;AAAA,MACF;AACA;AAAA,IACF;AAKA,QAAI,aAAa;AAEjB,UAAM,WAAW;AAAA,MACf,IAAI,QAAQ;AAAA,MACZ,QAAQ,QAAQ;AAAA,MAChB,OAAO,QAAQ;AAAA,MACf,WAAW,QAAQ;AAAA,MACnB,SAAS,QAAQ,QAAQ,IAAI,CAAC,OAAO;AAAA,QACnC,MAAM,EAAE;AAAA,QACR,MAAM,EAAE;AAAA,QACR,YAAY,EAAE;AAAA,QACd,YAAY,EAAE,aAAa,eAAe;AAAA,MAC5C,EAAE;AAAA,IACJ;AAEA,SAAK,QAAQ,UAAU,IAAI,SAAS,IAAI,QAAQ;AAChD,SAAK,QAAQ,YAAY,YAAY,QAAQ;AAAA,EAC/C;AAAA,EAEQ,kBAAkB,SAAmB;AAC3C,QAAI,KAAK,QAAQ,sBAAsB;AACrC,WAAK,yBAAyB,OAAO;AAAA,IACvC,WAAW,KAAK,uBAAuB,aAAa,GAAG;AACrD,UAAI;AACF,aAAK,uBAAuB,YAAY,QAAQ,GAAG;AAAA,MACrD,SAAS,GAAG;AACV,YAAI;AAAA,UACF,+CAA+C,KAAK,UAAU,CAAC,CAAC;AAAA,QAClE;AAAA,MACF;AAAA,IACF,OAAO;AACL,WAAK,oBAAoB,OAAO;AAAA,IAClC;AAAA,EACF;AAAA,EAEQ,YAAY,OAAqB;AACvC,SAAK,QAAQ,YAAY,SAAS,4BAA4B,KAAK,CAAC;AAAA,EACtE;AAAA,EAEQ,mBAAmB,KAAqC;AAC9D,QAAI,IAAI,KAAK;AACX,YAAM,QAAQ,0BAA0B,IAAI,GAAG;AAC/C,WAAK,uBAAuB,kBAAkB,IAAI,cAAc;AAChE,aAAO,EAAE,gBAAgB,IAAI,gBAAgB,MAAM;AAAA,IACrD,OAAO;AACL,WAAK,uBAAuB,qBAAqB,GAAG;AACpD,aAAO,EAAE,gBAAgB,IAAI,eAAe;AAAA,IAC9C;AAAA,EACF;AAAA,EAEQ,wBAAwB,KAA6B;AAC3D,SAAK,uBAAuB,sBAAsB,IAAI,gBAAgB,GAAG;AAAA,EAC3E;AAAA,EAEQ,4BAA4B,KAA6B;AAC/D,SAAK,uBAAuB,sBAAsB,GAAG;AAAA,EACvD;AAAA,EAEQ,0BAA0B,MAA4B;AAC5D,SAAK,uBAAuB,oBAAoB,KAAK,QAAQ,SAAS;AAAA,EACxE;AAAA,EAEQ,qBAAqB,KAA8B;AACzD,SAAK,uBAAuB,eAAe,GAAG;AAAA,EAChD;AAAA,EAEQ,mBAAmB,MAA6B;AACtD,SAAK,uBAAuB,aAAa;AAAA,EAC3C;AAAA;AAAA;AAAA,EAIQ,0BAA0B,MAA0C;AAC1E,WAAO,CAAC;AAAA,EACV;AAAA,EAEQ,sBAAsB,KAA+B;AAC3D,SAAK,QAAQ,uBAAuB,IAAI;AACxC,SAAK,QAAQ,WAAW,IAAI;AAAA,EAC9B;AAAA,EAEQ,oBAAoB,MAA8B;AACxD,QAAI,CAAC,KAAK,QAAQ;AAChB,YAAM,IAAI;AAAA,QACR,mBAAmB;AAAA,QACnB;AAAA,MACF;AAMF,UAAM,kBAAkB,CAAC,GAAG,KAAK,QAAQ,oBAAoB;AAE7D,SAAK,QAAQ;AAAA,MACX;AAAA,MACA,KAAK,QAAQ;AAAA,MACb;AAAA,MACA,KAAK,QAAQ;AAAA,MACb,MAAM;AACJ,aAAK,QAAQ,8BAA8B,KAAK,KAAK,GAAG,eAAe;AACvE,aAAK,aAAa,gBAAgB;AAAA,MACpC;AAAA,IACF;AAEA,SAAK,QAAQ,uBAAuB;AACpC,SAAK,QAAQ,YAAY,CAAC;AAAA,EAC5B;AAAA,EAEQ,sBACN,IACA,MACY;AACZ,WAAO,KAAK,cAAc,aAAa,YAAY;AACjD,WAAK,6BAA6B,KAAK;AACvC,UAAI;AACF,eAAO,MAAM,GAAG;AAAA,MAClB,UAAE;AACA,aAAK,6BAA6B,CAAC;AAAA,MACrC;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA,EAGA,MAAc,eAAe,MAAc;AACzC,QAAI;AACF,YAAM,UAAU,UAAU,IAAI;AAE9B,UACE,KAAK,cAAc,SAAS,KAC5B,EACE,QAAQ,UAAU,uCAClB,KAAK,2BAA2B,SAAS,QAAQ,MAAoB,IAEvE;AACA,cAAM,KAAK,cAAc,cAAc;AAAA,MACzC;AAEA,UAAI,IAAI,SAAS,KAAK,GAAG;AACvB,YAAI,MAAM,iBAAiB,YAAY,OAAO,CAAC,EAAE;AAAA,MACnD;AACA,WAAK,sBAAsB,QAAQ,KAAK,IAAI,OAAO;AAAA,IACrD,SAAS,OAAO;AACd,UAAI,iBAAiB,gBAAgB;AAEnC,YAAI,CAAC,kBAAkB,SAAS,MAAM,IAAI,GAAG;AAC3C,eAAK,QAAQ,YAAY,SAAS,KAAK;AAAA,QACzC;AAAA,MACF,OAAO;AAEL,cAAM;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,YAAY,EAAE,WAAW,GAAqC;AACpE,UAAM,MAAM,KAAK,QAAQ,UAAU,IAAI,UAAU;AACjD,QAAI,CAAC,KAAK;AACR,YAAM,IAAI;AAAA,QACR,mBAAmB;AAAA,QACnB,oBAAoB,UAAU;AAAA,MAChC;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EAEQ,yBAAyB,KAAqB;AACpD,QAAI,IAAI,QAAQ,CAAC,OAAO;AACtB,UAAI,CAAC,GAAG;AACN,cAAM,IAAI;AAAA,UACR,mBAAmB;AAAA,UACnB;AAAA,QACF;AAEF,YAAM,MAAM,KAAK,YAAY,GAAG,IAAI;AACpC,WAAK,QAAQ,UAAU,KAAK;AAAA,QAC1B,UAAU;AAAA,QACV,MAAM,eAAe;AAAA,QACrB,WAAW;AAAA,UACT,GAAG,KAAK;AAAA,UACR;AAAA,UACA,KAAK;AAAA,UACL,KAAK;AAAA,QACP;AAAA,QACA,MAAM,CAAC;AAAA,MACT,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEQ,oBAAoB,cAA8B;AACxD,UAAM,cAAc,KAAK;AACzB,iBAAa,IAAI,IAAI,CAAC,OAAO;AAC3B,UAAI,GAAG,OAAO;AACZ,cAAM,cAAiC;AAAA,UACrC,kBAAkB,GAAG,MAAM;AAAA,UAC3B,KAAK,GAAG,MAAM;AAAA,UACd,SAAS,CAAC;AAAA,UACV,QAAQ,GAAG,MAAM;AAAA,UACjB,IAAI,GAAG,MAAM;AAAA,QACf;AACA,oBAAY,aAAa;AACzB,oBAAY,aAAa,KAAK,WAAW;AAAA,MAC3C;AAEA,UAAI,GAAG,iBAAiB;AACtB,oBAAY,aAAa;AACzB,oBAAY,eAAe,KAAK;AAAA,UAC9B,KAAK,GAAG,gBAAgB;AAAA,UACxB,SAAS,CAAC;AAAA,QACZ,CAAC;AAAA,MACH;AAEA,YAAM,aAAa,YAAY,aAAa,SAAS;AACrD,YAAM,cAAc,YAAY,eAAe,SAAS;AACxD,UAAI,GAAG,QAAQ;AACb,YAAI,YAAY,eAAe;AAC7B,gBAAM,IAAI,MAAM,qDAAqD;AAEvE,cAAM,EAAE,kBAAkB,KAAK,SAAS,QAAQ,kBAAkB,GAAG,IACnE,YAAY,aAAa,UAAU;AAGrC,cAAM,qBAAqB,QAAQ,IAAI,CAAC,WAAW;AACjD,cAAI,CAAC,aAAa,MAAM;AAAG,mBAAO;AAClC,iBAAO,KAAK,0BAA0B,QAAQ,SAAS;AAAA,QACzD,CAAC;AAED,cAAM,cAAiC;AAAA,UACrC;AAAA,UACA;AAAA,UACA,SAAS;AAAA,UACT;AAAA,UACA;AAAA,UACA;AAAA,UACA,mBAAmB,GAAG,OAAO,kBAAkB,OAAO,IAClD,SACA,GAAG,OAAO;AAAA,QAChB;AACA,aAAK,QAAQ,YAAY,eAAe,aAAa,MAAM;AACzD,eAAK,QAAQ,WAAW,YAAY;AACpC,eAAK,QAAQ,WAAW,YAAY;AACpC,eAAK,QAAQ;AACb,eAAK,QAAQ,gCAAgC;AAAA,YAC3C,UAAU,CAAC;AAAA,YACX,eAAe,CAAC;AAAA,YAChB,MAAM,CAAC;AAAA,UACT;AACA,eAAK,aAAa;AAAA,QACpB,CAAC;AACD,oBAAY,aAAa,OAAO,UAAU;AAC1C,oBAAY,aAAa;AACzB,YAAI,CAAC,GAAG,OAAO,kBAAkB,OAAO;AACtC,sBAAY,yBAAyB;AAAA,YACnC,GAAG,OAAO,kBAAkB,SAAS;AAAA,UACvC;AAAA,MACJ;AAEA,UAAI,GAAG,kBAAkB;AACvB,YAAI,YAAY,eAAe;AAC7B,gBAAM,IAAI;AAAA,YACR;AAAA,UACF;AACF,cAAM,MAAM,GAAG,iBAAkB;AAGjC,aAAK,QAAQ;AAAA,UACX;AAAA,UACA,YAAY,eAAe,WAAW;AAAA,UACtC,MAAM;AACJ,iBAAK,QAAQ,8BAA8B,SAAS,KAAK,GAAG;AAC5D,iBAAK,aAAa,gBAAgB;AAAA,UACpC;AAAA,QACF;AACA,oBAAY,eAAe,OAAO,WAAW;AAC7C,oBAAY,aAAa;AACzB,oBAAY,yBAAyB,OAAO,IAAI,SAAS,CAAC;AAAA,MAC5D;AAEA,UAAI,GAAG,QAAQ;AACb,cAAM,MAAM,KAAK,YAAY,GAAG,MAAM;AAEtC,cAAM,SAAqB;AAAA,UACzB,UAAU;AAAA,UACV,MAAM,eAAe;AAAA,UACrB,QAAQ;AAAA,YACN,GAAG,OAAO;AAAA,YACV;AAAA,YACA,KAAK;AAAA,YACL,KAAK;AAAA,UACP;AAAA,UACA,MAAM,GAAG,OAAO;AAAA,QAClB;AAEA,YAAI,YAAY,eAAgB,eAAe;AAC7C,sBAAY,aAAa,UAAU,EAAE,QAAQ,KAAK,MAAM;AAAA,QAC1D,OAAO;AACL,sBAAY,eAAe,WAAW,EAAE,QAAQ,KAAK,MAAM;AAAA,QAC7D;AAAA,MACF;AAEA,UAAI,GAAG,QAAQ;AACb,cAAM,MAAM,KAAK,YAAY,GAAG,MAAM;AAEtC,cAAM,SAAS;AAAA,UACb,UAAU;AAAA,UACV,MAAM,eAAe;AAAA,UACrB,QAAQ;AAAA,YACN,GAAG,OAAO;AAAA,YACV;AAAA,YACA,KAAK;AAAA,YACL,KAAK;AAAA,UACP;AAAA,UACA,WAAW;AAAA,YACT,GAAG,OAAO;AAAA,YACV;AAAA,YACA,KAAK;AAAA,YACL,KAAK;AAAA,UACP;AAAA,UACA,MAAM,GAAG,OAAO;AAAA,QAClB;AAEA,oBAAY,aAAa,UAAU,EAAE,QAAQ,KAAK,MAAM;AAAA,MAC1D;AAEA,UAAI,GAAG,QAAQ;AACb,cAAM,MAAM,KAAK,YAAY,GAAG,MAAM;AAEtC,cAAM,SAAS;AAAA,UACb,UAAU;AAAA,UACV,MAAM,eAAe;AAAA,UACrB,WAAW;AAAA,YACT,GAAG,OAAO;AAAA,YACV;AAAA,YACA,KAAK;AAAA,YACL,KAAK;AAAA,UACP;AAAA,UACA,MAAM,GAAG,OAAO;AAAA,QAClB;AAEA,oBAAY,aAAa,UAAU,EAAE,QAAQ,KAAK,MAAM;AAAA,MAC1D;AAEA,UAAI,GAAG,MAAM;AACX,cAAM,MAAM,KAAK,YAAY,GAAG,IAAI;AAEpC,cAAM,SAAS;AAAA,UACb,UAAU;AAAA,UACV,MAAM,eAAe;AAAA,UACrB,WAAW;AAAA,YACT,GAAG,KAAK;AAAA,YACR;AAAA,YACA,KAAK;AAAA,YACL,KAAK;AAAA,UACP;AAAA,UACA,MAAM,CAAC;AAAA,QACT;AAEA,oBAAY,aAAa,UAAU,EAAE,QAAQ,KAAK,MAAM;AAAA,MAC1D;AAEA,UAAI,GAAG,SAAS;AAOd,cAAM,KAAK,YAAY,aAAa,UAAU;AAC9C,WAAG,mBAAmB,GAAG,QAAQ;AAEjC,cAAM,QAAQ,GAAG,QAAQ;AACzB,cAAM,QAAQ,CAAC,SAAS;AACtB,gBAAM,SAAuB;AAAA,YAC3B,OAAO,GAAG,QAAS;AAAA,YACnB,eAAe,KAAK;AAAA,YACpB,KAAK,KAAK;AAAA,UACZ;AACA,aAAG,QAAQ,KAAK,MAAM;AAAA,QACxB,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEQ,YAAgC,SAAY;AAClD,QAAI,IAAI,SAAS,KAAK;AAAG,UAAI,MAAM,iBAAiB,YAAY,OAAO,CAAC,EAAE;AAC1E,QAAI,CAAC,KAAK,UAAU,CAAC,KAAK,YAAY,GAAG;AACvC,YAAM,IAAI;AAAA,QACR,mBAAmB;AAAA,QACnB;AAAA,MACF;AAAA,IACF;AACA,UAAM,MAAM,iBAAiB,QAAQ,KAAK;AAC1C,QAAI,QAAQ,QAAW;AACrB,YAAM,IAAI;AAAA,QACR,mBAAmB;AAAA,QACnB,GAAG,QAAQ,KAAK;AAAA,MAClB;AAAA,IACF;AAEA,UAAM,OAAO,iBAAiB,OAAO;AACrC,UAAM,MAAM,IAAI,OAAO,SAAS,IAAI,OAAO,OAAO,CAAC,EAAE,OAAO;AAC5D,UAAM,SAAS,IAAI,WAAW,KAAK,SAAS,IAAI,MAAM;AACtD,WAAO,IAAI,MAAM,CAAC;AAClB,WAAO,IAAI,KAAK,CAAC;AAEjB,SAAK,OAAO,MAAM,MAAM;AAAA,EAC1B;AAAA,EAEA,iBAAsB;AACpB,WAAO,KAAK,SAAS,YAAY;AAAA,EACnC;AAAA,EAEQ,aAAa,QAAuC;AAE1D,QAAI,WAAW;AACb,WAAK,QAAQ,WAAW;AAAA,QACtB,MAAM,KAAK,aAAa,SAAS;AAAA,QACjC,KAAK,QAAQ;AAAA,MACf;AAGF,QAAI,CAAC,KAAK,UAAU,CAAC,KAAK,YAAY;AAAG;AAEzC,QAAI,KAAK,QAAQ,aAAa;AAAW;AAEzC,QAAI,KAAK,QAAQ,eAAe,GAAG,KAAK,QAAQ,QAAQ;AAAG;AAI3D,UAAM,WAAW,KAAK,MAAM,KAAK,QAAQ,gBAAgB,GAAG;AAI5D,QACE,KAAK,QAAQ,cAAc,YAC3B,WAAW,aACX,WAAW,kBACX;AACA,YAAM,MAAgB;AAAA,QACpB,OAAO;AAAA,QACP,cAAc,KAAK,MAAM,KAAI,oBAAI,KAAK,GAAE,QAAQ,CAAC;AAAA,QACjD,KAAK,KAAK,QAAQ;AAAA,QAClB,eAAe,KAAK,QAAQ;AAAA,QAC5B,iBACE,KAAK,QAAQ,8BAA8B;AAAA,QAC7C,yBACE,KAAK,QAAQ,8BAA8B;AAAA,QAC7C,qBAAqB,KAAK,QAAQ,8BAA8B;AAAA,MAClE;AAEA,WAAK,YAAY,GAAG;AACpB,WAAK,QAAQ,gBAAgB,IAAI;AAAA,IACnC;AAAA,EACF;AAAA,EAEO,wBACL,WACA,WACM;AACN,SAAK,sBAAsB,IAAI,UAAU,WAAW,SAAS;AAAA,EAC/D;AAAA,EAEO,0BAA0B,WAAqC;AACpE,SAAK,sBAAsB,OAAO,UAAU,SAAS;AAAA,EACvD;AAAA,EAEQ,0BACN,YACA,UACY;AACZ,UAAM,aAAa,KAAK,sBAAsB,IAAI,WAAW,SAAS,KAAK;AAC3E,QAAI,CAAC;AAAY,aAAO;AACxB,UAAM,iBACJ,aAAa,YACT,WAAW,mBACX,WAAW;AACjB,QAAI;AACF,aAAO;AAAA,QACL,GAAG;AAAA,QACH,QAAQ,WAAW,UAAU,eAAe,WAAW,MAAM;AAAA,QAC7D,WAAW,WAAW,aAAa,eAAe,WAAW,SAAS;AAAA,MACxE;AAAA,IACF,SAAS,KAAU;AACjB,YAAM,IAAI;AAAA,QACR,mBAAmB;AAAA,QACnB,IAAI;AAAA,MACN;AAAA,IACF;AAAA,EACF;AACF;AASA,SAAS,cACP,eACA,OACA,QACQ;AACR,MACE,cAAc,SAAS,KAAK,KAC5B,cAAc,UAAU,KAAK,EAAE,IAAI,OAAO,IAAI,GAC9C;AAEA,WAAO,cAAc,UAAU,KAAK,EAAE,IAAI,OAAO,IAAI;AAAA,EACvD,OAAO;AAUL,WAAO,OAAO,KAAK,YAAY;AAAA,EACjC;AACF;AAEO,SAAS,aACd,KACA,UACA,eACA,SACU;AACV,MAAI,kBAAkB;AACtB,QAAM,oBAAoB,IAAI;AAAA,IAC5B,kBAAkB,SAAS,QAAQ,MAAM;AAAA,EAC3C;AACA,QAAM,eAAe,SAAU,QAAQ;AAAA,IACrC,CAAC,KAAmB,MAAsB;AACxC,YAAM,cAAc,IAAI,EAAE,IAAI;AAC9B,UAAI,gBAAgB,QAAQ,gBAAgB,QAAW;AACrD,cAAM,eAAe,cAAc,eAAe,SAAS,OAAO,CAAC;AACnE,YAAI,KAAK,oBAAoB,aAAa,cAAc,OAAO,CAAC;AAAA,MAClE,OAAO;AACL,YAAI,KAAK,kBAAkB,CAAC;AAC5B,mBAAW,mBAAmB,eAAe;AAAA,MAC/C;AACA,wBAAkB,kBAAkB;AACpC,aAAO;AAAA,IACT;AAAA,IACA,CAAC;AAAA,EACH;AACA,SAAO,SAAS,YAAY;AAAA,IAC1B,cAAc;AAAA,IACd,QAAQ;AAAA,EACV,CAAC;AACH;AAcO,SAAS,eACd,KACA,UACA,eACA,SACsB;AACtB,MAAI,QAAQ,QAAW;AACrB,WAAO;AAAA,EACT;AACA,SAAO,SAAS,QAAQ,OAAO,CAAC,iBAAiB,GAAG,MAAM;AACxD,QAAI,WAAW,IAAI,cAAc,CAAC,MAAM,GAAG;AACzC,sBAAgB,EAAE,IAAI,IAAI;AAAA,IAC5B,OAAO;AACL,YAAM,eAAe,cAAc,eAAe,SAAS,OAAO,CAAC;AACnE,sBAAgB,EAAE,IAAI,IAAI;AAAA,QACxB,IAAI,OAAO,CAAC;AAAA,QACZ;AAAA,QACA;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT,GAAG,CAAC,CAAa;AACnB;AAEA,SAAS,kBAAkB,YAA4B;AACrD,QAAM,MAAM,aAAa;AACzB,MAAI,QAAQ,GAAG;AACb,WAAO,aAAa;AAAA,EACtB,OAAO;AACL,WAAO,KAAK,aAAa,OAAO;AAAA,EAClC;AACF;AAEA,SAAS,sBACP,QACA,YACA,SACwC;AACxC,UAAQ,YAAY;AAAA,IAClB,KAAK,YAAY;AACf,aAAO,QAAQ,KAAK,MAAM;AAAA,IAC5B,KAAK,YAAY;AAAA,IACjB,KAAK,YAAY;AAAA,IACjB,KAAK,YAAY;AAAA,IACjB,KAAK,YAAY;AACf,aAAO,OAAO,QAAQ,KAAK,MAAM,CAAC;AAAA,IACpC,KAAK,YAAY;AAAA,IACjB,KAAK,YAAY;AAAA,IACjB,KAAK,YAAY;AACf,aAAO,QAAQ,MAAM,MAAM;AAAA,IAC7B,KAAK,WAAW;AACd,aAAO,QAAQ,OAAO,MAAM;AAAA,IAC9B,KAAK,YAAY;AACf,aAAO,QAAQ,MAAM,MAAM;AAAA,IAC7B,KAAK,YAAY;AAAA,IACjB,KAAK,YAAY;AACf,aAAO,QAAQ,KAAK,MAAM;AAAA,IAC5B;AAEE,aAAO,QAAQ,KAAK,MAAM;AAAA,EAC9B;AACF;AAGA,SAAS,oBACP,aACA,YACA,SACY;AACZ,UAAQ,YAAY;AAAA,IAClB,KAAK,YAAY;AACf,aAAQ,QAAQ,KAAa,WAAW;AAAA,IAC1C,KAAK,WAAW;AACd,aAAO,QAAQ,OAAO,WAAqB;AAAA,IAC7C,KAAK,YAAY;AACf,aAAO,QAAQ,MAAM,WAAyB;AAAA,IAChD,KAAK,YAAY;AAAA,IACjB,KAAK,YAAY;AACf,aAAQ,QAAQ,KAAa,WAAW;AAAA,IAC1C;AACE,aAAO,QAAQ,KAAK,OAAO,WAAW,CAAC;AAAA,EAC3C;AACF;AAEA,SAAS,oBAAgC;AACvC,SAAO,IAAI,WAAW;AACxB;AAEO,SAAS,UAAU,MAA4B;AACpD,QAAM,OAAO,KAAK,CAAC;AACnB,QAAM,OAAO,gBAAgB,IAAI;AACjC,QAAM,MAAM,iBAAiB,IAAI;AACjC,MAAI,QAAQ,QAAW;AACrB,UAAM,IAAI;AAAA,MACR,mBAAmB;AAAA,MACnB,GAAG,IAAI;AAAA,IACT;AAAA,EACF;AACA,SAAO,IAAI,OAAO,KAAK,SAAS,CAAC,CAAC;AACpC;","names":[]}