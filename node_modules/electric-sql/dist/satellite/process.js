import throttle from "lodash.throttle";
import {
  SatOpMigrate_Type,
  SatRelation_RelationType
} from '../_generated/protocol/satellite.js';
import { getWaiter } from '../util/common.js';
import { base64, bytesToNumber } from '../util/encoders/index.js';
import { QualifiedTablename } from '../util/tablename.js';
import {
  ReplicationStatus,
  SatelliteError,
  SatelliteErrorCode,
  isDataChange
} from '../util/types.js';
import {
  OPTYPES,
  encodeTags,
  extractPK,
  fromTransaction,
  generateTag,
  getShadowPrimaryKey,
  primaryKeyToStr,
  toTransactions
} from './oplog.js';
import { Mutex } from "async-mutex";
import Log from "loglevel";
import { generateTableTriggers } from '../migrators/triggers.js';
import { mergeEntries } from './merge.js';
import { backOff } from "exponential-backoff";
import { chunkBy, genUUID } from '../util/index.js';
import { isFatal, isOutOfSyncError, isThrowable, wrapFatalError } from './error.js';
import { inferRelationsFromDb } from '../util/relations.js';
import { decodeUserIdFromToken } from '../auth/secure/index.js';
import { InvalidArgumentError } from '../client/validation/errors/invalidArgumentError.js';
import Long from "long";
import groupBy from "lodash.groupby";
import { ShapeManager } from './shapes/shapeManager.js';
import { runInTransaction } from '../util/transactions.js';
import { ForeignKeyChecks } from '../config/index.js';
const connectRetryHandler = (error) => {
  if (!(error instanceof SatelliteError) || isThrowable(error) || isFatal(error)) {
    Log.debug(`connectAndStartRetryHandler was cancelled: ${error.message}`);
    return false;
  }
  return true;
};
class SatelliteProcess {
  dbName;
  adapter;
  migrator;
  notifier;
  client;
  builder;
  opts;
  fkChecks;
  _authState;
  _unsubscribeFromAuthState;
  connectivityState;
  _unsubscribeFromConnectivityChanges;
  _pollingInterval;
  _unsubscribeFromPotentialDataChanges;
  _throttledSnapshot;
  _lsn;
  relations;
  previousShapeSubscriptions;
  subscriptionManager;
  /**
   * To optimize inserting a lot of data when the subscription data comes, we need to do
   * less `INSERT` queries, but SQLite/Postgres support only a limited amount of `?`/`$i` positional
   * arguments. Precisely, its either 999 for SQLite versions prior to 3.32.0 and 32766 for
   * versions after, and 65535 for Postgres.
   */
  maxSqlParameters = 999;
  snapshotMutex = new Mutex();
  performingSnapshot = false;
  _connectRetryHandler;
  initializing;
  _removeClientListeners;
  constructor(dbName, adapter, migrator, notifier, client, opts) {
    this.dbName = dbName;
    this.adapter = adapter;
    this.migrator = migrator;
    this.notifier = notifier;
    this.client = client;
    this.builder = this.migrator.queryBuilder;
    this.opts = opts;
    this.fkChecks = this.builder.dialect === "SQLite" ? this.opts.fkChecks : ForeignKeyChecks.inherit;
    this.relations = {};
    this.previousShapeSubscriptions = [];
    this.subscriptionManager = new ShapeManager(
      this.notifier.shapeSubscriptionSyncStatusChanged.bind(
        this.notifier,
        this.dbName
      )
    );
    this._throttledSnapshot = throttle(
      this._mutexSnapshot.bind(this),
      opts.minSnapshotWindow,
      {
        leading: true,
        trailing: true
      }
    );
    this._connectRetryHandler = connectRetryHandler;
  }
  /**
   * Perform a snapshot while taking out a mutex to avoid concurrent calls.
   */
  async _mutexSnapshot() {
    const release = await this.snapshotMutex.acquire();
    try {
      return await this._performSnapshot();
    } finally {
      release();
    }
  }
  async start(authConfig) {
    if (this.opts.debug) {
      await this.logDatabaseVersion();
    }
    this.setClientListeners();
    await this.migrator.up();
    const isVerified = await this._verifyTableStructure();
    if (!isVerified) {
      throw new Error("Invalid database schema.");
    }
    const clientId = authConfig?.clientId && authConfig.clientId !== "" ? authConfig.clientId : await this._getClientId();
    this._setAuthState({ clientId });
    const notifierSubscriptions = Object.entries({
      _authStateSubscription: this._unsubscribeFromAuthState,
      _connectivityChangeSubscription: this._unsubscribeFromConnectivityChanges,
      _potentialDataChangeSubscription: this._unsubscribeFromPotentialDataChanges
    });
    notifierSubscriptions.forEach(([name, value]) => {
      if (value !== void 0) {
        throw new Error(
          `Starting satellite process with an existing
           \`${name}\`.
           This means there is a notifier subscription leak.`
        );
      }
    });
    const authStateHandler = this._updateAuthState.bind(this);
    this._unsubscribeFromAuthState = this.notifier.subscribeToAuthStateChanges(authStateHandler);
    this._unsubscribeFromPotentialDataChanges = this.notifier.subscribeToPotentialDataChanges(this._throttledSnapshot);
    clearInterval(this._pollingInterval);
    this._pollingInterval = setInterval(
      this._throttledSnapshot,
      this.opts.pollingInterval
    );
    await this._throttledSnapshot();
    this.relations = await this._getLocalRelations();
    this.checkMaxSqlParameters();
    const lsnBase64 = await this._getMeta("lsn");
    if (lsnBase64 && lsnBase64.length > 0) {
      this._lsn = base64.toBytes(lsnBase64);
      Log.info(`retrieved lsn ${this._lsn}`);
    } else {
      Log.info(`no lsn retrieved from store`);
    }
    const subscriptionsState = await this._getMeta("subscriptions");
    if (subscriptionsState) {
      this.subscriptionManager.initialize(subscriptionsState);
    }
  }
  async logDatabaseVersion() {
    const versionRow = await this.adapter.query({
      sql: this.builder.getVersion
    });
    Log.info(
      `Using ${this.builder.dialect} version: ${versionRow[0]["version"]}`
    );
  }
  _setAuthState(authState) {
    this._authState = authState;
  }
  // Adds all the necessary listeners to the satellite client
  // They can be cleared up by calling the function `_removeClientListeners`
  setClientListeners() {
    if (this._removeClientListeners) {
      this._removeClientListeners?.();
      this._removeClientListeners = void 0;
    }
    const clientErrorCallback = this._handleClientError.bind(this);
    this.client.subscribeToError(clientErrorCallback);
    const clientRelationsCallback = this._handleClientRelations.bind(this);
    this.client.subscribeToRelations(clientRelationsCallback);
    const clientTransactionsCallback = this._handleClientTransactions.bind(this);
    this.client.subscribeToTransactions(clientTransactionsCallback);
    const clientAdditionalDataCallback = this._handleClientAdditionalData.bind(this);
    this.client.subscribeToAdditionalData(clientAdditionalDataCallback);
    const clientOutboundStartedCallback = this._handleClientOutboundStarted.bind(this);
    this.client.subscribeToOutboundStarted(clientOutboundStartedCallback);
    const clientGoneBatchCallback = this._applyGoneBatch.bind(this);
    this.client.subscribeToGoneBatch(clientGoneBatchCallback);
    const clientSubscriptionDataCallback = this._handleSubscriptionData.bind(this);
    const clientSubscriptionErrorCallback = this._handleSubscriptionError.bind(this);
    this.client.subscribeToSubscriptionEvents(
      clientSubscriptionDataCallback,
      clientSubscriptionErrorCallback
    );
    this._removeClientListeners = () => {
      this.client.unsubscribeToError(clientErrorCallback);
      this.client.unsubscribeToRelations(clientRelationsCallback);
      this.client.unsubscribeToTransactions(clientTransactionsCallback);
      this.client.unsubscribeToAdditionalData(clientAdditionalDataCallback);
      this.client.unsubscribeToOutboundStarted(clientOutboundStartedCallback);
      this.client.unsubscribeToSubscriptionEvents(
        clientSubscriptionDataCallback,
        clientSubscriptionErrorCallback
      );
      this.client.unsubscribeToGoneBatch(clientGoneBatchCallback);
    };
  }
  // Unsubscribe from data changes and stop polling
  async stop(shutdown) {
    return this._stop(shutdown);
  }
  async _stop(shutdown) {
    clearInterval(this._pollingInterval);
    this._pollingInterval = void 0;
    const unsubscribers = [
      "_unsubscribeFromAuthState",
      "_unsubscribeFromConnectivityChanges",
      "_unsubscribeFromPotentialDataChanges"
    ];
    unsubscribers.forEach((unsubscriber) => {
      const unsub = this[unsubscriber];
      if (unsub !== void 0) {
        unsub();
        this[unsubscriber] = void 0;
      }
    });
    this._removeClientListeners?.();
    this._removeClientListeners = void 0;
    this._throttledSnapshot.cancel();
    await this._waitForActiveSnapshots();
    this.disconnect();
    if (shutdown) {
      await this.client.shutdown();
    }
  }
  // Ensure that no snapshot is left running in the background
  // by acquiring the mutex and releasing it immediately.
  async _waitForActiveSnapshots() {
    const releaseMutex = await this.snapshotMutex.acquire();
    releaseMutex();
  }
  /** Get information about a requested subscription by it's key */
  syncStatus(key) {
    return this.subscriptionManager.status(key);
  }
  /**
   * Subscribe to a set of shapes, so that server data can get onto the client.
   *
   * A set of shapes can be "named" using a key. Any subsequent calls to `subscribe`
   * using this key will exchange the subscription: a new one will be subscribed, and
   * then the old one will be unsubscribed.
   *
   * If the `key` is not provided, it will instead be generated. Un-keyed subscriptions
   * are deduplicated: multiple `subscribe` calls with exactly same shapes will result in
   * only one subscription, and will even return the same key.
   */
  async subscribe(shapeDefinitions, key) {
    await this.initializing?.waitOn();
    return this._doSubscribe(shapeDefinitions, key);
  }
  /** Make a subscription without waiting for init */
  async _doSubscribe(shapes, key) {
    const request = this.subscriptionManager.syncRequested(shapes, key);
    if ("existing" in request)
      return { key: request.key, synced: request.existing };
    const clearSubAndThrow = (error) => {
      request.syncFailed();
      throw error;
    };
    try {
      const { subscriptionId, error } = await this.client.subscribe(
        genUUID(),
        shapes.map((x) => ({ definition: x, requestId: genUUID() }))
      );
      request.setServerId(subscriptionId);
      if (error)
        throw error;
      await this._setMeta("subscriptions", this.subscriptionManager.serialize());
      return {
        key: request.key,
        synced: request.promise
      };
    } catch (error) {
      return clearSubAndThrow(error);
    }
  }
  unsubscribe(target) {
    if (Array.isArray(target)) {
      return this.unsubscribeIds(this.subscriptionManager.getServerIDs(target));
    } else if (target.key) {
      return this.unsubscribeIds(
        this.subscriptionManager.getServerIDs([target.key])
      );
    } else {
      return this.unsubscribeIds(
        this.subscriptionManager.getServerIDsForShapes(target.shapes)
      );
    }
  }
  async unsubscribeIds(subscriptionIds) {
    if (subscriptionIds.length === 0)
      return;
    await this.client.unsubscribe(subscriptionIds);
    this.subscriptionManager.unsubscribeMade(subscriptionIds);
    await this.adapter.run(
      this._setMetaStatement(
        "subscriptions",
        this.subscriptionManager.serialize()
      )
    );
  }
  async _handleSubscriptionData(subsData) {
    const afterApply = this.subscriptionManager.dataDelivered(
      subsData.subscriptionId
    );
    const applied = await this._applySubscriptionData(
      subsData.data,
      subsData.lsn,
      [],
      subsData.subscriptionId
    );
    if (applied) {
      const toBeUnsubbed = afterApply();
      if (toBeUnsubbed.length > 0)
        await this.unsubscribeIds(toBeUnsubbed);
    }
  }
  /**
   * Insert incoming subscription data into the database.
   * Returns flag indicating whether application was successful or not.
   */
  async _applySubscriptionData(changes, lsn, additionalStmts = [], subscriptionId) {
    const namespace = this.builder.defaultNamespace;
    const stmts = [];
    stmts.push({ sql: this.builder.deferOrDisableFKsForTx });
    const groupedChanges = /* @__PURE__ */ new Map();
    const allArgsForShadowInsert = [];
    const fullTableNameLookup = /* @__PURE__ */ new Map();
    for (const op of changes) {
      let groupedChange;
      if (!fullTableNameLookup.has(op.relation.table)) {
        const qt = new QualifiedTablename(namespace, op.relation.table);
        const tableName = qt.toString();
        fullTableNameLookup.set(op.relation.table, tableName);
        groupedChange = {
          relation: op.relation,
          primaryKeyColNames: op.relation.columns.filter((col) => col.primaryKey).map((col) => col.name),
          records: [op.record],
          table: qt
        };
        groupedChanges.set(tableName, groupedChange);
      } else {
        groupedChange = groupedChanges.get(
          fullTableNameLookup.get(op.relation.table)
        );
        groupedChange.records.push(op.record);
      }
      const primaryKeyCols = groupedChange.primaryKeyColNames.reduce(
        (agg, colName) => {
          agg[colName] = op.record[colName];
          return agg;
        },
        {}
      );
      allArgsForShadowInsert.push({
        namespace,
        tablename: op.relation.table,
        primaryKey: primaryKeyToStr(primaryKeyCols),
        tags: encodeTags(op.tags)
      });
    }
    const qualifiedTableNames = [
      ...Array.from(groupedChanges.values()).map((chg) => chg.table)
    ];
    stmts.push(...this._disableTriggers(qualifiedTableNames));
    for (const [_table, { relation, records, table }] of groupedChanges) {
      const columnNames = relation.columns.map((col) => col.name);
      const qualifiedTableName = `${table}`;
      const orIgnore = this.builder.sqliteOnly("OR IGNORE");
      const onConflictDoNothing = this.builder.pgOnly("ON CONFLICT DO NOTHING");
      const sqlBase = `INSERT ${orIgnore} INTO ${qualifiedTableName} (${columnNames.join(
        ", "
      )}) VALUES `;
      stmts.push(
        ...this.builder.prepareInsertBatchedStatements(
          sqlBase,
          columnNames,
          records,
          this.maxSqlParameters,
          onConflictDoNothing
        )
      );
    }
    stmts.push(...this._enableTriggers(qualifiedTableNames));
    const batchedShadowInserts = this.builder.batchedInsertOrReplace(
      this.opts.shadowTable,
      ["namespace", "tablename", "primaryKey", "tags"],
      allArgsForShadowInsert,
      ["namespace", "tablename", "primaryKey"],
      ["namespace", "tablename", "tags"],
      this.maxSqlParameters
    );
    stmts.push(...batchedShadowInserts);
    stmts.push(
      this._setMetaStatement(
        "subscriptions",
        this.subscriptionManager.serialize()
      ),
      this.updateLsnStmt(lsn),
      ...additionalStmts
    );
    try {
      await this.runInTransaction(...stmts);
      const notificationChanges = [];
      groupedChanges.forEach(({ records, table, primaryKeyColNames }) => {
        notificationChanges.push({
          qualifiedTablename: table,
          rowids: [],
          recordChanges: records.map((change) => {
            return {
              primaryKey: primaryKeyColNames.reduce(
                (primaryKeyRec, col_name) => {
                  primaryKeyRec[col_name] = change[col_name];
                  return primaryKeyRec;
                },
                {}
              ),
              type: "INITIAL"
            };
          })
        });
      });
      this.notifier.actuallyChanged(this.dbName, notificationChanges, "initial");
      return true;
    } catch (e) {
      this._handleSubscriptionError(
        new SatelliteError(
          SatelliteErrorCode.INTERNAL,
          `Error applying subscription data: ${e.message}`
        ),
        subscriptionId
      );
      return false;
    }
  }
  /**
   * Runs the provided statements in a transaction and disables FK checks if `this.fkChecks` is set to `disabled`.
   * `this.fkChecks` should only be set to true when using SQLite as we already disable FK checks for incoming TXs when using Postgres
   */
  async runInTransaction(...stmts) {
    return runInTransaction(this.adapter, this.fkChecks, ...stmts);
  }
  _resetClientState(opts) {
    Log.warn(`resetting client state`);
    this.disconnect();
    this._lsn = void 0;
    const tables = this.subscriptionManager.reset({
      defaultNamespace: this.builder.defaultNamespace,
      reestablishSubscribed: opts?.keepSubscribedShapes
    });
    return this._clearTables(tables);
  }
  async _clearTables(tables) {
    await this.runInTransaction(
      this._setMetaStatement("lsn", null),
      this._setMetaStatement(
        "subscriptions",
        this.subscriptionManager.serialize()
      ),
      { sql: this.builder.deferOrDisableFKsForTx },
      ...this._disableTriggers(tables),
      ...tables.map((x) => ({ sql: `DELETE FROM ${x}` })),
      ...this._enableTriggers(tables)
    );
  }
  async _handleSubscriptionError(satelliteError, subscriptionId) {
    Log.error("encountered a subscription error: " + satelliteError.message);
    let resettingError = satelliteError;
    let onFailure;
    if (subscriptionId)
      onFailure = this.subscriptionManager.getOnFailureCallback(subscriptionId);
    try {
      await this._resetClientState();
    } catch (error) {
      console.log(error);
      resettingError = error;
      resettingError.stack += "\n  Encountered when handling a subscription error: \n    " + satelliteError.stack;
    }
    onFailure?.(resettingError);
  }
  _handleClientRelations(relation) {
    this._updateRelations(relation);
  }
  async _handleClientTransactions(tx) {
    await this._applyTransaction(tx);
  }
  async _handleClientAdditionalData(data) {
    await this._applyAdditionalData(data);
  }
  async _handleClientOutboundStarted() {
    await this._throttledSnapshot();
  }
  // handles async client errors: can be a socket error or a server error message
  _handleClientError(satelliteError) {
    if (this.initializing && !this.initializing.finished()) {
      if (satelliteError.code === SatelliteErrorCode.SOCKET_ERROR) {
        Log.warn(
          `a socket error occurred while connecting to server: ${satelliteError.message}`
        );
        return;
      }
      if (satelliteError.code === SatelliteErrorCode.AUTH_REQUIRED) {
        Log.warn(
          `an authentication error occurred while connecting to server: ${satelliteError.message}`
        );
        return;
      }
      throw satelliteError;
    }
    Log.warn(`an error occurred in satellite: ${satelliteError.message}`);
    this._handleOrThrowClientError(satelliteError);
  }
  async _handleOrThrowClientError(error) {
    if (error.code === SatelliteErrorCode.AUTH_EXPIRED) {
      Log.warn("Connection closed by Electric because the JWT expired.");
      return this.disconnect(
        new SatelliteError(
          error.code,
          "Connection closed by Electric because the JWT expired."
        )
      );
    }
    this.disconnect(error);
    if (isThrowable(error)) {
      throw error;
    }
    if (isFatal(error)) {
      throw wrapFatalError(error);
    }
    Log.warn("Client disconnected with a non fatal error, reconnecting");
    return this.connectWithBackoff();
  }
  /**
   * Sets the JWT token.
   * @param token The JWT token.
   */
  setToken(token) {
    const newUserId = decodeUserIdFromToken(token);
    const userId = this._authState?.userId;
    if (typeof userId !== "undefined" && newUserId !== userId) {
      throw new InvalidArgumentError(
        `Can't change user ID when reconnecting. Previously connected with user ID '${userId}' but trying to reconnect with user ID '${newUserId}'`
      );
    }
    this._setAuthState({
      ...this._authState,
      userId: newUserId,
      token
    });
  }
  /**
   * @returns True if a JWT token has been set previously. False otherwise.
   */
  hasToken() {
    return this._authState?.token !== void 0;
  }
  async connectWithBackoff() {
    if (this.client.isConnected()) {
      return;
    }
    if (this.initializing && !this.initializing.finished()) {
      return this.initializing.waitOn();
    }
    if (!this.initializing || this.initializing?.finished()) {
      this.initializing = getWaiter();
    }
    const opts = {
      ...this.opts.connectionBackOffOptions,
      retry: this._connectRetryHandler
    };
    const prom = this.initializing.waitOn();
    await backOff(async () => {
      if (this.initializing?.finished()) {
        return prom;
      }
      await this._connect();
      await this._startReplication();
      await this._makePendingSubscriptions();
      this._notifyConnectivityState("connected");
      this.initializing?.resolve();
    }, opts).catch((e) => {
      const error = !connectRetryHandler(e, 0) ? e : new SatelliteError(
        SatelliteErrorCode.CONNECTION_FAILED_AFTER_RETRY,
        `Failed to connect to server after exhausting retry policy. Last error thrown by server: ${e.message}`
      );
      this.disconnect(error);
      this.initializing?.reject(error);
    });
    return prom;
  }
  async _makePendingSubscriptions() {
    const { subscribe, unsubscribe } = this.subscriptionManager.listPendingActions();
    await this.unsubscribeIds(unsubscribe);
    await Promise.all(subscribe.map((x) => this._doSubscribe(x.shapes, x.key)));
  }
  // _subscribePreviousShapeRequests(): void {
  //   try {
  //     if (this.previousShapeSubscriptions.length > 0) {
  //       Log.warn(`Subscribing previous shape definitions`)
  //       this.subscribe(
  //         this.previousShapeSubscriptions.splice(
  //           0,
  //           this.previousShapeSubscriptions.length
  //         )
  //       )
  //     }
  //   } catch (error: any) {
  //     const message = `Client was unable to subscribe previously subscribed shapes: ${error.message}`
  //     throw new SatelliteError(SatelliteErrorCode.INTERNAL, message)
  //   }
  // }
  // NO DIRECT CALLS TO CONNECT
  async _connect() {
    Log.info(`connecting to electric server`);
    if (!this._authState || !this._authState.token) {
      throw new Error(`trying to connect before authentication`);
    }
    try {
      await this.client.connect();
      await this.authenticate(this._authState.token);
    } catch (error) {
      Log.debug(
        `server returned an error while establishing connection: ${error.message}`
      );
      throw error;
    }
  }
  /**
   * Authenticates with the Electric sync service using the provided token.
   * @returns A promise that resolves to void if authentication succeeded. Otherwise, rejects with the reason for the error.
   */
  async authenticate(token) {
    const authState = {
      clientId: this._authState.clientId,
      token
    };
    const authResp = await this.client.authenticate(authState);
    if (authResp.error) {
      throw authResp.error;
    }
    this._setAuthState(authState);
  }
  cancelConnectionWaiter(error) {
    if (this.initializing && !this.initializing.finished()) {
      this.initializing?.reject(error);
    }
  }
  disconnect(error) {
    this.client.disconnect();
    this._notifyConnectivityState("disconnected", error);
  }
  /**
   * A disconnection issued by the client.
   */
  clientDisconnect() {
    const error = new SatelliteError(
      SatelliteErrorCode.CONNECTION_CANCELLED_BY_DISCONNECT,
      `Connection cancelled by 'disconnect'`
    );
    this.disconnect(error);
    this.cancelConnectionWaiter(error);
  }
  async _startReplication() {
    try {
      const schemaVersion = await this.migrator.querySchemaVersion();
      const subscriptionsState = await this._getMeta("subscriptions");
      if (subscriptionsState) {
        this.subscriptionManager.initialize(subscriptionsState);
      }
      const subscriptionIds = this.subscriptionManager.listContinuedSubscriptions();
      const observedTransactionData = await this._getMeta("seenAdditionalData");
      const { error } = await this.client.startReplication(
        this._lsn,
        schemaVersion,
        subscriptionIds.length > 0 ? subscriptionIds : void 0,
        observedTransactionData.split(",").filter((x) => x !== "").map((x) => Long.fromString(x))
      );
      if (error) {
        throw error;
      }
    } catch (error) {
      Log.warn(`Couldn't start replication: ${error.message}`);
      if (!(error instanceof SatelliteError)) {
        throw new SatelliteError(SatelliteErrorCode.INTERNAL, error.message);
      }
      if (isOutOfSyncError(error) && this.opts?.clearOnBehindWindow) {
        await this._resetClientState({ keepSubscribedShapes: true });
        throw error;
      }
      if (isThrowable(error)) {
        throw error;
      }
      if (isFatal(error)) {
        throw wrapFatalError(error);
      }
    }
  }
  _notifyConnectivityState(connectivityStatus, error) {
    this.connectivityState = {
      status: connectivityStatus,
      reason: error
    };
    this.notifier.connectivityStateChanged(this.dbName, this.connectivityState);
  }
  async _verifyTableStructure() {
    const meta = this.opts.metaTable.tablename;
    const oplog = this.opts.oplogTable.tablename;
    const shadow = this.opts.shadowTable.tablename;
    const [{ count }] = await this.adapter.query(
      this.builder.countTablesIn([meta, oplog, shadow])
    );
    return count === 3;
  }
  // Handle auth state changes.
  async _updateAuthState({ authState }) {
    this._authState = authState;
  }
  // Perform a snapshot and notify which data actually changed.
  // It is not safe to call concurrently. Use mutexSnapshot.
  async _performSnapshot() {
    if (this.performingSnapshot) {
      throw new SatelliteError(
        SatelliteErrorCode.INTERNAL,
        "already performing snapshot"
      );
    } else {
      this.performingSnapshot = true;
    }
    try {
      const oplog = `${this.opts.oplogTable}`;
      const shadow = `${this.opts.shadowTable}`;
      const timestamp = /* @__PURE__ */ new Date();
      const newTag = this._generateTag(timestamp);
      const q1 = {
        sql: `
      UPDATE ${oplog} SET timestamp = ${this.builder.makePositionalParam(1)}
      WHERE rowid in (
        SELECT rowid FROM ${oplog}
            WHERE timestamp is NULL
        ORDER BY rowid ASC
        )
      RETURNING *
      `,
        args: [timestamp.toISOString()]
      };
      const q2 = {
        sql: `
      UPDATE ${oplog}
      SET "clearTags" =
          CASE WHEN shadow.tags = '[]' OR shadow.tags = ''
               THEN '["' || ${this.builder.makePositionalParam(1)} || '"]'
               ELSE '["' || ${this.builder.makePositionalParam(
          2
        )} || '",' || substring(shadow.tags, 2)
          END
      FROM ${shadow} AS shadow
      WHERE ${oplog}.namespace = shadow.namespace
          AND ${oplog}.tablename = shadow.tablename
          AND ${oplog}."primaryKey" = shadow."primaryKey" AND ${oplog}.timestamp = ${this.builder.makePositionalParam(
          3
        )}
      `,
        args: [newTag, newTag, timestamp.toISOString()]
      };
      const q3 = {
        sql: this.builder.setTagsForShadowRows(
          this.opts.oplogTable,
          this.opts.shadowTable
        ),
        args: [encodeTags([newTag]), timestamp.toISOString()]
      };
      const q4 = {
        sql: this.builder.removeDeletedShadowRows(
          this.opts.oplogTable,
          this.opts.shadowTable
        ),
        args: [timestamp.toISOString()]
      };
      const oplogEntries = await this.adapter.transaction(
        (tx, setResult) => {
          tx.query(q1, (tx2, res) => {
            if (res.length > 0)
              tx2.run(
                q2,
                (tx3) => tx3.run(
                  q3,
                  (tx4) => tx4.run(q4, () => setResult(res))
                )
              );
            else {
              setResult([]);
            }
          });
        }
      );
      if (oplogEntries.length > 0)
        this._notifyChanges(oplogEntries, "local");
      if (this.client.getOutboundReplicationStatus() === ReplicationStatus.ACTIVE) {
        const enqueued = this.client.getLastSentLsn();
        const enqueuedLogPos = bytesToNumber(enqueued);
        await this._getEntries(enqueuedLogPos).then(
          (missing) => this._replicateSnapshotChanges(missing)
        );
      }
      return timestamp;
    } catch (e) {
      Log.error(`error performing snapshot: ${e}`);
      throw e;
    } finally {
      this.performingSnapshot = false;
    }
  }
  _notifyChanges(results, origin) {
    const acc = {};
    const reduceFn = (acc2, entry) => {
      const qt = new QualifiedTablename(entry.namespace, entry.tablename);
      const key = qt.toString();
      if (key in acc2) {
        const change = acc2[key];
        if (change.rowids === void 0) {
          change.rowids = [];
        }
        if (change.recordChanges === void 0) {
          change.recordChanges = [];
        }
        change.rowids.push(entry.rowid);
        change.recordChanges.push({
          primaryKey: JSON.parse(entry.primaryKey),
          type: entry.optype
        });
      } else {
        acc2[key] = {
          qualifiedTablename: qt,
          rowids: [entry.rowid],
          recordChanges: [
            {
              primaryKey: JSON.parse(entry.primaryKey),
              type: entry.optype
            }
          ]
        };
      }
      return acc2;
    };
    const changes = Object.values(results.reduce(reduceFn, acc));
    this.notifier.actuallyChanged(this.dbName, changes, origin);
  }
  async _replicateSnapshotChanges(results) {
    if (this.client.getOutboundReplicationStatus() !== ReplicationStatus.ACTIVE) {
      return;
    }
    const transactions = toTransactions(results, this.relations);
    for (const txn of transactions) {
      this.client.enqueueTransaction(txn);
    }
  }
  // Apply a set of incoming transactions against pending local operations,
  // applying conflict resolution rules. Takes all changes per each key before
  // merging, for local and remote operations.
  // TODO: in case the subscriptions between the client and server become
  // out of sync, the server might send operations that do not belong to
  // any existing subscription. We need a way to detect and prevent that.
  async _apply(incoming, incoming_origin) {
    const local = await this._getEntries();
    const merged = mergeEntries(
      this._authState.clientId,
      local,
      incoming_origin,
      incoming,
      this.relations
    );
    const stmts = [];
    for (const [tablenameStr, mapping] of Object.entries(merged)) {
      const qualifiedTableName = QualifiedTablename.parse(tablenameStr);
      for (const entryChanges of Object.values(mapping)) {
        const shadowEntry = {
          namespace: entryChanges.namespace,
          tablename: entryChanges.tablename,
          primaryKey: getShadowPrimaryKey(entryChanges),
          tags: encodeTags(entryChanges.tags)
        };
        switch (entryChanges.optype) {
          case OPTYPES.gone:
          case OPTYPES.delete:
            stmts.push(
              this._applyDeleteOperation(entryChanges, qualifiedTableName)
            );
            stmts.push(this._deleteShadowTagsStatement(shadowEntry));
            break;
          default:
            stmts.push(
              this._applyNonDeleteOperation(entryChanges, qualifiedTableName)
            );
            stmts.push(this._updateShadowTagsStatement(shadowEntry));
        }
      }
    }
    const tablenames = Object.keys(merged);
    return {
      tablenames,
      statements: stmts
    };
  }
  async _getEntries(since) {
    since ??= -1;
    const oplog = `${this.opts.oplogTable}`;
    const selectEntries = `
      SELECT * FROM ${oplog}
        WHERE timestamp IS NOT NULL
          AND rowid > ${this.builder.makePositionalParam(1)}
        ORDER BY rowid ASC
    `;
    const rows = await this.adapter.query({ sql: selectEntries, args: [since] });
    return rows;
  }
  _deleteShadowTagsStatement(shadow) {
    const shadowTable = `${this.opts.shadowTable}`;
    const pos = (i) => this.builder.makePositionalParam(i);
    const deleteRow = `
      DELETE FROM ${shadowTable}
      WHERE namespace = ${pos(1)} AND
            tablename = ${pos(2)} AND
            "primaryKey" = ${pos(3)};
    `;
    return {
      sql: deleteRow,
      args: [shadow.namespace, shadow.tablename, shadow.primaryKey]
    };
  }
  _updateShadowTagsStatement(shadow) {
    return this.builder.insertOrReplace(
      this.opts.shadowTable,
      ["namespace", "tablename", "primaryKey", "tags"],
      [shadow.namespace, shadow.tablename, shadow.primaryKey, shadow.tags],
      ["namespace", "tablename", "primaryKey"],
      ["tags"]
    );
  }
  _updateRelations(rel) {
    if (rel.tableType === SatRelation_RelationType.TABLE) {
      const tableName = rel.table;
      if (this.relations[tableName] === void 0) {
        let id = 0;
        for (const r of Object.values(this.relations)) {
          if (r.id > id) {
            id = r.id;
          }
        }
        const relation = {
          ...rel,
          id: id + 1
        };
        this.relations[tableName] = relation;
      } else {
        const id = this.relations[tableName].id;
        const relation = {
          ...rel,
          id
        };
        this.relations[tableName] = relation;
      }
    }
  }
  async _applyTransaction(transaction) {
    const namespace = this.builder.defaultNamespace;
    const origin = transaction.origin;
    const commitTimestamp = new Date(transaction.commit_timestamp.toNumber());
    const stmts = [];
    const txStmts = [];
    const tablenamesSet = /* @__PURE__ */ new Set();
    let newTables = /* @__PURE__ */ new Set();
    const opLogEntries = [];
    const lsn = transaction.lsn;
    let firstDMLChunk = true;
    stmts.push({ sql: this.builder.deferOrDisableFKsForTx });
    stmts.push(this.updateLsnStmt(lsn));
    stmts.push(this._resetAllSeenStmt());
    const processDML = async (changes) => {
      const tx = {
        ...transaction,
        changes
      };
      const entries = fromTransaction(tx, this.relations, namespace);
      if (firstDMLChunk) {
        Log.info(`apply incoming changes for LSN: ${base64.fromBytes(lsn)}`);
        await this._mutexSnapshot();
        firstDMLChunk = false;
      }
      const { statements, tablenames: tablenames2 } = await this._apply(entries, origin);
      entries.forEach((e) => opLogEntries.push(e));
      statements.forEach((s) => stmts.push(s));
      tablenames2.forEach((n) => tablenamesSet.add(n));
    };
    const processDDL = async (changes) => {
      const createdTables = /* @__PURE__ */ new Set();
      const affectedTables = /* @__PURE__ */ new Map();
      changes.forEach((change) => {
        const changeStmt = { sql: change.sql };
        stmts.push(changeStmt);
        if (change.migrationType === SatOpMigrate_Type.CREATE_TABLE || change.migrationType === SatOpMigrate_Type.ALTER_ADD_COLUMN) {
          const affectedTable = new QualifiedTablename(
            namespace,
            change.table.name
          ).toString();
          affectedTables.set(affectedTable, change.table);
          tablenamesSet.add(affectedTable);
          if (change.migrationType === SatOpMigrate_Type.CREATE_TABLE) {
            createdTables.add(affectedTable);
          }
        }
      });
      affectedTables.forEach((table) => {
        const triggers = generateTriggersForTable(table, this.builder);
        stmts.push(...triggers);
        txStmts.push(...triggers);
      });
      const createdQualifiedTables = Array.from(createdTables).map(
        QualifiedTablename.parse
      );
      stmts.push(...this._disableTriggers(createdQualifiedTables));
      newTables = /* @__PURE__ */ new Set([...newTables, ...createdTables]);
    };
    await this.maybeGarbageCollect(origin, commitTimestamp);
    for (const [dataChange, chunk] of chunkBy(
      transaction.changes,
      isDataChange
    )) {
      if (dataChange) {
        await processDML(chunk);
      } else {
        await processDDL(chunk);
      }
    }
    const tablenames = Array.from(tablenamesSet);
    const qualifiedTables = tablenames.map(QualifiedTablename.parse);
    const notNewTableNames = tablenames.filter((t) => !newTables.has(t));
    const notNewQualifiedTables = notNewTableNames.map(QualifiedTablename.parse);
    const allStatements = this._disableTriggers(notNewQualifiedTables).concat(stmts).concat(this._enableTriggers(qualifiedTables));
    if (transaction.migrationVersion) {
      await this.migrator.applyIfNotAlready(
        {
          statements: allStatements,
          version: transaction.migrationVersion
        },
        this.fkChecks
      );
    } else {
      await this.runInTransaction(...allStatements);
    }
    this._notifyChanges(opLogEntries, "remote");
  }
  async _applyAdditionalData(data) {
    return this._applySubscriptionData(data.changes, this._lsn, [
      this._addSeenAdditionalDataStmt(data.ref.toString())
    ]);
  }
  async _applyGoneBatch(lsn, subscriptionIds, allGone) {
    const fakeOplogEntries = allGone.map(
      (x) => ({
        namespace: this.builder.defaultNamespace,
        tablename: x.relation.table,
        primaryKey: extractPK(x),
        optype: "GONE",
        // Fields below don't matter here.
        rowid: -1,
        timestamp: "",
        clearTags: ""
      })
    );
    const stmts = this.builder.prepareDeleteBatchedStatements(
      `DELETE FROM ${this.opts.shadowTable} WHERE `,
      ["namespace", "tablename", "primaryKey"],
      fakeOplogEntries,
      this.maxSqlParameters
    );
    const groupedChanges = groupBy(allGone, (x) => x.relation.table);
    const affectedTables = Object.keys(groupedChanges).map(
      (x) => this.builder.makeQT(x)
    );
    for (const [table, gone] of Object.entries(groupedChanges)) {
      if (gone.length === 0)
        continue;
      const fqtn = this.builder.makeQT(table);
      const pkCols = gone[0].relation.columns.filter((x) => x.primaryKey).map((x) => x.name);
      stmts.push(
        ...this.builder.prepareDeleteBatchedStatements(
          `DELETE FROM ${fqtn} WHERE`,
          pkCols,
          gone.map((x) => x.oldRecord),
          this.maxSqlParameters
        )
      );
    }
    await this.runInTransaction(
      this.updateLsnStmt(lsn),
      { sql: this.builder.deferOrDisableFKsForTx },
      ...this._disableTriggers(affectedTables),
      ...stmts,
      ...this._enableTriggers(affectedTables)
    );
    this.subscriptionManager.goneBatchDelivered(subscriptionIds);
    this._notifyChanges(fakeOplogEntries, "remote");
  }
  async maybeGarbageCollect(origin, commitTimestamp) {
    if (origin === this._authState.clientId) {
      await this._garbageCollectOplog(commitTimestamp);
    }
  }
  _disableTriggers(tables) {
    return this._updateTriggerSettings(tables, 0);
  }
  _enableTriggers(tables) {
    return this._updateTriggerSettings(tables, 1);
  }
  _updateTriggerSettings(tables, flag) {
    if (tables.length === 0)
      return [];
    const triggers = `${this.opts.triggersTable}`;
    const namespacesAndTableNames = tables.flatMap((tbl) => [
      tbl.namespace,
      tbl.tablename
    ]);
    const pos = (i2) => this.builder.makePositionalParam(i2);
    let i = 1;
    return [
      {
        sql: `UPDATE ${triggers} SET flag = ${pos(i++)} WHERE ${tables.map((_) => `(namespace = ${pos(i++)} AND tablename = ${pos(i++)})`).join(" OR ")}`,
        args: [flag, ...namespacesAndTableNames]
      }
    ];
  }
  _addSeenGoneBatchStmt(subscriptionIds) {
    const meta = `${this.opts.metaTable}`;
    return {
      sql: `INSERT INTO ${meta} VALUES ('seenGoneBatch', ${this.builder.makePositionalParam(
        1
      )} ON CONFLICT (key) DO UPDATE SET value = ${meta}.value || ',' || excluded.value`,
      args: [subscriptionIds.join(",")]
    };
  }
  _addSeenAdditionalDataStmt(ref) {
    const meta = `${this.opts.metaTable}`;
    const sql = `
      INSERT INTO ${meta} (key, value) VALUES ('seenAdditionalData', ${this.builder.makePositionalParam(
      1
    )})
        ON CONFLICT (key) DO
          UPDATE SET value = ${meta}.value || ',' || excluded.value
    `;
    const args = [ref];
    return { sql, args };
  }
  _resetAllSeenStmt(keys = ["seenAdditionalData", "seenGoneBatch"]) {
    const whereClause = keys.map((_, i) => `key = ${this.builder.makePositionalParam(i + 1)}`).join(" OR ");
    const sql = `UPDATE ${this.opts.metaTable} SET VALUE = '' WHERE ${whereClause}`;
    return { sql, args: keys };
  }
  _setMetaStatement(key, value) {
    const meta = `${this.opts.metaTable}`;
    const pos = (i) => this.builder.makePositionalParam(i);
    const sql = `UPDATE ${meta} SET value = ${pos(1)} WHERE key = ${pos(2)}`;
    const args = [value, key];
    return { sql, args };
  }
  async _setMeta(key, value) {
    const stmt = this._setMetaStatement(key, value);
    await this.adapter.run(stmt);
  }
  async _getMeta(key) {
    const meta = `${this.opts.metaTable}`;
    const pos = (i) => this.builder.makePositionalParam(i);
    const sql = `SELECT value from ${meta} WHERE key = ${pos(1)}`;
    const args = [key];
    const rows = await this.adapter.query({ sql, args });
    if (rows.length !== 1) {
      throw `Invalid metadata table: missing ${key}`;
    }
    return rows[0].value;
  }
  async _getClientId() {
    const clientIdKey = "clientId";
    let clientId = await this._getMeta(clientIdKey);
    if (clientId === "") {
      clientId = genUUID();
      await this._setMeta(clientIdKey, clientId);
    }
    return clientId;
  }
  async _getLocalRelations() {
    return inferRelationsFromDb(this.adapter, this.opts, this.builder);
  }
  _generateTag(timestamp) {
    const instanceId = this._authState.clientId;
    return generateTag(instanceId, timestamp);
  }
  async _garbageCollectOplog(commitTimestamp) {
    const isoString = commitTimestamp.toISOString();
    const oplog = `${this.opts.oplogTable}`;
    const pos = (i) => this.builder.makePositionalParam(i);
    await this.adapter.run({
      sql: `DELETE FROM ${oplog} WHERE timestamp = ${pos(1)}`,
      args: [isoString]
    });
  }
  /**
   * Update `this._lsn` to the new value and generate a statement to persist this change
   *
   * @param lsn new LSN value
   * @returns statement to be executed to save the new LSN value in the database
   */
  updateLsnStmt(lsn) {
    this._lsn = lsn;
    return this._setMetaStatement("lsn", base64.fromBytes(lsn));
  }
  setReplicationTransform(tableName, transform) {
    this.client.setReplicationTransform(tableName, transform);
  }
  clearReplicationTransform(tableName) {
    this.client.clearReplicationTransform(tableName);
  }
  _applyDeleteOperation(entryChanges, qualifiedTableName) {
    const pkEntries = Object.entries(entryChanges.primaryKeyCols);
    if (pkEntries.length === 0)
      throw new Error(
        "Can't apply delete operation. None of the columns in changes are marked as PK."
      );
    let i = 1;
    const pos = (i2) => this.builder.makePositionalParam(i2);
    const params = pkEntries.reduce(
      (acc, [column, value]) => {
        acc.where.push(`${column} = ${pos(i++)}`);
        acc.values.push(value);
        return acc;
      },
      { where: [], values: [] }
    );
    return {
      sql: `DELETE FROM "${qualifiedTableName.namespace}"."${qualifiedTableName.tablename}" WHERE ${params.where.join(" AND ")}`,
      args: params.values
    };
  }
  _applyNonDeleteOperation({ fullRow, primaryKeyCols }, qualifiedTableName) {
    const columnNames = Object.keys(fullRow);
    const columnValues = Object.values(fullRow);
    const updateColumnStmts = columnNames.filter((c) => !(c in primaryKeyCols));
    if (updateColumnStmts.length > 0) {
      return this.builder.insertOrReplaceWith(
        qualifiedTableName,
        columnNames,
        columnValues,
        Object.keys(primaryKeyCols),
        updateColumnStmts,
        updateColumnStmts.map((col) => fullRow[col])
      );
    }
    return this.builder.insertOrIgnore(
      qualifiedTableName,
      columnNames,
      columnValues
    );
  }
  async checkMaxSqlParameters() {
    if (this.builder.dialect === "SQLite") {
      const [{ version }] = await this.adapter.query({
        sql: "SELECT sqlite_version() AS version"
      });
      const [major, minor, _patch] = version.split(".").map((x) => parseInt(x));
      if (major === 3 && minor >= 32)
        this.maxSqlParameters = 32766;
      else
        this.maxSqlParameters = 999;
    } else {
      this.maxSqlParameters = 65535;
    }
  }
}
function generateTriggersForTable(tbl, builder) {
  const table = {
    qualifiedTableName: new QualifiedTablename(
      builder.defaultNamespace,
      tbl.name
    ),
    columns: tbl.columns.map((col) => col.name),
    primary: tbl.pks,
    foreignKeys: tbl.fks.map((fk) => {
      if (fk.fkCols.length !== 1 || fk.pkCols.length !== 1)
        throw new Error("Satellite does not yet support compound foreign keys.");
      return {
        table: fk.pkTable,
        childKey: fk.fkCols[0],
        parentKey: fk.pkCols[0]
      };
    }),
    columnTypes: Object.fromEntries(
      tbl.columns.map((col) => [col.name, col.pgType.name.toUpperCase()])
    )
  };
  return generateTableTriggers(table, builder);
}
export {
  SatelliteProcess,
  generateTriggersForTable
};
//# sourceMappingURL=process.js.map