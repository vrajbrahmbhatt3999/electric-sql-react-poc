{"version":3,"sources":["../../src/satellite/oplog.ts"],"sourcesContent":["import Long from 'long'\nimport { QualifiedTablename } from '../util/tablename'\nimport {\n  DataChangeType,\n  RelationsCache,\n  Row,\n  SqlValue,\n  DataTransaction,\n  DataChange,\n  DbRecord as Rec,\n  Relation,\n} from '../util/types'\nimport { union } from '../util/sets'\nimport {\n  numberToBytes,\n  blobToHexString,\n  hexStringToBlob,\n} from '../util/encoders'\n\n// format: UUID@timestamp_in_milliseconds\nexport type Timestamp = string\nexport type Tag = string\n\nexport type ShadowKey = string\n\n// Oplog table schema.\nexport interface OplogEntry {\n  namespace: string\n  tablename: string\n  primaryKey: string // json object\n  rowid: number\n  optype: OpType\n  timestamp: string // ISO string\n  newRow?: string // json object if present\n  oldRow?: string // json object if present\n  clearTags: string // json object if present\n}\n\n// Representation of a change operation.\nexport interface OplogEntryChanges {\n  namespace: string\n  tablename: string\n  primaryKeyCols: {\n    [key: string]: string | number\n  }\n  optype: ChangesOpType\n  changes: OplogColumnChanges\n  tag: Tag | null\n  clearTags: Tag[]\n}\n\nexport interface ShadowEntryChanges {\n  namespace: string\n  tablename: string\n  primaryKeyCols: {\n    [key: string]: string | number\n  }\n  optype: ChangesOpType\n  changes: OplogColumnChanges\n  fullRow: Row\n  tags: Tag[]\n}\n\nexport interface OplogColumnChanges {\n  [columnName: string]: {\n    value: SqlValue\n    timestamp: number // ms since epoch\n  }\n}\n\nexport interface OplogTableChanges {\n  [qualifiedTablenameStr: string]: {\n    [primaryKey: string]: [Timestamp, OplogEntryChanges]\n  }\n}\n\nexport interface PendingChanges {\n  [qualifiedTablenameStr: string]: {\n    [primaryKey: string]: ShadowEntryChanges\n  }\n}\n\nexport type OpType = 'DELETE' | 'INSERT' | 'UPDATE' | 'COMPENSATION' | 'GONE'\n\nexport type ChangesOpType = 'DELETE' | 'UPSERT' | 'GONE'\n\nexport const OPTYPES: {\n  insert: 'INSERT'\n  update: 'UPDATE'\n  delete: 'DELETE'\n  upsert: 'UPSERT'\n  compensation: 'COMPENSATION'\n  gone: 'GONE'\n} = {\n  insert: 'INSERT',\n  update: 'UPDATE',\n  delete: 'DELETE',\n  upsert: 'UPSERT',\n  compensation: 'COMPENSATION',\n  gone: 'GONE',\n}\n\nexport interface ShadowEntry {\n  namespace: string\n  tablename: string\n  primaryKey: string\n  tags: string // json object\n}\n\nexport const shadowTagsDefault = '[]'\n\nexport const stringToOpType = (opTypeStr: string): OpType => {\n  switch (opTypeStr) {\n    case 'INSERT':\n      return OPTYPES.insert\n    case 'UPDATE':\n      return OPTYPES.update\n    case 'DELETE':\n      return OPTYPES.delete\n    case 'COMPENSATION':\n      return OPTYPES.compensation\n    case 'GONE':\n      return OPTYPES.gone\n  }\n  throw new Error(`unexpected opType string: ${opTypeStr}`)\n}\n\n// Convert an `OplogEntry` to an `OplogEntryChanges` structure,\n// parsing out the changed columns from the oldRow and the newRow.\nexport const localEntryToChanges = (\n  entry: OplogEntry,\n  tag: Tag,\n  relations: RelationsCache\n): OplogEntryChanges => {\n  const relation = relations[entry.tablename]\n\n  const result: OplogEntryChanges = {\n    namespace: entry.namespace,\n    tablename: entry.tablename,\n    primaryKeyCols: deserialiseRow(entry.primaryKey, relation) as Record<\n      string,\n      string | number\n    >,\n    optype: entry.optype === OPTYPES.delete ? OPTYPES.delete : OPTYPES.upsert,\n    changes: {},\n    tag: entry.optype === OPTYPES.delete ? null : tag,\n    clearTags: decodeTags(entry.clearTags),\n  }\n\n  const oldRow: Row = entry.oldRow\n    ? (deserialiseRow(entry.oldRow, relation) as Row)\n    : {}\n  const newRow: Row = entry.newRow\n    ? (deserialiseRow(entry.newRow, relation) as Row)\n    : {}\n\n  const timestamp = new Date(entry.timestamp).getTime()\n\n  for (const [key, value] of Object.entries(newRow)) {\n    if (oldRow[key] !== value) {\n      result.changes[key] = { value, timestamp }\n    }\n  }\n\n  return result\n}\n\n// Convert an `OplogEntry` to a `ShadowEntryChanges` structure,\n// parsing out the changed columns from the oldRow and the newRow.\nexport const remoteEntryToChanges = (\n  entry: OplogEntry,\n  relations: RelationsCache\n): ShadowEntryChanges => {\n  const relation = relations[entry.tablename]\n  const oldRow: Row = entry.oldRow\n    ? (deserialiseRow(entry.oldRow, relation) as Row)\n    : {}\n  const newRow: Row = entry.newRow\n    ? (deserialiseRow(entry.newRow, relation) as Row)\n    : {}\n\n  const result: ShadowEntryChanges = {\n    namespace: entry.namespace,\n    tablename: entry.tablename,\n    primaryKeyCols: deserialiseRow(entry.primaryKey, relation) as Record<\n      string,\n      string | number\n    >,\n    optype: optypeToShadow(entry.optype),\n    changes: {},\n    // if it is a delete, then `newRow` is empty so the full row is the old row\n    fullRow: entry.optype === OPTYPES.delete ? oldRow : newRow,\n    tags: decodeTags(entry.clearTags),\n  }\n\n  const timestamp = new Date(entry.timestamp).getTime()\n\n  for (const [key, value] of Object.entries(newRow)) {\n    if (oldRow[key] !== value) {\n      result.changes[key] = { value, timestamp }\n    }\n  }\n\n  return result\n}\n\nfunction optypeToShadow(optype: OpType): ChangesOpType {\n  switch (optype) {\n    case 'DELETE':\n      return 'DELETE'\n    case 'GONE':\n      return 'GONE'\n    case 'INSERT':\n    case 'UPDATE':\n      return 'UPSERT'\n    default:\n      throw new Error(`Unexpected optype: ${optype}`)\n  }\n}\n\n/**\n * Convert a list of `OplogEntry`s into a nested `OplogTableChanges` map of\n * `{tableName: {primaryKey: entryChanges}}` where the entryChanges has the\n * most recent `optype` and column `value` from all of the operations.\n * Multiple OplogEntries that point to the same row will be merged to a\n * single OpLogEntryChanges object.\n *\n * @param operations Array of local oplog entries.\n * @param genTag Function that generates a tag from a timestamp.\n * @returns An object of oplog table changes.\n */\nexport const localOperationsToTableChanges = (\n  operations: OplogEntry[],\n  genTag: (timestamp: Date) => Tag,\n  relations: RelationsCache\n): OplogTableChanges => {\n  const initialValue: OplogTableChanges = {}\n\n  return operations.reduce((acc, entry) => {\n    const entryChanges = localEntryToChanges(\n      entry,\n      genTag(new Date(entry.timestamp)),\n      relations\n    )\n\n    // Sort for deterministic key generation.\n    const primaryKeyStr = primaryKeyToStr(entryChanges.primaryKeyCols)\n    const qualifiedTablename = new QualifiedTablename(\n      entryChanges.namespace,\n      entryChanges.tablename\n    )\n    const tablenameStr = qualifiedTablename.toString()\n\n    if (acc[tablenameStr] === undefined) {\n      acc[tablenameStr] = {}\n    }\n\n    if (acc[tablenameStr][primaryKeyStr] === undefined) {\n      acc[tablenameStr][primaryKeyStr] = [entry.timestamp, entryChanges]\n    } else {\n      const [timestamp, existing] = acc[tablenameStr][primaryKeyStr]\n      existing.optype = entryChanges.optype\n      for (const [key, value] of Object.entries(entryChanges.changes)) {\n        existing.changes[key] = value\n      }\n      if (entryChanges.optype === 'DELETE') {\n        existing.tag = null\n      } else {\n        existing.tag = genTag(new Date(entry.timestamp))\n      }\n\n      if (timestamp === entry.timestamp) {\n        // within the same transaction overwirte\n        existing.clearTags = entryChanges.clearTags\n      } else {\n        existing.clearTags = union(entryChanges.clearTags, existing.clearTags)\n      }\n    }\n\n    return acc\n  }, initialValue)\n}\n\nexport const remoteOperationsToTableChanges = (\n  operations: OplogEntry[],\n  relations: RelationsCache\n): PendingChanges => {\n  const initialValue: PendingChanges = {}\n\n  return operations.reduce((acc, entry) => {\n    const entryChanges = remoteEntryToChanges(entry, relations)\n\n    // Sort for deterministic key generation.\n    const primaryKeyStr = primaryKeyToStr(entryChanges.primaryKeyCols)\n    const qualifiedTablename = new QualifiedTablename(\n      entryChanges.namespace,\n      entryChanges.tablename\n    )\n    const tablenameStr = qualifiedTablename.toString()\n\n    if (acc[tablenameStr] === undefined) {\n      acc[tablenameStr] = {}\n    }\n    if (acc[tablenameStr][primaryKeyStr] === undefined) {\n      acc[tablenameStr][primaryKeyStr] = entryChanges\n    } else {\n      const existing = acc[tablenameStr][primaryKeyStr]\n      existing.optype = entryChanges.optype\n      for (const [key, value] of Object.entries(entryChanges.changes)) {\n        existing.changes[key] = value\n        existing.fullRow[key] = value.value\n      }\n    }\n\n    return acc\n  }, initialValue)\n}\n\n/**\n * Serialises a row that is represented by a record.\n * `NaN`, `+Inf`, and `-Inf` are transformed to their string equivalent.\n * Bytestrings are encoded as hex strings\n * @param record The row to serialise.\n */\nfunction serialiseRow(row?: Rec): string {\n  return JSON.stringify(row, (_key, value) => {\n    if (typeof value === 'number') {\n      if (Number.isNaN(value)) {\n        return 'NaN'\n      } else if (value === Infinity) {\n        return 'Inf'\n      } else if (value === -Infinity) {\n        return '-Inf'\n      }\n    }\n    if (typeof value === 'bigint') {\n      return value.toString()\n    }\n\n    if (value instanceof Uint8Array) {\n      return blobToHexString(value)\n    }\n    return value\n  })\n}\n\n/**\n * Deserialises a row back into a record.\n * `\"NaN\"`, `\"+Inf\"`, and `\"-Inf\"` are transformed back into their numeric equivalent\n * if the column type is a float.\n * Hex encoded bytestrings are transformed back to `Uint8Array` instances\n * @param str The row to deserialise.\n * @param rel The relation for the table to which this row belongs.\n */\nfunction deserialiseRow(str: string, rel: Pick<Relation, 'columns'>): Rec {\n  return JSON.parse(str, (key, value) => {\n    if (value === null) return null\n\n    const columnType = rel.columns\n      .find((c) => c.name === key)\n      ?.type?.toUpperCase()\n    if (\n      (columnType === 'FLOAT4' ||\n        columnType === 'FLOAT8' ||\n        columnType === 'REAL') &&\n      typeof value === 'string'\n    ) {\n      if (value === 'NaN') {\n        return NaN\n      } else if (value === 'Inf') {\n        return Infinity\n      } else if (value === '-Inf') {\n        return -Infinity\n      } else {\n        return Number(value)\n      }\n    }\n    if (columnType === 'INT8' || columnType === 'BIGINT') {\n      return BigInt(value)\n    }\n    if (\n      (columnType === 'BYTEA' || columnType === 'BLOB') &&\n      typeof value === 'string'\n    ) {\n      return hexStringToBlob(value)\n    }\n\n    return value\n  })\n}\n\nexport function extractPK(c: DataChange) {\n  const columnValues = c.record ? c.record : c.oldRecord!\n\n  return primaryKeyToStr(\n    c.relation.columns\n      .filter((c) => c.primaryKey)\n      .reduce((primaryKeyRec, col) => {\n        primaryKeyRec[col.name] = columnValues[col.name]!\n        return primaryKeyRec\n      }, {} as Record<string, boolean | string | number | Uint8Array>)\n  )\n}\n\nexport const fromTransaction = (\n  transaction: DataTransaction,\n  _relations: RelationsCache,\n  namespace: string\n): OplogEntry[] => {\n  return transaction.changes.map((t) => {\n    return {\n      namespace,\n      tablename: t.relation.table,\n      optype: stringToOpType(t.type),\n      newRow: serialiseRow(t.record),\n      oldRow: serialiseRow(t.oldRecord),\n      primaryKey: extractPK(t),\n      rowid: -1, // not required\n      timestamp: new Date(\n        transaction.commit_timestamp.toNumber()\n      ).toISOString(), // TODO: check precision\n      clearTags: encodeTags(t.tags),\n    }\n  })\n}\n\nexport const toTransactions = (\n  opLogEntries: OplogEntry[],\n  relations: RelationsCache\n): DataTransaction[] => {\n  if (opLogEntries.length === 0) {\n    return []\n  }\n\n  const to_commit_timestamp = (timestamp: string): Long =>\n    Long.UZERO.add(new Date(timestamp).getTime())\n\n  const init: DataTransaction = {\n    commit_timestamp: to_commit_timestamp(opLogEntries[0].timestamp),\n    lsn: numberToBytes(opLogEntries[0].rowid),\n    changes: [],\n  }\n\n  return opLogEntries.reduce(\n    (acc, txn) => {\n      let currTxn = acc[acc.length - 1]\n\n      const nextTs = to_commit_timestamp(txn.timestamp)\n      if (nextTs.notEquals(currTxn.commit_timestamp as Long)) {\n        const nextTxn = {\n          commit_timestamp: to_commit_timestamp(txn.timestamp),\n          lsn: numberToBytes(txn.rowid),\n          changes: [],\n        }\n        acc.push(nextTxn)\n        currTxn = nextTxn\n      }\n\n      const change = opLogEntryToChange(txn, relations)\n      currTxn.changes.push(change)\n      currTxn.lsn = numberToBytes(txn.rowid)\n      return acc\n    },\n    [init]\n  )\n}\n\nexport const getShadowPrimaryKey = (\n  oplogEntry: OplogEntry | OplogEntryChanges | ShadowEntryChanges\n): ShadowKey => {\n  if ('primaryKey' in oplogEntry) {\n    return oplogEntry.primaryKey\n  } else {\n    return primaryKeyToStr(oplogEntry.primaryKeyCols)\n  }\n}\n\nexport const encodeTags = (tags: Tag[]): string => {\n  return JSON.stringify(tags)\n}\n\nexport const decodeTags = (tags: string): Tag[] => {\n  return JSON.parse(tags)\n}\n\nexport const opLogEntryToChange = (\n  entry: OplogEntry,\n  relations: RelationsCache\n): DataChange => {\n  const relation = relations[`${entry.tablename}`]\n\n  let record, oldRecord\n  if (typeof entry.newRow === 'string') {\n    record = deserialiseRow(entry.newRow, relation)\n  }\n\n  if (typeof entry.oldRow === 'string') {\n    oldRecord = deserialiseRow(entry.oldRow, relation)\n  }\n\n  if (typeof relation === 'undefined') {\n    throw new Error(`Could not find relation for ${entry.tablename}`)\n  }\n\n  return {\n    type: entry.optype as DataChangeType,\n    relation: relation,\n    record,\n    oldRecord,\n    tags: decodeTags(entry.clearTags),\n  }\n}\n\n/**\n * Convert a primary key to a string the same way our triggers do when generating oplog entries.\n *\n * Takes the object that contains the primary key and serializes it to JSON in a non-prettified\n * way with column sorting.\n *\n * @param primaryKeyObj object representing all columns of a primary key\n * @returns a stringified JSON with stable sorting on column names\n */\nexport const primaryKeyToStr = <\n  T extends Record<string, boolean | string | number | Uint8Array>\n>(\n  primaryKeyObj: T\n): string => {\n  // Sort the keys then insert them in order in a fresh object\n  // cf. https://stackoverflow.com/questions/5467129/sort-javascript-object-by-key\n\n  // TODO: it probably makes more sense to sort the PK object by actual PK order\n  const keys: Array<keyof T> = Object.keys(primaryKeyObj).sort()\n  const sortedObj = keys.reduce((obj, key) => {\n    obj[key] = primaryKeyObj[key]\n    return obj\n  }, {} as T)\n\n  return serialiseRow(sortedObj)\n}\n\nexport const generateTag = (\n  instanceId: string,\n  timestamp: Date | number\n): Tag => {\n  const milliseconds =\n    typeof timestamp === 'number' ? timestamp : timestamp.getTime()\n  return instanceId + '@' + milliseconds.toString()\n}\n"],"mappings":"AAAA,OAAO,UAAU;AACjB,SAAS,0BAA0B;AAWnC,SAAS,aAAa;AACtB;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAqEA,MAAM,UAOT;AAAA,EACF,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,cAAc;AAAA,EACd,MAAM;AACR;AASO,MAAM,oBAAoB;AAE1B,MAAM,iBAAiB,CAAC,cAA8B;AAC3D,UAAQ,WAAW;AAAA,IACjB,KAAK;AACH,aAAO,QAAQ;AAAA,IACjB,KAAK;AACH,aAAO,QAAQ;AAAA,IACjB,KAAK;AACH,aAAO,QAAQ;AAAA,IACjB,KAAK;AACH,aAAO,QAAQ;AAAA,IACjB,KAAK;AACH,aAAO,QAAQ;AAAA,EACnB;AACA,QAAM,IAAI,MAAM,6BAA6B,SAAS,EAAE;AAC1D;AAIO,MAAM,sBAAsB,CACjC,OACA,KACA,cACsB;AACtB,QAAM,WAAW,UAAU,MAAM,SAAS;AAE1C,QAAM,SAA4B;AAAA,IAChC,WAAW,MAAM;AAAA,IACjB,WAAW,MAAM;AAAA,IACjB,gBAAgB,eAAe,MAAM,YAAY,QAAQ;AAAA,IAIzD,QAAQ,MAAM,WAAW,QAAQ,SAAS,QAAQ,SAAS,QAAQ;AAAA,IACnE,SAAS,CAAC;AAAA,IACV,KAAK,MAAM,WAAW,QAAQ,SAAS,OAAO;AAAA,IAC9C,WAAW,WAAW,MAAM,SAAS;AAAA,EACvC;AAEA,QAAM,SAAc,MAAM,SACrB,eAAe,MAAM,QAAQ,QAAQ,IACtC,CAAC;AACL,QAAM,SAAc,MAAM,SACrB,eAAe,MAAM,QAAQ,QAAQ,IACtC,CAAC;AAEL,QAAM,YAAY,IAAI,KAAK,MAAM,SAAS,EAAE,QAAQ;AAEpD,aAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,MAAM,GAAG;AACjD,QAAI,OAAO,GAAG,MAAM,OAAO;AACzB,aAAO,QAAQ,GAAG,IAAI,EAAE,OAAO,UAAU;AAAA,IAC3C;AAAA,EACF;AAEA,SAAO;AACT;AAIO,MAAM,uBAAuB,CAClC,OACA,cACuB;AACvB,QAAM,WAAW,UAAU,MAAM,SAAS;AAC1C,QAAM,SAAc,MAAM,SACrB,eAAe,MAAM,QAAQ,QAAQ,IACtC,CAAC;AACL,QAAM,SAAc,MAAM,SACrB,eAAe,MAAM,QAAQ,QAAQ,IACtC,CAAC;AAEL,QAAM,SAA6B;AAAA,IACjC,WAAW,MAAM;AAAA,IACjB,WAAW,MAAM;AAAA,IACjB,gBAAgB,eAAe,MAAM,YAAY,QAAQ;AAAA,IAIzD,QAAQ,eAAe,MAAM,MAAM;AAAA,IACnC,SAAS,CAAC;AAAA;AAAA,IAEV,SAAS,MAAM,WAAW,QAAQ,SAAS,SAAS;AAAA,IACpD,MAAM,WAAW,MAAM,SAAS;AAAA,EAClC;AAEA,QAAM,YAAY,IAAI,KAAK,MAAM,SAAS,EAAE,QAAQ;AAEpD,aAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,MAAM,GAAG;AACjD,QAAI,OAAO,GAAG,MAAM,OAAO;AACzB,aAAO,QAAQ,GAAG,IAAI,EAAE,OAAO,UAAU;AAAA,IAC3C;AAAA,EACF;AAEA,SAAO;AACT;AAEA,SAAS,eAAe,QAA+B;AACrD,UAAQ,QAAQ;AAAA,IACd,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AAAA,IACL,KAAK;AACH,aAAO;AAAA,IACT;AACE,YAAM,IAAI,MAAM,sBAAsB,MAAM,EAAE;AAAA,EAClD;AACF;AAaO,MAAM,gCAAgC,CAC3C,YACA,QACA,cACsB;AACtB,QAAM,eAAkC,CAAC;AAEzC,SAAO,WAAW,OAAO,CAAC,KAAK,UAAU;AACvC,UAAM,eAAe;AAAA,MACnB;AAAA,MACA,OAAO,IAAI,KAAK,MAAM,SAAS,CAAC;AAAA,MAChC;AAAA,IACF;AAGA,UAAM,gBAAgB,gBAAgB,aAAa,cAAc;AACjE,UAAM,qBAAqB,IAAI;AAAA,MAC7B,aAAa;AAAA,MACb,aAAa;AAAA,IACf;AACA,UAAM,eAAe,mBAAmB,SAAS;AAEjD,QAAI,IAAI,YAAY,MAAM,QAAW;AACnC,UAAI,YAAY,IAAI,CAAC;AAAA,IACvB;AAEA,QAAI,IAAI,YAAY,EAAE,aAAa,MAAM,QAAW;AAClD,UAAI,YAAY,EAAE,aAAa,IAAI,CAAC,MAAM,WAAW,YAAY;AAAA,IACnE,OAAO;AACL,YAAM,CAAC,WAAW,QAAQ,IAAI,IAAI,YAAY,EAAE,aAAa;AAC7D,eAAS,SAAS,aAAa;AAC/B,iBAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,aAAa,OAAO,GAAG;AAC/D,iBAAS,QAAQ,GAAG,IAAI;AAAA,MAC1B;AACA,UAAI,aAAa,WAAW,UAAU;AACpC,iBAAS,MAAM;AAAA,MACjB,OAAO;AACL,iBAAS,MAAM,OAAO,IAAI,KAAK,MAAM,SAAS,CAAC;AAAA,MACjD;AAEA,UAAI,cAAc,MAAM,WAAW;AAEjC,iBAAS,YAAY,aAAa;AAAA,MACpC,OAAO;AACL,iBAAS,YAAY,MAAM,aAAa,WAAW,SAAS,SAAS;AAAA,MACvE;AAAA,IACF;AAEA,WAAO;AAAA,EACT,GAAG,YAAY;AACjB;AAEO,MAAM,iCAAiC,CAC5C,YACA,cACmB;AACnB,QAAM,eAA+B,CAAC;AAEtC,SAAO,WAAW,OAAO,CAAC,KAAK,UAAU;AACvC,UAAM,eAAe,qBAAqB,OAAO,SAAS;AAG1D,UAAM,gBAAgB,gBAAgB,aAAa,cAAc;AACjE,UAAM,qBAAqB,IAAI;AAAA,MAC7B,aAAa;AAAA,MACb,aAAa;AAAA,IACf;AACA,UAAM,eAAe,mBAAmB,SAAS;AAEjD,QAAI,IAAI,YAAY,MAAM,QAAW;AACnC,UAAI,YAAY,IAAI,CAAC;AAAA,IACvB;AACA,QAAI,IAAI,YAAY,EAAE,aAAa,MAAM,QAAW;AAClD,UAAI,YAAY,EAAE,aAAa,IAAI;AAAA,IACrC,OAAO;AACL,YAAM,WAAW,IAAI,YAAY,EAAE,aAAa;AAChD,eAAS,SAAS,aAAa;AAC/B,iBAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,aAAa,OAAO,GAAG;AAC/D,iBAAS,QAAQ,GAAG,IAAI;AACxB,iBAAS,QAAQ,GAAG,IAAI,MAAM;AAAA,MAChC;AAAA,IACF;AAEA,WAAO;AAAA,EACT,GAAG,YAAY;AACjB;AAQA,SAAS,aAAa,KAAmB;AACvC,SAAO,KAAK,UAAU,KAAK,CAAC,MAAM,UAAU;AAC1C,QAAI,OAAO,UAAU,UAAU;AAC7B,UAAI,OAAO,MAAM,KAAK,GAAG;AACvB,eAAO;AAAA,MACT,WAAW,UAAU,UAAU;AAC7B,eAAO;AAAA,MACT,WAAW,UAAU,WAAW;AAC9B,eAAO;AAAA,MACT;AAAA,IACF;AACA,QAAI,OAAO,UAAU,UAAU;AAC7B,aAAO,MAAM,SAAS;AAAA,IACxB;AAEA,QAAI,iBAAiB,YAAY;AAC/B,aAAO,gBAAgB,KAAK;AAAA,IAC9B;AACA,WAAO;AAAA,EACT,CAAC;AACH;AAUA,SAAS,eAAe,KAAa,KAAqC;AACxE,SAAO,KAAK,MAAM,KAAK,CAAC,KAAK,UAAU;AACrC,QAAI,UAAU;AAAM,aAAO;AAE3B,UAAM,aAAa,IAAI,QACpB,KAAK,CAAC,MAAM,EAAE,SAAS,GAAG,GACzB,MAAM,YAAY;AACtB,SACG,eAAe,YACd,eAAe,YACf,eAAe,WACjB,OAAO,UAAU,UACjB;AACA,UAAI,UAAU,OAAO;AACnB,eAAO;AAAA,MACT,WAAW,UAAU,OAAO;AAC1B,eAAO;AAAA,MACT,WAAW,UAAU,QAAQ;AAC3B,eAAO;AAAA,MACT,OAAO;AACL,eAAO,OAAO,KAAK;AAAA,MACrB;AAAA,IACF;AACA,QAAI,eAAe,UAAU,eAAe,UAAU;AACpD,aAAO,OAAO,KAAK;AAAA,IACrB;AACA,SACG,eAAe,WAAW,eAAe,WAC1C,OAAO,UAAU,UACjB;AACA,aAAO,gBAAgB,KAAK;AAAA,IAC9B;AAEA,WAAO;AAAA,EACT,CAAC;AACH;AAEO,SAAS,UAAU,GAAe;AACvC,QAAM,eAAe,EAAE,SAAS,EAAE,SAAS,EAAE;AAE7C,SAAO;AAAA,IACL,EAAE,SAAS,QACR,OAAO,CAACA,OAAMA,GAAE,UAAU,EAC1B,OAAO,CAAC,eAAe,QAAQ;AAC9B,oBAAc,IAAI,IAAI,IAAI,aAAa,IAAI,IAAI;AAC/C,aAAO;AAAA,IACT,GAAG,CAAC,CAA2D;AAAA,EACnE;AACF;AAEO,MAAM,kBAAkB,CAC7B,aACA,YACA,cACiB;AACjB,SAAO,YAAY,QAAQ,IAAI,CAAC,MAAM;AACpC,WAAO;AAAA,MACL;AAAA,MACA,WAAW,EAAE,SAAS;AAAA,MACtB,QAAQ,eAAe,EAAE,IAAI;AAAA,MAC7B,QAAQ,aAAa,EAAE,MAAM;AAAA,MAC7B,QAAQ,aAAa,EAAE,SAAS;AAAA,MAChC,YAAY,UAAU,CAAC;AAAA,MACvB,OAAO;AAAA;AAAA,MACP,WAAW,IAAI;AAAA,QACb,YAAY,iBAAiB,SAAS;AAAA,MACxC,EAAE,YAAY;AAAA;AAAA,MACd,WAAW,WAAW,EAAE,IAAI;AAAA,IAC9B;AAAA,EACF,CAAC;AACH;AAEO,MAAM,iBAAiB,CAC5B,cACA,cACsB;AACtB,MAAI,aAAa,WAAW,GAAG;AAC7B,WAAO,CAAC;AAAA,EACV;AAEA,QAAM,sBAAsB,CAAC,cAC3B,KAAK,MAAM,IAAI,IAAI,KAAK,SAAS,EAAE,QAAQ,CAAC;AAE9C,QAAM,OAAwB;AAAA,IAC5B,kBAAkB,oBAAoB,aAAa,CAAC,EAAE,SAAS;AAAA,IAC/D,KAAK,cAAc,aAAa,CAAC,EAAE,KAAK;AAAA,IACxC,SAAS,CAAC;AAAA,EACZ;AAEA,SAAO,aAAa;AAAA,IAClB,CAAC,KAAK,QAAQ;AACZ,UAAI,UAAU,IAAI,IAAI,SAAS,CAAC;AAEhC,YAAM,SAAS,oBAAoB,IAAI,SAAS;AAChD,UAAI,OAAO,UAAU,QAAQ,gBAAwB,GAAG;AACtD,cAAM,UAAU;AAAA,UACd,kBAAkB,oBAAoB,IAAI,SAAS;AAAA,UACnD,KAAK,cAAc,IAAI,KAAK;AAAA,UAC5B,SAAS,CAAC;AAAA,QACZ;AACA,YAAI,KAAK,OAAO;AAChB,kBAAU;AAAA,MACZ;AAEA,YAAM,SAAS,mBAAmB,KAAK,SAAS;AAChD,cAAQ,QAAQ,KAAK,MAAM;AAC3B,cAAQ,MAAM,cAAc,IAAI,KAAK;AACrC,aAAO;AAAA,IACT;AAAA,IACA,CAAC,IAAI;AAAA,EACP;AACF;AAEO,MAAM,sBAAsB,CACjC,eACc;AACd,MAAI,gBAAgB,YAAY;AAC9B,WAAO,WAAW;AAAA,EACpB,OAAO;AACL,WAAO,gBAAgB,WAAW,cAAc;AAAA,EAClD;AACF;AAEO,MAAM,aAAa,CAAC,SAAwB;AACjD,SAAO,KAAK,UAAU,IAAI;AAC5B;AAEO,MAAM,aAAa,CAAC,SAAwB;AACjD,SAAO,KAAK,MAAM,IAAI;AACxB;AAEO,MAAM,qBAAqB,CAChC,OACA,cACe;AACf,QAAM,WAAW,UAAU,GAAG,MAAM,SAAS,EAAE;AAE/C,MAAI,QAAQ;AACZ,MAAI,OAAO,MAAM,WAAW,UAAU;AACpC,aAAS,eAAe,MAAM,QAAQ,QAAQ;AAAA,EAChD;AAEA,MAAI,OAAO,MAAM,WAAW,UAAU;AACpC,gBAAY,eAAe,MAAM,QAAQ,QAAQ;AAAA,EACnD;AAEA,MAAI,OAAO,aAAa,aAAa;AACnC,UAAM,IAAI,MAAM,+BAA+B,MAAM,SAAS,EAAE;AAAA,EAClE;AAEA,SAAO;AAAA,IACL,MAAM,MAAM;AAAA,IACZ;AAAA,IACA;AAAA,IACA;AAAA,IACA,MAAM,WAAW,MAAM,SAAS;AAAA,EAClC;AACF;AAWO,MAAM,kBAAkB,CAG7B,kBACW;AAKX,QAAM,OAAuB,OAAO,KAAK,aAAa,EAAE,KAAK;AAC7D,QAAM,YAAY,KAAK,OAAO,CAAC,KAAK,QAAQ;AAC1C,QAAI,GAAG,IAAI,cAAc,GAAG;AAC5B,WAAO;AAAA,EACT,GAAG,CAAC,CAAM;AAEV,SAAO,aAAa,SAAS;AAC/B;AAEO,MAAM,cAAc,CACzB,YACA,cACQ;AACR,QAAM,eACJ,OAAO,cAAc,WAAW,YAAY,UAAU,QAAQ;AAChE,SAAO,aAAa,MAAM,aAAa,SAAS;AAClD;","names":["c"]}