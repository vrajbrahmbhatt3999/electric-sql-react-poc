/// <reference types="node" />
import { AuthState } from '../auth/index.js';
import { DatabaseAdapter } from '../electric/adapter.js';
import { Migrator } from '../migrators/index.js';
import { Notifier } from '../notifiers/index.js';
import { AuthResponse, DbName, LSN, SatelliteError, DataTransaction, Relation, RelationsCache, DbRecord as DataRecord, StartReplicationResponse, StopReplicationResponse, OutboundStartedCallback, TransactionCallback, SocketCloseReason, ReplicationStatus, AdditionalDataCallback, ConnectivityState, ReplicatedRowTransformer, GoneBatchCallback, DataGone } from '../util/types.js';
import { ElectricConfig } from '../config/index.js';
import { Client, Satellite } from './index.js';
import { SatelliteOpts, SatelliteOverrides } from './config.js';
import { BaseRegistry } from './registry.js';
import { SocketFactory } from '../sockets/index.js';
import { AsyncEventEmitter, QualifiedTablename } from '../util/index.js';
import { Shape, SUBSCRIPTION_DELIVERED, SUBSCRIPTION_ERROR, ShapeRequest, SubscribeResponse, SubscriptionData, SubscriptionDeliveredCallback, SubscriptionErrorCallback, UnsubscribeResponse } from './shapes/types.js';
import { ShapeSubscription } from './process.js';
import { DbSchema } from '../client/model/schema.js';
import { SyncStatus } from '../client/model/shapes.js';
export declare const MOCK_BEHIND_WINDOW_LSN = 42;
export declare const MOCK_INTERNAL_ERROR = 27;
export declare class MockSatelliteProcess implements Satellite {
    dbName: DbName;
    adapter: DatabaseAdapter;
    migrator: Migrator;
    notifier: Notifier;
    socketFactory: SocketFactory;
    opts: SatelliteOpts;
    token: string | undefined;
    connectivityState?: ConnectivityState;
    constructor(dbName: DbName, adapter: DatabaseAdapter, migrator: Migrator, notifier: Notifier, socketFactory: SocketFactory, opts: SatelliteOpts);
    syncStatus(_key: string): SyncStatus;
    subscribe(_shapeDefinitions: Shape[]): Promise<ShapeSubscription>;
    unsubscribe(_shapeUuid: any): Promise<void>;
    start(): Promise<void>;
    setToken(token: string): void;
    hasToken(): boolean;
    connect(): Promise<void>;
    connectWithBackoff(): Promise<void>;
    disconnect(): void;
    clientDisconnect(): void;
    authenticate(_token: string): Promise<void>;
    stop(): Promise<void>;
    setReplicationTransform(_tableName: QualifiedTablename, _transform: ReplicatedRowTransformer<DataRecord>): void;
    clearReplicationTransform(_tableName: QualifiedTablename): void;
}
export declare class MockRegistry extends BaseRegistry {
    private shouldFailToStart;
    setShouldFailToStart(shouldFail: boolean): void;
    startProcess(dbName: DbName, _dbDescription: DbSchema<any>, adapter: DatabaseAdapter, migrator: Migrator, notifier: Notifier, socketFactory: SocketFactory, _config: ElectricConfig, overrides?: SatelliteOverrides): Promise<Satellite>;
}
type Events = {
    [SUBSCRIPTION_DELIVERED]: (data: SubscriptionData) => void;
    [SUBSCRIPTION_ERROR]: (error: SatelliteError, subscriptionId: string) => void;
    outbound_started: OutboundStartedCallback;
    error: (error: SatelliteError) => void;
    goneBatch: GoneBatchCallback;
};
export declare class MockSatelliteClient extends AsyncEventEmitter<Events> implements Client {
    isDown: boolean;
    replicating: boolean;
    disconnected: boolean;
    inboundAck: Uint8Array;
    outboundSent: Uint8Array;
    outboundTransactionsEnqueued: DataTransaction[];
    timeouts: NodeJS.Timeout[];
    relations: RelationsCache;
    relationsCb?: (relation: Relation) => void;
    transactionsCb?: TransactionCallback;
    additionalDataCb?: AdditionalDataCallback;
    outboundStartedCallback?: OutboundStartedCallback;
    relationData: Record<string, DataRecord[]>;
    goneBatches: Record<string, DataGone[]>;
    deliverFirst: boolean;
    doSkipNextEmit: boolean;
    private startReplicationDelayMs;
    private replicationTransforms;
    setStartReplicationDelayMs(delayMs: number | null): void;
    setRelations(relations: RelationsCache): void;
    setRelationData(tablename: string, record: DataRecord): void;
    setGoneBatch(subscriptionId: string, batch: {
        tablename: string;
        record: DataGone['oldRecord'];
    }[]): void;
    enableDeliverFirst(): void;
    skipNextEmit(): void;
    subscribe(subscriptionId: string, shapes: ShapeRequest[]): Promise<SubscribeResponse>;
    unsubscribe(subIds: string[]): Promise<UnsubscribeResponse>;
    subscribeToSubscriptionEvents(successCallback: SubscriptionDeliveredCallback, errorCallback: SubscriptionErrorCallback): void;
    unsubscribeToSubscriptionEvents(successCallback: SubscriptionDeliveredCallback, errorCallback: SubscriptionErrorCallback): void;
    subscribeToGoneBatch(callback: GoneBatchCallback): void;
    unsubscribeToGoneBatch(callback: GoneBatchCallback): void;
    subscribeToError(cb: (error: SatelliteError) => void): void;
    emitSocketClosedError(ev: SocketCloseReason): void;
    unsubscribeToError(cb: (error: SatelliteError) => void): void;
    isConnected(): boolean;
    getOutboundReplicationStatus(): ReplicationStatus;
    shutdown(): Promise<void>;
    getLastSentLsn(): Uint8Array;
    connect(): Promise<void>;
    disconnect(): Promise<void>;
    authenticate(_authState: AuthState): Promise<AuthResponse>;
    startReplication(lsn: LSN): Promise<StartReplicationResponse>;
    stopReplication(): Promise<StopReplicationResponse>;
    subscribeToRelations(callback: (relation: Relation) => void): void;
    unsubscribeToRelations(): void;
    subscribeToTransactions(callback: TransactionCallback): void;
    unsubscribeToTransactions(): void;
    subscribeToAdditionalData(callback: AdditionalDataCallback): void;
    unsubscribeToAdditionalData(_cb: AdditionalDataCallback): void;
    enqueueTransaction(transaction: DataTransaction): void;
    subscribeToOutboundStarted(callback: OutboundStartedCallback): void;
    unsubscribeToOutboundStarted(): void;
    sendErrorAfterTimeout(subscriptionId: string, timeout: number): void;
    setReplicationTransform(tableName: QualifiedTablename, transform: ReplicatedRowTransformer<DataRecord>): void;
    clearReplicationTransform(tableName: QualifiedTablename): void;
}
export {};
