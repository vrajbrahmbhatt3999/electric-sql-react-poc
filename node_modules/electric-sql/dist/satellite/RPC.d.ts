import { Root, SatErrorResp, SatRpcRequest, SatRpcResponse } from '../_generated/protocol/satellite.js';
import Log, { Logger } from 'loglevel';
import { ClientRpcResponse } from '../util/index.js';
type SenderFn = (msg: SatRpcRequest | SatRpcResponse) => void;
/**
 * Wrapper class that exposes a `request` method for generated RPC services to use.
 *
 * Any `SatRpcResponse` messages should be forwarded to this class to be correctly marked
 * as fulfilled.
 */
export declare class RPC {
    private sender;
    private defaultTimeout;
    private log;
    /** Monotonically increasing request id */
    private nextRequestId;
    /** Known pending requests and the promise resolvers for them */
    private pendingRequests;
    /** Set of request identifiers that had timed out, for better errors */
    private timedOutCalls;
    constructor(sender: SenderFn, defaultTimeout: number, log: Log.Logger);
    /**
     * Perform given RPC method using given message as data.
     *
     * This fulfills unexported generated interface `RPC` in `_generated/protocol/satellite.ts`.
     * The generated service instance expects to pass in an already-encoded message because RPC
     * is assumed to be part of the transport and not the protocol. Service instance also expects
     * to receive a still-encoded response.
     *
     * The details of the RPC contract are available in `.proto` file for the Satellite protocol,
     * but the gist is that there are two special messages in the Satellite protocol: `SatRpcRequest`
     * and `SatRpcResponse` that facilitate the call.
     */
    request(_service: string, method: string, message: Uint8Array): Promise<Uint8Array>;
    /**
     * Handle RPC response, dispatching it to the appropriate listener if relevant
     */
    handleResponse(rpc: SatRpcResponse): void;
    private clearAndDelete;
    private timedOut;
}
/**
 * Build an RPC responder to reply to server-sent RPC requests.
 *
 * The responder function itself just correctly wraps the result or error in
 * a SatRpcResponse object, and then sends it.
 *
 * @param send function to send the response to the server
 * @returns function that builds and sends the RPC response
 */
export declare const rpcRespond: (send: SenderFn) => (req: SatRpcRequest, respOrError: ClientRpcResponse | SatErrorResp) => void;
/**
 * Wrap an RPC service instance to log decoded RPC request & response
 *
 * `proto-ts`-generated server instance passes to and expects to receive from
 * the RPC client an already encoded request/response object. To centrally log the decoded
 * version of the object, we wrap the service with a proxy, logging the yet-decoded request
 * before the function call and already-decoded response from the function return.
 *
 * @param service Service instance to wrap
 * @returns A proxy around the service instance
 */
export declare function withRpcRequestLogging(service: Root, logger: Logger): Root;
export {};
