{"version":3,"sources":["../../src/satellite/process.ts"],"sourcesContent":["import throttle from 'lodash.throttle'\n\nimport {\n  SatOpMigrate_Type,\n  SatRelation_RelationType,\n} from '../_generated/protocol/satellite'\nimport { AuthConfig, AuthState } from '../auth/index'\nimport { DatabaseAdapter } from '../electric/adapter'\nimport { Migrator } from '../migrators/index'\nimport {\n  AuthStateNotification,\n  Change,\n  ChangeOrigin,\n  Notifier,\n  UnsubscribeFunction,\n} from '../notifiers/index'\nimport { Waiter, getWaiter } from '../util/common'\nimport { base64, bytesToNumber } from '../util/encoders'\nimport { QualifiedTablename } from '../util/tablename'\nimport {\n  AdditionalData,\n  ConnectivityState,\n  ConnectivityStatus,\n  DataChange,\n  DbName,\n  LSN,\n  MigrationTable,\n  Relation,\n  RelationsCache,\n  ReplicationStatus,\n  SatelliteError,\n  SatelliteErrorCode,\n  SchemaChange,\n  SqlValue,\n  Statement,\n  Transaction,\n  isDataChange,\n  Uuid,\n  DbRecord as DataRecord,\n  ReplicatedRowTransformer,\n  DataGone,\n  ServerTransaction,\n} from '../util/types'\nimport { SatelliteOpts } from './config'\nimport { Client, Satellite } from './index'\nimport {\n  OPTYPES,\n  OplogEntry,\n  ShadowEntry,\n  ShadowEntryChanges,\n  encodeTags,\n  extractPK,\n  fromTransaction,\n  generateTag,\n  getShadowPrimaryKey,\n  primaryKeyToStr,\n  toTransactions,\n} from './oplog'\n\nimport { Mutex } from 'async-mutex'\nimport Log from 'loglevel'\nimport { generateTableTriggers } from '../migrators/triggers'\nimport { mergeEntries } from './merge'\nimport {\n  Shape,\n  InitialDataChange,\n  SubscribeResponse,\n  SubscriptionData,\n} from './shapes/types'\nimport { backOff } from 'exponential-backoff'\nimport { chunkBy, genUUID } from '../util'\nimport { isFatal, isOutOfSyncError, isThrowable, wrapFatalError } from './error'\nimport { inferRelationsFromDb } from '../util/relations'\nimport { decodeUserIdFromToken } from '../auth/secure'\nimport { InvalidArgumentError } from '../client/validation/errors/invalidArgumentError'\nimport Long from 'long'\nimport { QueryBuilder } from '../migrators/query-builder'\nimport groupBy from 'lodash.groupby'\nimport { ShapeManager } from './shapes/shapeManager'\nimport { SyncStatus } from '../client/model/shapes'\nimport { runInTransaction } from '../util/transactions'\nimport { ForeignKeyChecks } from '../config'\n\ntype ChangeAccumulator = {\n  [key: string]: Change\n}\n\nexport type ShapeSubscription = {\n  key: string\n  synced: Promise<void>\n}\n\ntype ThrottleFunction = {\n  cancel: () => void\n  (): Promise<Date> | undefined\n}\n\ntype MetaEntries = {\n  clientId: Uuid | ''\n  compensations: number\n  lsn: string | null\n  subscriptions: string\n  seenAdditionalData: string\n  seenGoneBatch: string\n}\n\ntype ConnectRetryHandler = (error: Error, attempt: number) => boolean\nconst connectRetryHandler: ConnectRetryHandler = (error) => {\n  if (\n    !(error instanceof SatelliteError) ||\n    isThrowable(error) ||\n    isFatal(error)\n  ) {\n    Log.debug(`connectAndStartRetryHandler was cancelled: ${error.message}`)\n    return false\n  }\n  return true\n}\n\nexport class SatelliteProcess implements Satellite {\n  dbName: DbName\n  adapter: DatabaseAdapter\n  migrator: Migrator\n  notifier: Notifier\n  client: Client\n  builder: QueryBuilder\n\n  opts: SatelliteOpts\n  fkChecks: ForeignKeyChecks\n\n  _authState?: AuthState\n  _unsubscribeFromAuthState?: UnsubscribeFunction\n\n  connectivityState?: ConnectivityState\n  _unsubscribeFromConnectivityChanges?: UnsubscribeFunction\n\n  _pollingInterval?: any\n  _unsubscribeFromPotentialDataChanges?: UnsubscribeFunction\n  _throttledSnapshot: ThrottleFunction\n\n  _lsn?: LSN\n\n  relations: RelationsCache\n\n  previousShapeSubscriptions: { keY: string; shapes: Shape[] }[]\n  subscriptionManager: ShapeManager\n\n  /**\n   * To optimize inserting a lot of data when the subscription data comes, we need to do\n   * less `INSERT` queries, but SQLite/Postgres support only a limited amount of `?`/`$i` positional\n   * arguments. Precisely, its either 999 for SQLite versions prior to 3.32.0 and 32766 for\n   * versions after, and 65535 for Postgres.\n   */\n  private maxSqlParameters: 999 | 32766 | 65535 = 999\n  private snapshotMutex: Mutex = new Mutex()\n  private performingSnapshot = false\n\n  private _connectRetryHandler: ConnectRetryHandler\n  private initializing?: Waiter\n\n  private _removeClientListeners?: () => void\n\n  constructor(\n    dbName: DbName,\n    adapter: DatabaseAdapter,\n    migrator: Migrator,\n    notifier: Notifier,\n    client: Client,\n    opts: SatelliteOpts\n  ) {\n    this.dbName = dbName\n    this.adapter = adapter\n    this.migrator = migrator\n    this.notifier = notifier\n    this.client = client\n    this.builder = this.migrator.queryBuilder\n\n    this.opts = opts\n    this.fkChecks =\n      this.builder.dialect === 'SQLite'\n        ? this.opts.fkChecks\n        : ForeignKeyChecks.inherit\n    this.relations = {}\n\n    this.previousShapeSubscriptions = []\n    this.subscriptionManager = new ShapeManager(\n      this.notifier.shapeSubscriptionSyncStatusChanged.bind(\n        this.notifier,\n        this.dbName\n      )\n    )\n\n    this._throttledSnapshot = throttle(\n      this._mutexSnapshot.bind(this),\n      opts.minSnapshotWindow,\n      {\n        leading: true,\n        trailing: true,\n      }\n    )\n\n    this._connectRetryHandler = connectRetryHandler\n  }\n\n  /**\n   * Perform a snapshot while taking out a mutex to avoid concurrent calls.\n   */\n  async _mutexSnapshot() {\n    const release = await this.snapshotMutex.acquire()\n    try {\n      return await this._performSnapshot()\n    } finally {\n      release()\n    }\n  }\n\n  async start(authConfig?: AuthConfig): Promise<void> {\n    if (this.opts.debug) {\n      await this.logDatabaseVersion()\n    }\n\n    this.setClientListeners()\n\n    await this.migrator.up()\n\n    const isVerified = await this._verifyTableStructure()\n    if (!isVerified) {\n      throw new Error('Invalid database schema.')\n    }\n\n    const clientId =\n      authConfig?.clientId && authConfig.clientId !== ''\n        ? authConfig.clientId\n        : await this._getClientId()\n    this._setAuthState({ clientId: clientId })\n\n    const notifierSubscriptions = Object.entries({\n      _authStateSubscription: this._unsubscribeFromAuthState,\n      _connectivityChangeSubscription: this._unsubscribeFromConnectivityChanges,\n      _potentialDataChangeSubscription:\n        this._unsubscribeFromPotentialDataChanges,\n    })\n    notifierSubscriptions.forEach(([name, value]) => {\n      if (value !== undefined) {\n        throw new Error(\n          `Starting satellite process with an existing\n           \\`${name}\\`.\n           This means there is a notifier subscription leak.`\n        )\n      }\n    })\n\n    // Monitor auth state changes.\n    const authStateHandler = this._updateAuthState.bind(this)\n    this._unsubscribeFromAuthState =\n      this.notifier.subscribeToAuthStateChanges(authStateHandler)\n\n    // Request a snapshot whenever the data in our database potentially changes.\n    this._unsubscribeFromPotentialDataChanges =\n      this.notifier.subscribeToPotentialDataChanges(this._throttledSnapshot)\n\n    // Start polling to request a snapshot every `pollingInterval` ms.\n    clearInterval(this._pollingInterval)\n    this._pollingInterval = setInterval(\n      this._throttledSnapshot,\n      this.opts.pollingInterval\n    )\n\n    // Starting now!\n    await this._throttledSnapshot()\n\n    // Need to reload primary keys after schema migration\n    this.relations = await this._getLocalRelations()\n    this.checkMaxSqlParameters()\n\n    const lsnBase64 = await this._getMeta('lsn')\n    if (lsnBase64 && lsnBase64.length > 0) {\n      this._lsn = base64.toBytes(lsnBase64)\n      Log.info(`retrieved lsn ${this._lsn}`)\n    } else {\n      Log.info(`no lsn retrieved from store`)\n    }\n\n    const subscriptionsState = await this._getMeta('subscriptions')\n    if (subscriptionsState) {\n      // this.subscriptions.setState(subscriptionsState)\n      this.subscriptionManager.initialize(subscriptionsState)\n    }\n  }\n\n  private async logDatabaseVersion(): Promise<void> {\n    const versionRow = await this.adapter.query({\n      sql: this.builder.getVersion,\n    })\n    Log.info(\n      `Using ${this.builder.dialect} version: ${versionRow[0]['version']}`\n    )\n  }\n\n  _setAuthState(authState: AuthState): void {\n    this._authState = authState\n  }\n\n  // Adds all the necessary listeners to the satellite client\n  // They can be cleared up by calling the function `_removeClientListeners`\n  setClientListeners(): void {\n    // Remove any existing listeners\n    if (this._removeClientListeners) {\n      this._removeClientListeners?.()\n      this._removeClientListeners = undefined\n    }\n\n    const clientErrorCallback = this._handleClientError.bind(this)\n    this.client.subscribeToError(clientErrorCallback)\n\n    const clientRelationsCallback = this._handleClientRelations.bind(this)\n    this.client.subscribeToRelations(clientRelationsCallback)\n\n    const clientTransactionsCallback = this._handleClientTransactions.bind(this)\n    this.client.subscribeToTransactions(clientTransactionsCallback)\n\n    const clientAdditionalDataCallback =\n      this._handleClientAdditionalData.bind(this)\n    this.client.subscribeToAdditionalData(clientAdditionalDataCallback)\n\n    const clientOutboundStartedCallback =\n      this._handleClientOutboundStarted.bind(this)\n    this.client.subscribeToOutboundStarted(clientOutboundStartedCallback)\n\n    const clientGoneBatchCallback = this._applyGoneBatch.bind(this)\n    this.client.subscribeToGoneBatch(clientGoneBatchCallback)\n\n    const clientSubscriptionDataCallback =\n      this._handleSubscriptionData.bind(this)\n    const clientSubscriptionErrorCallback =\n      this._handleSubscriptionError.bind(this)\n    this.client.subscribeToSubscriptionEvents(\n      clientSubscriptionDataCallback,\n      clientSubscriptionErrorCallback\n    )\n\n    // Keep a way to remove the client listeners\n    this._removeClientListeners = () => {\n      this.client.unsubscribeToError(clientErrorCallback)\n      this.client.unsubscribeToRelations(clientRelationsCallback)\n      this.client.unsubscribeToTransactions(clientTransactionsCallback)\n      this.client.unsubscribeToAdditionalData(clientAdditionalDataCallback)\n      this.client.unsubscribeToOutboundStarted(clientOutboundStartedCallback)\n\n      this.client.unsubscribeToSubscriptionEvents(\n        clientSubscriptionDataCallback,\n        clientSubscriptionErrorCallback\n      )\n      this.client.unsubscribeToGoneBatch(clientGoneBatchCallback)\n    }\n  }\n\n  // Unsubscribe from data changes and stop polling\n  async stop(shutdown?: boolean): Promise<void> {\n    return this._stop(shutdown)\n  }\n\n  private async _stop(shutdown?: boolean): Promise<void> {\n    // Stop snapshot polling\n    clearInterval(this._pollingInterval)\n    this._pollingInterval = undefined\n\n    // Unsubscribe all listeners and remove them\n    const unsubscribers = [\n      '_unsubscribeFromAuthState',\n      '_unsubscribeFromConnectivityChanges',\n      '_unsubscribeFromPotentialDataChanges',\n    ] as const\n\n    unsubscribers.forEach((unsubscriber) => {\n      const unsub = this[unsubscriber]\n      if (unsub !== undefined) {\n        unsub!()\n        this[unsubscriber] = undefined\n      }\n    })\n\n    this._removeClientListeners?.()\n    this._removeClientListeners = undefined\n\n    // Cancel the snapshot throttle\n    this._throttledSnapshot.cancel()\n\n    // Make sure no snapshot is running after we stop the process, otherwise we might be trying to\n    // interact with a closed database connection\n    await this._waitForActiveSnapshots()\n\n    this.disconnect()\n\n    if (shutdown) {\n      await this.client.shutdown()\n    }\n  }\n\n  // Ensure that no snapshot is left running in the background\n  // by acquiring the mutex and releasing it immediately.\n  async _waitForActiveSnapshots(): Promise<void> {\n    const releaseMutex = await this.snapshotMutex.acquire()\n    releaseMutex()\n  }\n\n  /** Get information about a requested subscription by it's key */\n  public syncStatus(key: string): SyncStatus {\n    return this.subscriptionManager.status(key)\n  }\n\n  /**\n   * Subscribe to a set of shapes, so that server data can get onto the client.\n   *\n   * A set of shapes can be \"named\" using a key. Any subsequent calls to `subscribe`\n   * using this key will exchange the subscription: a new one will be subscribed, and\n   * then the old one will be unsubscribed.\n   *\n   * If the `key` is not provided, it will instead be generated. Un-keyed subscriptions\n   * are deduplicated: multiple `subscribe` calls with exactly same shapes will result in\n   * only one subscription, and will even return the same key.\n   */\n  async subscribe(\n    shapeDefinitions: Shape[],\n    key?: string\n  ): Promise<ShapeSubscription> {\n    // Await for client to be ready before doing anything else\n    await this.initializing?.waitOn()\n\n    return this._doSubscribe(shapeDefinitions, key)\n  }\n\n  /** Make a subscription without waiting for init */\n  private async _doSubscribe(\n    shapes: Shape[],\n    key?: string\n  ): Promise<ShapeSubscription> {\n    const request = this.subscriptionManager.syncRequested(shapes, key)\n\n    if ('existing' in request)\n      return { key: request.key, synced: request.existing }\n\n    const clearSubAndThrow = (error: any): never => {\n      request.syncFailed()\n      throw error\n    }\n\n    try {\n      // We're not using generated subscription ID in code here because\n      // it should become server-generated at some point.\n      const { subscriptionId, error }: SubscribeResponse =\n        await this.client.subscribe(\n          genUUID(),\n          shapes.map((x) => ({ definition: x, requestId: genUUID() }))\n        )\n\n      request.setServerId(subscriptionId)\n\n      if (error) throw error\n\n      // persist subscription metadata\n      await this._setMeta('subscriptions', this.subscriptionManager.serialize())\n\n      return {\n        key: request.key,\n        synced: request.promise,\n      }\n    } catch (error: any) {\n      return clearSubAndThrow(error)\n    }\n  }\n\n  public unsubscribe(sync: { shapes: Shape[]; key?: string }): Promise<void>\n  public unsubscribe(keys: string[]): Promise<void>\n  public unsubscribe(\n    target: string[] | { shapes: Shape[]; key?: string }\n  ): Promise<void> {\n    if (Array.isArray(target)) {\n      return this.unsubscribeIds(this.subscriptionManager.getServerIDs(target))\n    } else if (target.key) {\n      return this.unsubscribeIds(\n        this.subscriptionManager.getServerIDs([target.key])\n      )\n    } else {\n      return this.unsubscribeIds(\n        this.subscriptionManager.getServerIDsForShapes(target.shapes)\n      )\n    }\n  }\n\n  private async unsubscribeIds(subscriptionIds: string[]): Promise<void> {\n    if (subscriptionIds.length === 0) return\n\n    await this.client.unsubscribe(subscriptionIds)\n\n    // If the server didn't send an error, we persist the fact the subscription was deleted.\n    this.subscriptionManager.unsubscribeMade(subscriptionIds)\n\n    // persist subscription metadata\n    await this.adapter.run(\n      this._setMetaStatement(\n        'subscriptions',\n        this.subscriptionManager.serialize()\n      )\n    )\n  }\n\n  async _handleSubscriptionData(subsData: SubscriptionData): Promise<void> {\n    const afterApply = this.subscriptionManager.dataDelivered(\n      subsData.subscriptionId\n    )\n\n    const applied = await this._applySubscriptionData(\n      subsData.data,\n      subsData.lsn,\n      [],\n      subsData.subscriptionId\n    )\n\n    if (applied) {\n      const toBeUnsubbed = afterApply()\n      if (toBeUnsubbed.length > 0) await this.unsubscribeIds(toBeUnsubbed)\n    }\n  }\n\n  /**\n   * Insert incoming subscription data into the database.\n   * Returns flag indicating whether application was successful or not.\n   */\n  private async _applySubscriptionData(\n    changes: InitialDataChange[],\n    lsn: LSN,\n    additionalStmts: Statement[] = [],\n    subscriptionId?: string\n  ): Promise<boolean> {\n    const namespace = this.builder.defaultNamespace\n    const stmts: Statement[] = []\n\n    // Defer (SQLite) or temporarily disable FK checks (Postgres)\n    // because order of inserts may not respect referential integrity\n    // and Postgres doesn't let us defer FKs\n    // that were not originally defined as deferrable\n    stmts.push({ sql: this.builder.deferOrDisableFKsForTx })\n\n    // It's much faster[1] to do less statements to insert the data instead of doing an insert statement for each row\n    // so we're going to do just that, but with a caveat: SQLite has a max number of parameters in prepared statements,\n    // so this is less of \"insert all at once\" and more of \"insert in batches\". This should be even more noticeable with\n    // WASM builds, since we'll be crossing the JS-WASM boundary less.\n    //\n    // [1]: https://medium.com/@JasonWyatt/squeezing-performance-from-sqlite-insertions-971aff98eef2\n\n    const groupedChanges = new Map<\n      string,\n      {\n        relation: Relation\n        primaryKeyColNames: string[]\n        records: InitialDataChange['record'][]\n        table: QualifiedTablename\n      }\n    >()\n\n    const allArgsForShadowInsert: Record<\n      'namespace' | 'tablename' | 'primaryKey' | 'tags',\n      SqlValue\n    >[] = []\n\n    // Group all changes by table name to be able to insert them all together\n    const fullTableNameLookup = new Map<string, string>()\n    for (const op of changes) {\n      let groupedChange\n      if (!fullTableNameLookup.has(op.relation.table)) {\n        const qt = new QualifiedTablename(namespace, op.relation.table)\n        const tableName = qt.toString()\n        fullTableNameLookup.set(op.relation.table, tableName)\n        groupedChange = {\n          relation: op.relation,\n          primaryKeyColNames: op.relation.columns\n            .filter((col) => col.primaryKey)\n            .map((col) => col.name),\n          records: [op.record],\n          table: qt,\n        }\n        groupedChanges.set(tableName, groupedChange)\n      } else {\n        groupedChange = groupedChanges.get(\n          fullTableNameLookup.get(op.relation.table)!\n        )!\n        groupedChange.records.push(op.record)\n      }\n\n      // Since we're already iterating changes, we can also prepare data for shadow table\n      const primaryKeyCols = groupedChange.primaryKeyColNames.reduce(\n        (agg, colName) => {\n          agg[colName] = op.record[colName] as string | number\n          return agg\n        },\n        {} as Record<string, string | number>\n      )\n\n      allArgsForShadowInsert.push({\n        namespace,\n        tablename: op.relation.table,\n        primaryKey: primaryKeyToStr(primaryKeyCols),\n        tags: encodeTags(op.tags),\n      })\n    }\n\n    const qualifiedTableNames = [\n      ...Array.from(groupedChanges.values()).map((chg) => chg.table),\n    ]\n\n    // Disable trigger for all affected tables\n    stmts.push(...this._disableTriggers(qualifiedTableNames))\n\n    // For each table, do a batched insert\n    for (const [_table, { relation, records, table }] of groupedChanges) {\n      const columnNames = relation.columns.map((col) => col.name)\n      const qualifiedTableName = `${table}`\n      const orIgnore = this.builder.sqliteOnly('OR IGNORE')\n      const onConflictDoNothing = this.builder.pgOnly('ON CONFLICT DO NOTHING')\n      const sqlBase = `INSERT ${orIgnore} INTO ${qualifiedTableName} (${columnNames.join(\n        ', '\n      )}) VALUES `\n      // Must be an insert or ignore into\n\n      stmts.push(\n        ...this.builder.prepareInsertBatchedStatements(\n          sqlBase,\n          columnNames,\n          records as Record<string, SqlValue>[],\n          this.maxSqlParameters,\n          onConflictDoNothing\n        )\n      )\n    }\n\n    // And re-enable the triggers for all of them\n    stmts.push(...this._enableTriggers(qualifiedTableNames))\n\n    // Then do a batched insert for the shadow table\n    const batchedShadowInserts = this.builder.batchedInsertOrReplace(\n      this.opts.shadowTable,\n      ['namespace', 'tablename', 'primaryKey', 'tags'],\n      allArgsForShadowInsert,\n      ['namespace', 'tablename', 'primaryKey'],\n      ['namespace', 'tablename', 'tags'],\n      this.maxSqlParameters\n    )\n    stmts.push(...batchedShadowInserts)\n\n    // Then update subscription state and LSN\n    stmts.push(\n      this._setMetaStatement(\n        'subscriptions',\n        this.subscriptionManager.serialize()\n      ),\n      this.updateLsnStmt(lsn),\n      ...additionalStmts\n    )\n\n    try {\n      await this.runInTransaction(...stmts)\n\n      // We're explicitly not specifying rowids in these changes for now,\n      // because nobody uses them and we don't have the machinery to to a\n      // `RETURNING` clause in the middle of `runInTransaction`.\n      const notificationChanges: Change[] = []\n      groupedChanges.forEach(({ records, table, primaryKeyColNames }) => {\n        notificationChanges.push({\n          qualifiedTablename: table,\n          rowids: [],\n          recordChanges: records.map((change) => {\n            return {\n              primaryKey: primaryKeyColNames.reduce(\n                (primaryKeyRec, col_name) => {\n                  primaryKeyRec[col_name] = change[col_name]\n                  return primaryKeyRec\n                },\n                {} as typeof change\n              ),\n              type: 'INITIAL',\n            }\n          }),\n        })\n      })\n      this.notifier.actuallyChanged(this.dbName, notificationChanges, 'initial')\n      return true\n    } catch (e) {\n      this._handleSubscriptionError(\n        new SatelliteError(\n          SatelliteErrorCode.INTERNAL,\n          `Error applying subscription data: ${(e as any).message}`\n        ),\n        subscriptionId\n      )\n      return false\n    }\n  }\n\n  /**\n   * Runs the provided statements in a transaction and disables FK checks if `this.fkChecks` is set to `disabled`.\n   * `this.fkChecks` should only be set to true when using SQLite as we already disable FK checks for incoming TXs when using Postgres\n   */\n  async runInTransaction(...stmts: Statement[]) {\n    return runInTransaction(this.adapter, this.fkChecks, ...stmts)\n  }\n\n  _resetClientState(opts?: { keepSubscribedShapes: boolean }): Promise<void> {\n    Log.warn(`resetting client state`)\n    this.disconnect()\n\n    this._lsn = undefined\n\n    const tables = this.subscriptionManager.reset({\n      defaultNamespace: this.builder.defaultNamespace,\n      reestablishSubscribed: opts?.keepSubscribedShapes,\n    })\n\n    return this._clearTables(tables)\n  }\n\n  async _clearTables(tables: QualifiedTablename[]) {\n    await this.runInTransaction(\n      this._setMetaStatement('lsn', null),\n      this._setMetaStatement(\n        'subscriptions',\n        this.subscriptionManager.serialize()\n      ),\n      { sql: this.builder.deferOrDisableFKsForTx },\n      ...this._disableTriggers(tables),\n      ...tables.map((x) => ({ sql: `DELETE FROM ${x}` })),\n      ...this._enableTriggers(tables)\n    )\n  }\n\n  async _handleSubscriptionError(\n    satelliteError: SatelliteError,\n    subscriptionId?: string\n  ): Promise<void> {\n    Log.error('encountered a subscription error: ' + satelliteError.message)\n    let resettingError: any = satelliteError\n    let onFailure: ((reason?: any) => void) | undefined\n\n    // We're pulling out the reject callback because we're about to reset the subscription manager\n    if (subscriptionId)\n      onFailure = this.subscriptionManager.getOnFailureCallback(subscriptionId)\n\n    try {\n      await this._resetClientState()\n    } catch (error) {\n      console.log(error)\n      // If we encounter an error here, we want to float it to the client so that the bug is visible\n      // instead of just a broken state.\n      resettingError = error\n      resettingError.stack +=\n        '\\n  Encountered when handling a subscription error: \\n    ' +\n        satelliteError.stack\n    }\n    // Call the `onFailure` callback for this subscription\n    onFailure?.(resettingError)\n  }\n\n  _handleClientRelations(relation: Relation): void {\n    this._updateRelations(relation)\n  }\n\n  async _handleClientTransactions(tx: ServerTransaction) {\n    await this._applyTransaction(tx)\n  }\n\n  async _handleClientAdditionalData(data: AdditionalData) {\n    await this._applyAdditionalData(data)\n  }\n\n  async _handleClientOutboundStarted() {\n    await this._throttledSnapshot()\n  }\n\n  // handles async client errors: can be a socket error or a server error message\n  _handleClientError(satelliteError: SatelliteError) {\n    if (this.initializing && !this.initializing.finished()) {\n      if (satelliteError.code === SatelliteErrorCode.SOCKET_ERROR) {\n        Log.warn(\n          `a socket error occurred while connecting to server: ${satelliteError.message}`\n        )\n        return\n      }\n\n      if (satelliteError.code === SatelliteErrorCode.AUTH_REQUIRED) {\n        // TODO: should stop retrying\n        Log.warn(\n          `an authentication error occurred while connecting to server: ${satelliteError.message}`\n        )\n        return\n      }\n\n      // throw unhandled error\n      throw satelliteError\n    }\n\n    Log.warn(`an error occurred in satellite: ${satelliteError.message}`)\n\n    this._handleOrThrowClientError(satelliteError)\n  }\n\n  async _handleOrThrowClientError(error: SatelliteError): Promise<void> {\n    if (error.code === SatelliteErrorCode.AUTH_EXPIRED) {\n      Log.warn('Connection closed by Electric because the JWT expired.')\n      return this.disconnect(\n        new SatelliteError(\n          error.code,\n          'Connection closed by Electric because the JWT expired.'\n        )\n      )\n    }\n\n    this.disconnect(error)\n\n    if (isThrowable(error)) {\n      throw error\n    }\n    if (isFatal(error)) {\n      throw wrapFatalError(error)\n    }\n\n    Log.warn('Client disconnected with a non fatal error, reconnecting')\n    return this.connectWithBackoff()\n  }\n\n  /**\n   * Sets the JWT token.\n   * @param token The JWT token.\n   */\n  setToken(token: string): void {\n    const newUserId = decodeUserIdFromToken(token)\n    const userId: string | undefined = this._authState?.userId\n    if (typeof userId !== 'undefined' && newUserId !== userId) {\n      // We must check that the new token is still using the same user ID.\n      // We can't accept a re-connection that changes the user ID because the Satellite process is statefull.\n      // To change user ID the user must re-electrify the database.\n      throw new InvalidArgumentError(\n        `Can't change user ID when reconnecting. Previously connected with user ID '${userId}' but trying to reconnect with user ID '${newUserId}'`\n      )\n    }\n    this._setAuthState({\n      ...this._authState!,\n      userId: newUserId,\n      token,\n    })\n  }\n\n  /**\n   * @returns True if a JWT token has been set previously. False otherwise.\n   */\n  hasToken(): boolean {\n    return this._authState?.token !== undefined\n  }\n\n  async connectWithBackoff(): Promise<void> {\n    if (this.client.isConnected()) {\n      // we're already connected\n      return\n    }\n\n    if (this.initializing && !this.initializing.finished()) {\n      // we're already trying to connect to Electric\n      // return the promise that resolves when the connection is established\n      return this.initializing.waitOn()\n    }\n\n    if (!this.initializing || this.initializing?.finished()) {\n      this.initializing = getWaiter()\n    }\n\n    const opts = {\n      ...this.opts.connectionBackOffOptions,\n      retry: this._connectRetryHandler,\n    }\n\n    const prom = this.initializing.waitOn()\n\n    await backOff(async () => {\n      if (this.initializing?.finished()) {\n        return prom\n      }\n      await this._connect()\n      await this._startReplication()\n      await this._makePendingSubscriptions()\n      // this._subscribePreviousShapeRequests()\n\n      this._notifyConnectivityState('connected')\n      this.initializing?.resolve()\n    }, opts).catch((e) => {\n      // We're very sure that no calls are going to modify `this.initializing` before this promise resolves\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const error = !connectRetryHandler(e, 0)\n        ? e\n        : new SatelliteError(\n            SatelliteErrorCode.CONNECTION_FAILED_AFTER_RETRY,\n            `Failed to connect to server after exhausting retry policy. Last error thrown by server: ${e.message}`\n          )\n\n      this.disconnect(error)\n      this.initializing?.reject(error)\n    })\n\n    return prom\n  }\n\n  private async _makePendingSubscriptions(): Promise<void> {\n    const { subscribe, unsubscribe } =\n      this.subscriptionManager.listPendingActions()\n\n    await this.unsubscribeIds(unsubscribe)\n    await Promise.all(subscribe.map((x) => this._doSubscribe(x.shapes, x.key)))\n  }\n\n  // _subscribePreviousShapeRequests(): void {\n  //   try {\n  //     if (this.previousShapeSubscriptions.length > 0) {\n  //       Log.warn(`Subscribing previous shape definitions`)\n  //       this.subscribe(\n  //         this.previousShapeSubscriptions.splice(\n  //           0,\n  //           this.previousShapeSubscriptions.length\n  //         )\n  //       )\n  //     }\n  //   } catch (error: any) {\n  //     const message = `Client was unable to subscribe previously subscribed shapes: ${error.message}`\n  //     throw new SatelliteError(SatelliteErrorCode.INTERNAL, message)\n  //   }\n  // }\n\n  // NO DIRECT CALLS TO CONNECT\n  private async _connect(): Promise<void> {\n    Log.info(`connecting to electric server`)\n\n    if (!this._authState || !this._authState.token) {\n      throw new Error(`trying to connect before authentication`)\n    }\n\n    try {\n      await this.client.connect()\n      await this.authenticate(this._authState!.token!)\n    } catch (error: any) {\n      Log.debug(\n        `server returned an error while establishing connection: ${error.message}`\n      )\n      throw error\n    }\n  }\n\n  /**\n   * Authenticates with the Electric sync service using the provided token.\n   * @returns A promise that resolves to void if authentication succeeded. Otherwise, rejects with the reason for the error.\n   */\n  async authenticate(token: string): Promise<void> {\n    const authState = {\n      clientId: this._authState!.clientId,\n      token,\n    }\n    const authResp = await this.client.authenticate(authState)\n    if (authResp.error) {\n      throw authResp.error\n    }\n    this._setAuthState(authState)\n  }\n\n  cancelConnectionWaiter(error: SatelliteError): void {\n    if (this.initializing && !this.initializing.finished()) {\n      this.initializing?.reject(error)\n    }\n  }\n\n  disconnect(error?: SatelliteError): void {\n    this.client.disconnect()\n    this._notifyConnectivityState('disconnected', error)\n  }\n\n  /**\n   * A disconnection issued by the client.\n   */\n  clientDisconnect(): void {\n    const error = new SatelliteError(\n      SatelliteErrorCode.CONNECTION_CANCELLED_BY_DISCONNECT,\n      `Connection cancelled by 'disconnect'`\n    )\n    this.disconnect(error)\n    this.cancelConnectionWaiter(error)\n  }\n\n  async _startReplication(): Promise<void> {\n    try {\n      const schemaVersion = await this.migrator.querySchemaVersion()\n\n      // Load subscription state that to reset the subscription manager correctly\n      const subscriptionsState = await this._getMeta('subscriptions')\n      if (subscriptionsState) {\n        this.subscriptionManager.initialize(subscriptionsState)\n      }\n\n      // Fetch the subscription IDs that were fulfilled\n      // such that we can resume and inform Electric\n      // about fulfilled subscriptions\n      const subscriptionIds =\n        this.subscriptionManager.listContinuedSubscriptions()\n      const observedTransactionData = await this._getMeta('seenAdditionalData')\n\n      const { error } = await this.client.startReplication(\n        this._lsn,\n        schemaVersion,\n        subscriptionIds.length > 0 ? subscriptionIds : undefined,\n        observedTransactionData\n          .split(',')\n          .filter((x) => x !== '')\n          .map((x) => Long.fromString(x))\n      )\n\n      if (error) {\n        throw error\n      }\n    } catch (error: any) {\n      Log.warn(`Couldn't start replication: ${error.message}`)\n      if (!(error instanceof SatelliteError)) {\n        throw new SatelliteError(SatelliteErrorCode.INTERNAL, error.message)\n      }\n\n      if (isOutOfSyncError(error) && this.opts?.clearOnBehindWindow) {\n        await this._resetClientState({ keepSubscribedShapes: true })\n        throw error\n      }\n\n      // Some errors could be fixed by dropping local database entirely\n      // We propagate throwable and fatal errors for the app to decide\n      if (isThrowable(error)) {\n        throw error\n      }\n\n      if (isFatal(error)) {\n        throw wrapFatalError(error)\n      }\n    }\n  }\n\n  private _notifyConnectivityState(\n    connectivityStatus: ConnectivityStatus,\n    error?: SatelliteError\n  ): void {\n    this.connectivityState = {\n      status: connectivityStatus,\n      reason: error,\n    }\n    this.notifier.connectivityStateChanged(this.dbName, this.connectivityState)\n  }\n\n  async _verifyTableStructure(): Promise<boolean> {\n    const meta = this.opts.metaTable.tablename\n    const oplog = this.opts.oplogTable.tablename\n    const shadow = this.opts.shadowTable.tablename\n\n    const [{ count }] = await this.adapter.query(\n      this.builder.countTablesIn([meta, oplog, shadow])\n    )\n    return count === 3\n  }\n\n  // Handle auth state changes.\n  async _updateAuthState({ authState }: AuthStateNotification): Promise<void> {\n    // XXX do whatever we need to stop/start or reconnect the replication\n    // connection with the new auth state.\n\n    // XXX Maybe we need to auto-start processing and/or replication\n    // when we get the right authState?\n\n    this._authState = authState\n  }\n\n  // Perform a snapshot and notify which data actually changed.\n  // It is not safe to call concurrently. Use mutexSnapshot.\n  async _performSnapshot(): Promise<Date> {\n    // assert a single call at a time\n    if (this.performingSnapshot) {\n      throw new SatelliteError(\n        SatelliteErrorCode.INTERNAL,\n        'already performing snapshot'\n      )\n    } else {\n      this.performingSnapshot = true\n    }\n\n    try {\n      const oplog = `${this.opts.oplogTable}`\n      const shadow = `${this.opts.shadowTable}`\n      const timestamp = new Date()\n      const newTag = this._generateTag(timestamp)\n\n      /*\n       * IMPORTANT!\n       *\n       * The following queries make use of a documented but rare SQLite behaviour that allows selecting bare column\n       * on aggregate queries: https://sqlite.org/lang_select.html#bare_columns_in_an_aggregate_query\n       *\n       * In short, when a query has a `GROUP BY` clause with a single `min()` or `max()` present in SELECT/HAVING,\n       * then the \"bare\" columns (i.e. those not mentioned in a `GROUP BY` clause) are definitely the ones from the\n       * row that satisfied that `min`/`max` function. We make use of it here to find first/last operations in the\n       * oplog that touch a particular row.\n       */\n\n      // Update the timestamps on all \"new\" entries - they have been added but timestamp is still `NULL`\n      const q1: Statement = {\n        sql: `\n      UPDATE ${oplog} SET timestamp = ${this.builder.makePositionalParam(1)}\n      WHERE rowid in (\n        SELECT rowid FROM ${oplog}\n            WHERE timestamp is NULL\n        ORDER BY rowid ASC\n        )\n      RETURNING *\n      `,\n        args: [timestamp.toISOString()],\n      }\n\n      // We're adding new tag to the shadow tags for this row\n      const q2: Statement = {\n        sql: `\n      UPDATE ${oplog}\n      SET \"clearTags\" =\n          CASE WHEN shadow.tags = '[]' OR shadow.tags = ''\n               THEN '[\"' || ${this.builder.makePositionalParam(1)} || '\"]'\n               ELSE '[\"' || ${this.builder.makePositionalParam(\n                 2\n               )} || '\",' || substring(shadow.tags, 2)\n          END\n      FROM ${shadow} AS shadow\n      WHERE ${oplog}.namespace = shadow.namespace\n          AND ${oplog}.tablename = shadow.tablename\n          AND ${oplog}.\"primaryKey\" = shadow.\"primaryKey\" AND ${oplog}.timestamp = ${this.builder.makePositionalParam(\n          3\n        )}\n      `,\n        args: [newTag, newTag, timestamp.toISOString()],\n      }\n\n      // For each affected shadow row, set new tag array, unless the last oplog operation was a DELETE\n      const q3: Statement = {\n        sql: this.builder.setTagsForShadowRows(\n          this.opts.oplogTable,\n          this.opts.shadowTable\n        ),\n        args: [encodeTags([newTag]), timestamp.toISOString()],\n      }\n\n      // And finally delete any shadow rows where the last oplog operation was a `DELETE`\n      const q4: Statement = {\n        sql: this.builder.removeDeletedShadowRows(\n          this.opts.oplogTable,\n          this.opts.shadowTable\n        ),\n        args: [timestamp.toISOString()],\n      }\n\n      // Execute the four queries above in a transaction, returning the results from the first query\n      // We're dropping down to this transaction interface because `runInTransaction` doesn't allow queries\n      const oplogEntries = (await this.adapter.transaction<OplogEntry[]>(\n        (tx, setResult) => {\n          tx.query(q1, (tx, res) => {\n            if (res.length > 0)\n              tx.run(q2, (tx) =>\n                tx.run(q3, (tx) =>\n                  tx.run(q4, () => setResult(res as unknown as OplogEntry[]))\n                )\n              )\n            else {\n              setResult([])\n            }\n          })\n        }\n      )) as OplogEntry[]\n\n      if (oplogEntries.length > 0) this._notifyChanges(oplogEntries, 'local')\n\n      if (\n        this.client.getOutboundReplicationStatus() === ReplicationStatus.ACTIVE\n      ) {\n        const enqueued = this.client.getLastSentLsn()\n        const enqueuedLogPos = bytesToNumber(enqueued)\n\n        // TODO: handle case where pending oplog is large\n        await this._getEntries(enqueuedLogPos).then((missing) =>\n          this._replicateSnapshotChanges(missing)\n        )\n      }\n      return timestamp\n    } catch (e: any) {\n      Log.error(`error performing snapshot: ${e}`)\n      throw e\n    } finally {\n      this.performingSnapshot = false\n    }\n  }\n\n  _notifyChanges(results: OplogEntry[], origin: ChangeOrigin): void {\n    const acc: ChangeAccumulator = {}\n\n    // Would it be quicker to do this using a second SQL query that\n    // returns results in `Change` format?!\n    const reduceFn = (acc: ChangeAccumulator, entry: OplogEntry) => {\n      const qt = new QualifiedTablename(entry.namespace, entry.tablename)\n      const key = qt.toString()\n\n      if (key in acc) {\n        const change: Change = acc[key]\n\n        if (change.rowids === undefined) {\n          change.rowids = []\n        }\n        if (change.recordChanges === undefined) {\n          change.recordChanges = []\n        }\n\n        change.rowids.push(entry.rowid)\n        change.recordChanges.push({\n          primaryKey: JSON.parse(entry.primaryKey),\n          type: entry.optype,\n        })\n      } else {\n        acc[key] = {\n          qualifiedTablename: qt,\n          rowids: [entry.rowid],\n          recordChanges: [\n            {\n              primaryKey: JSON.parse(entry.primaryKey),\n              type: entry.optype,\n            },\n          ],\n        }\n      }\n\n      return acc\n    }\n\n    const changes = Object.values(results.reduce(reduceFn, acc))\n    this.notifier.actuallyChanged(this.dbName, changes, origin)\n  }\n\n  async _replicateSnapshotChanges(results: OplogEntry[]): Promise<void> {\n    if (\n      this.client.getOutboundReplicationStatus() !== ReplicationStatus.ACTIVE\n    ) {\n      return\n    }\n\n    const transactions = toTransactions(results, this.relations)\n    for (const txn of transactions) {\n      this.client.enqueueTransaction(txn)\n    }\n  }\n\n  // Apply a set of incoming transactions against pending local operations,\n  // applying conflict resolution rules. Takes all changes per each key before\n  // merging, for local and remote operations.\n\n  // TODO: in case the subscriptions between the client and server become\n  // out of sync, the server might send operations that do not belong to\n  // any existing subscription. We need a way to detect and prevent that.\n  async _apply(incoming: OplogEntry[], incoming_origin: string) {\n    const local = await this._getEntries()\n    const merged = mergeEntries(\n      this._authState!.clientId,\n      local,\n      incoming_origin,\n      incoming,\n      this.relations\n    )\n\n    const stmts: Statement[] = []\n    for (const [tablenameStr, mapping] of Object.entries(merged)) {\n      const qualifiedTableName = QualifiedTablename.parse(tablenameStr)\n      for (const entryChanges of Object.values(mapping)) {\n        const shadowEntry: ShadowEntry = {\n          namespace: entryChanges.namespace,\n          tablename: entryChanges.tablename,\n          primaryKey: getShadowPrimaryKey(entryChanges),\n          tags: encodeTags(entryChanges.tags),\n        }\n\n        switch (entryChanges.optype) {\n          case OPTYPES.gone:\n          case OPTYPES.delete:\n            stmts.push(\n              this._applyDeleteOperation(entryChanges, qualifiedTableName)\n            )\n            stmts.push(this._deleteShadowTagsStatement(shadowEntry))\n            break\n\n          default:\n            stmts.push(\n              this._applyNonDeleteOperation(entryChanges, qualifiedTableName)\n            )\n            stmts.push(this._updateShadowTagsStatement(shadowEntry))\n        }\n      }\n    }\n\n    const tablenames = Object.keys(merged)\n    return {\n      tablenames,\n      statements: stmts,\n    }\n  }\n\n  async _getEntries(since?: number): Promise<OplogEntry[]> {\n    // `rowid` is never below 0, so -1 means \"everything\"\n    since ??= -1\n    const oplog = `${this.opts.oplogTable}`\n\n    const selectEntries = `\n      SELECT * FROM ${oplog}\n        WHERE timestamp IS NOT NULL\n          AND rowid > ${this.builder.makePositionalParam(1)}\n        ORDER BY rowid ASC\n    `\n    const rows = await this.adapter.query({ sql: selectEntries, args: [since] })\n    return rows as unknown as OplogEntry[]\n  }\n\n  _deleteShadowTagsStatement(shadow: ShadowEntry): Statement {\n    const shadowTable = `${this.opts.shadowTable}`\n    const pos = (i: number) => this.builder.makePositionalParam(i)\n    const deleteRow = `\n      DELETE FROM ${shadowTable}\n      WHERE namespace = ${pos(1)} AND\n            tablename = ${pos(2)} AND\n            \"primaryKey\" = ${pos(3)};\n    `\n    return {\n      sql: deleteRow,\n      args: [shadow.namespace, shadow.tablename, shadow.primaryKey],\n    }\n  }\n\n  _updateShadowTagsStatement(shadow: ShadowEntry): Statement {\n    return this.builder.insertOrReplace(\n      this.opts.shadowTable,\n      ['namespace', 'tablename', 'primaryKey', 'tags'],\n      [shadow.namespace, shadow.tablename, shadow.primaryKey, shadow.tags],\n      ['namespace', 'tablename', 'primaryKey'],\n      ['tags']\n    )\n  }\n\n  _updateRelations(rel: Omit<Relation, 'id'>) {\n    if (rel.tableType === SatRelation_RelationType.TABLE) {\n      // this relation may be for a newly created table\n      // or for a column that was added to an existing table\n      const tableName = rel.table\n\n      if (this.relations[tableName] === undefined) {\n        let id = 0\n        // generate an id for the new relation as (the highest existing id) + 1\n        // TODO: why not just use the relation.id coming from pg?\n        for (const r of Object.values(this.relations)) {\n          if (r.id > id) {\n            id = r.id\n          }\n        }\n        const relation = {\n          ...rel,\n          id: id + 1,\n        }\n        this.relations[tableName] = relation\n      } else {\n        // the relation is for an existing table\n        // update the information but keep the same ID\n        const id = this.relations[tableName].id\n        const relation = {\n          ...rel,\n          id: id,\n        }\n        this.relations[tableName] = relation\n      }\n    }\n  }\n\n  async _applyTransaction(transaction: Transaction) {\n    const namespace = this.builder.defaultNamespace\n    const origin = transaction.origin!\n    const commitTimestamp = new Date(transaction.commit_timestamp.toNumber())\n\n    // Transactions coming from the replication stream\n    // may contain DML operations manipulating data\n    // but may also contain DDL operations migrating schemas.\n    // DML operations are ran through conflict resolution logic.\n    // DDL operations are applied as is against the local DB.\n\n    // `stmts` will store all SQL statements\n    // that need to be executed\n    const stmts: Statement[] = []\n    // `txStmts` will store the statements related to the transaction\n    // including the creation of triggers\n    // but not statements that disable/enable the triggers\n    // neither statements that update meta tables or modify pragmas.\n    // The `txStmts` is used to compute the hash of migration transactions\n    const txStmts: Statement[] = []\n    const tablenamesSet: Set<string> = new Set()\n    let newTables: Set<string> = new Set()\n    const opLogEntries: OplogEntry[] = []\n    const lsn = transaction.lsn\n    let firstDMLChunk = true\n\n    // Defer (SQLite) or temporarily disable FK checks (Postgres)\n    // because order of inserts may not respect referential integrity\n    // and Postgres doesn't let us defer FKs\n    // that were not originally defined as deferrable\n    stmts.push({ sql: this.builder.deferOrDisableFKsForTx })\n\n    // update lsn.\n    stmts.push(this.updateLsnStmt(lsn))\n    stmts.push(this._resetAllSeenStmt())\n\n    const processDML = async (changes: DataChange[]) => {\n      const tx = {\n        ...transaction,\n        changes,\n      }\n      const entries = fromTransaction(tx, this.relations, namespace)\n\n      // Before applying DML statements we need to assign a timestamp to pending operations.\n      // This only needs to be done once, even if there are several DML chunks\n      // because all those chunks are part of the same transaction.\n      if (firstDMLChunk) {\n        Log.info(`apply incoming changes for LSN: ${base64.fromBytes(lsn)}`)\n        // assign timestamp to pending operations before apply\n        await this._mutexSnapshot()\n        firstDMLChunk = false\n      }\n\n      const { statements, tablenames } = await this._apply(entries, origin)\n      entries.forEach((e) => opLogEntries.push(e))\n      statements.forEach((s) => stmts.push(s))\n      tablenames.forEach((n) => tablenamesSet.add(n))\n    }\n    const processDDL = async (changes: SchemaChange[]) => {\n      const createdTables: Set<string> = new Set()\n      const affectedTables: Map<string, MigrationTable> = new Map()\n      changes.forEach((change) => {\n        const changeStmt = { sql: change.sql }\n        stmts.push(changeStmt)\n\n        if (\n          change.migrationType === SatOpMigrate_Type.CREATE_TABLE ||\n          change.migrationType === SatOpMigrate_Type.ALTER_ADD_COLUMN\n        ) {\n          // We will create/update triggers for this new/updated table\n          // so store it in `tablenamesSet` such that those\n          // triggers can be disabled while executing the transaction\n          const affectedTable = new QualifiedTablename(\n            namespace,\n            change.table.name\n          ).toString()\n          // store the table information to generate the triggers after this `forEach`\n          affectedTables.set(affectedTable, change.table)\n          tablenamesSet.add(affectedTable)\n\n          if (change.migrationType === SatOpMigrate_Type.CREATE_TABLE) {\n            createdTables.add(affectedTable)\n          }\n        }\n      })\n\n      // Also add statements to create the necessary triggers for the created/updated table\n      affectedTables.forEach((table) => {\n        const triggers = generateTriggersForTable(table, this.builder)\n        stmts.push(...triggers)\n        txStmts.push(...triggers)\n      })\n\n      // Disable the newly created triggers\n      // during the processing of this transaction\n      const createdQualifiedTables = Array.from(createdTables).map(\n        QualifiedTablename.parse\n      )\n      stmts.push(...this._disableTriggers(createdQualifiedTables))\n      newTables = new Set([...newTables, ...createdTables])\n    }\n\n    // Start with garbage collection, because if this a transaction after round-trip, then we don't want it in conflict resolution\n    await this.maybeGarbageCollect(origin, commitTimestamp)\n\n    // Chunk incoming changes by their types, and process each chunk one by one\n    for (const [dataChange, chunk] of chunkBy(\n      transaction.changes,\n      isDataChange\n    )) {\n      if (dataChange) {\n        await processDML(chunk as DataChange[])\n      } else {\n        await processDDL(chunk as SchemaChange[])\n      }\n    }\n\n    // Now run the DML and DDL statements in-order in a transaction\n    const tablenames = Array.from(tablenamesSet)\n    const qualifiedTables = tablenames.map(QualifiedTablename.parse)\n    const notNewTableNames = tablenames.filter((t) => !newTables.has(t))\n    const notNewQualifiedTables = notNewTableNames.map(QualifiedTablename.parse)\n\n    const allStatements = this._disableTriggers(notNewQualifiedTables)\n      .concat(stmts)\n      .concat(this._enableTriggers(qualifiedTables))\n\n    if (transaction.migrationVersion) {\n      // If a migration version is specified\n      // then the transaction is a migration\n      await this.migrator.applyIfNotAlready(\n        {\n          statements: allStatements,\n          version: transaction.migrationVersion,\n        },\n        this.fkChecks\n      )\n    } else {\n      await this.runInTransaction(...allStatements)\n    }\n\n    this._notifyChanges(opLogEntries, 'remote')\n  }\n\n  async _applyAdditionalData(data: AdditionalData) {\n    // Server sends additional data on move-ins and tries to send only data\n    // the client has never seen from its perspective. Because of this, we're writing this\n    // data directly, like subscription data\n    return this._applySubscriptionData(data.changes, this._lsn!, [\n      this._addSeenAdditionalDataStmt(data.ref.toString()),\n    ])\n  }\n\n  async _applyGoneBatch(\n    lsn: LSN,\n    subscriptionIds: string[],\n    allGone: DataGone[]\n  ) {\n    const fakeOplogEntries: OplogEntry[] = allGone.map(\n      (x): OplogEntry => ({\n        namespace: this.builder.defaultNamespace,\n        tablename: x.relation.table,\n        primaryKey: extractPK(x),\n        optype: 'GONE',\n        // Fields below don't matter here.\n        rowid: -1,\n        timestamp: '',\n        clearTags: '',\n      })\n    )\n\n    // Batch-delete shadow entries\n    const stmts = this.builder.prepareDeleteBatchedStatements(\n      `DELETE FROM ${this.opts.shadowTable} WHERE `,\n      ['namespace', 'tablename', 'primaryKey'],\n      fakeOplogEntries,\n      this.maxSqlParameters\n    )\n\n    const groupedChanges = groupBy(allGone, (x) => x.relation.table)\n    const affectedTables = Object.keys(groupedChanges).map((x) =>\n      this.builder.makeQT(x)\n    )\n\n    // Batch-delete affected rows per table\n    for (const [table, gone] of Object.entries(groupedChanges)) {\n      if (gone.length === 0) continue\n\n      const fqtn = this.builder.makeQT(table)\n      const pkCols = gone[0].relation.columns\n        .filter((x) => x.primaryKey)\n        .map((x) => x.name)\n\n      stmts.push(\n        ...this.builder.prepareDeleteBatchedStatements(\n          `DELETE FROM ${fqtn} WHERE`,\n          pkCols,\n          gone.map((x) => x.oldRecord) as Record<string, SqlValue>[],\n          this.maxSqlParameters\n        )\n      )\n    }\n\n    await this.runInTransaction(\n      this.updateLsnStmt(lsn),\n      { sql: this.builder.deferOrDisableFKsForTx },\n      ...this._disableTriggers(affectedTables),\n      ...stmts,\n      ...this._enableTriggers(affectedTables)\n    )\n\n    this.subscriptionManager.goneBatchDelivered(subscriptionIds)\n\n    this._notifyChanges(fakeOplogEntries, 'remote')\n  }\n\n  private async maybeGarbageCollect(\n    origin: string,\n    commitTimestamp: Date\n  ): Promise<void> {\n    if (origin === this._authState!.clientId) {\n      /* Any outstanding transaction that originated on Satellite but haven't\n       * been received back from the Electric is considered to be concurrent with\n       * any other transaction coming from Electric.\n       *\n       * Thus we need to keep oplog entries in order to be able to do conflict\n       * resolution with add-wins semantics.\n       *\n       * Once we receive transaction that was originated on the Satellite, oplog\n       * entries that correspond to such transaction can be safely removed as\n       * they are no longer necessary for conflict resolution.\n       */\n      await this._garbageCollectOplog(commitTimestamp)\n    }\n  }\n\n  _disableTriggers(tables: QualifiedTablename[]): Statement[] {\n    return this._updateTriggerSettings(tables, 0)\n  }\n\n  _enableTriggers(tables: QualifiedTablename[]): Statement[] {\n    return this._updateTriggerSettings(tables, 1)\n  }\n\n  _updateTriggerSettings(\n    tables: QualifiedTablename[],\n    flag: 0 | 1\n  ): Statement[] {\n    if (tables.length === 0) return []\n    const triggers = `${this.opts.triggersTable}`\n    const namespacesAndTableNames = tables.flatMap((tbl) => [\n      tbl.namespace,\n      tbl.tablename,\n    ])\n    const pos = (i: number) => this.builder.makePositionalParam(i)\n    let i = 1\n    return [\n      {\n        sql: `UPDATE ${triggers} SET flag = ${pos(i++)} WHERE ${tables\n          .map((_) => `(namespace = ${pos(i++)} AND tablename = ${pos(i++)})`)\n          .join(' OR ')}`,\n        args: [flag, ...namespacesAndTableNames],\n      },\n    ]\n  }\n\n  _addSeenGoneBatchStmt(subscriptionIds: string[]): Statement {\n    const meta = `${this.opts.metaTable}`\n\n    return {\n      sql: `INSERT INTO ${meta} VALUES ('seenGoneBatch', ${this.builder.makePositionalParam(\n        1\n      )} ON CONFLICT (key) DO UPDATE SET value = ${meta}.value || ',' || excluded.value`,\n      args: [subscriptionIds.join(',')],\n    }\n  }\n\n  _addSeenAdditionalDataStmt(ref: string): Statement {\n    const meta = `${this.opts.metaTable}`\n    const sql = `\n      INSERT INTO ${meta} (key, value) VALUES ('seenAdditionalData', ${this.builder.makePositionalParam(\n      1\n    )})\n        ON CONFLICT (key) DO\n          UPDATE SET value = ${meta}.value || ',' || excluded.value\n    `\n    const args = [ref]\n    return { sql, args }\n  }\n\n  _resetAllSeenStmt(\n    keys: (keyof MetaEntries)[] = ['seenAdditionalData', 'seenGoneBatch']\n  ): Statement {\n    const whereClause = keys\n      .map((_, i) => `key = ${this.builder.makePositionalParam(i + 1)}`)\n      .join(' OR ')\n    const sql = `UPDATE ${this.opts.metaTable} SET VALUE = '' WHERE ${whereClause}`\n\n    return { sql, args: keys }\n  }\n\n  _setMetaStatement<K extends keyof MetaEntries>(\n    key: K,\n    value: MetaEntries[K]\n  ): Statement\n  _setMetaStatement(key: Uuid, value: string | null): Statement\n  _setMetaStatement(key: string, value: SqlValue) {\n    const meta = `${this.opts.metaTable}`\n    const pos = (i: number) => this.builder.makePositionalParam(i)\n    const sql = `UPDATE ${meta} SET value = ${pos(1)} WHERE key = ${pos(2)}`\n    const args = [value, key]\n    return { sql, args }\n  }\n\n  async _setMeta<K extends keyof MetaEntries>(\n    key: K,\n    value: MetaEntries[K]\n  ): Promise<void>\n  async _setMeta(key: Uuid, value: string | null): Promise<void>\n  async _setMeta(\n    key: Parameters<this['_setMetaStatement']>[0],\n    value: Parameters<this['_setMetaStatement']>[1]\n  ) {\n    const stmt = this._setMetaStatement(key, value)\n    await this.adapter.run(stmt)\n  }\n\n  async _getMeta(key: Uuid): Promise<string | null>\n  async _getMeta<K extends keyof MetaEntries>(key: K): Promise<MetaEntries[K]>\n  async _getMeta(key: string) {\n    const meta = `${this.opts.metaTable}`\n    const pos = (i: number) => this.builder.makePositionalParam(i)\n    const sql = `SELECT value from ${meta} WHERE key = ${pos(1)}`\n    const args = [key]\n    const rows = await this.adapter.query({ sql, args })\n\n    if (rows.length !== 1) {\n      throw `Invalid metadata table: missing ${key}`\n    }\n\n    return rows[0].value\n  }\n\n  private async _getClientId(): Promise<Uuid> {\n    const clientIdKey = 'clientId'\n\n    let clientId = await this._getMeta(clientIdKey)\n\n    if (clientId === '') {\n      clientId = genUUID()\n      await this._setMeta(clientIdKey, clientId)\n    }\n    return clientId\n  }\n\n  private async _getLocalRelations(): Promise<{ [k: string]: Relation }> {\n    return inferRelationsFromDb(this.adapter, this.opts, this.builder)\n  }\n\n  private _generateTag(timestamp: Date): string {\n    const instanceId = this._authState!.clientId\n    return generateTag(instanceId, timestamp)\n  }\n\n  async _garbageCollectOplog(commitTimestamp: Date): Promise<void> {\n    const isoString = commitTimestamp.toISOString()\n    const oplog = `${this.opts.oplogTable}`\n    const pos = (i: number) => this.builder.makePositionalParam(i)\n    await this.adapter.run({\n      sql: `DELETE FROM ${oplog} WHERE timestamp = ${pos(1)}`,\n      args: [isoString],\n    })\n  }\n\n  /**\n   * Update `this._lsn` to the new value and generate a statement to persist this change\n   *\n   * @param lsn new LSN value\n   * @returns statement to be executed to save the new LSN value in the database\n   */\n  private updateLsnStmt(lsn: LSN): Statement {\n    this._lsn = lsn\n    return this._setMetaStatement('lsn', base64.fromBytes(lsn))\n  }\n\n  public setReplicationTransform(\n    tableName: QualifiedTablename,\n    transform: ReplicatedRowTransformer<DataRecord>\n  ): void {\n    this.client.setReplicationTransform(tableName, transform)\n  }\n\n  public clearReplicationTransform(tableName: QualifiedTablename): void {\n    this.client.clearReplicationTransform(tableName)\n  }\n\n  _applyDeleteOperation(\n    entryChanges: ShadowEntryChanges,\n    qualifiedTableName: QualifiedTablename\n  ): Statement {\n    const pkEntries = Object.entries(entryChanges.primaryKeyCols)\n    if (pkEntries.length === 0)\n      throw new Error(\n        \"Can't apply delete operation. None of the columns in changes are marked as PK.\"\n      )\n    let i = 1\n    const pos = (i: number) => this.builder.makePositionalParam(i)\n    const params = pkEntries.reduce(\n      (acc, [column, value]) => {\n        acc.where.push(`${column} = ${pos(i++)}`)\n        acc.values.push(value)\n        return acc\n      },\n      { where: [] as string[], values: [] as SqlValue[] }\n    )\n\n    return {\n      sql: `DELETE FROM \"${qualifiedTableName.namespace}\".\"${\n        qualifiedTableName.tablename\n      }\" WHERE ${params.where.join(' AND ')}`,\n      args: params.values,\n    }\n  }\n\n  _applyNonDeleteOperation(\n    { fullRow, primaryKeyCols }: ShadowEntryChanges,\n    qualifiedTableName: QualifiedTablename\n  ): Statement {\n    const columnNames = Object.keys(fullRow)\n    const columnValues = Object.values(fullRow)\n    const updateColumnStmts = columnNames.filter((c) => !(c in primaryKeyCols))\n\n    if (updateColumnStmts.length > 0) {\n      return this.builder.insertOrReplaceWith(\n        qualifiedTableName,\n        columnNames,\n        columnValues,\n        Object.keys(primaryKeyCols),\n        updateColumnStmts,\n        updateColumnStmts.map((col) => fullRow[col])\n      )\n    }\n\n    // no changes, can ignore statement if exists\n    return this.builder.insertOrIgnore(\n      qualifiedTableName,\n      columnNames,\n      columnValues\n    )\n  }\n\n  private async checkMaxSqlParameters() {\n    if (this.builder.dialect === 'SQLite') {\n      const [{ version }] = (await this.adapter.query({\n        sql: 'SELECT sqlite_version() AS version',\n      })) as [{ version: string }]\n\n      const [major, minor, _patch] = version.split('.').map((x) => parseInt(x))\n\n      if (major === 3 && minor >= 32) this.maxSqlParameters = 32766\n      else this.maxSqlParameters = 999\n    } else {\n      // Postgres allows a maximum of 65535 query parameters\n      this.maxSqlParameters = 65535\n    }\n  }\n}\n\nexport function generateTriggersForTable(\n  tbl: MigrationTable,\n  builder: QueryBuilder\n): Statement[] {\n  const table = {\n    qualifiedTableName: new QualifiedTablename(\n      builder.defaultNamespace,\n      tbl.name\n    ),\n    columns: tbl.columns.map((col) => col.name),\n    primary: tbl.pks,\n    foreignKeys: tbl.fks.map((fk) => {\n      if (fk.fkCols.length !== 1 || fk.pkCols.length !== 1)\n        throw new Error('Satellite does not yet support compound foreign keys.')\n      return {\n        table: fk.pkTable,\n        childKey: fk.fkCols[0],\n        parentKey: fk.pkCols[0],\n      }\n    }),\n    columnTypes: Object.fromEntries(\n      tbl.columns.map((col) => [col.name, col.pgType!.name.toUpperCase()])\n    ),\n  }\n\n  return generateTableTriggers(table, builder)\n}\n"],"mappings":"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","names":["tx","acc","tablenames","i"]}