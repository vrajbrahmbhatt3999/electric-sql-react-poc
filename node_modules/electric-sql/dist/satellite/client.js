import throttle from "lodash.throttle";
import {
  SatAuthReq,
  SatAuthResp,
  SatErrorResp,
  SatErrorResp_ErrorCode,
  SatInStartReplicationReq,
  SatInStartReplicationResp,
  SatInStopReplicationReq,
  SatInStopReplicationResp,
  SatTransOp,
  SatOpRow,
  SatOpLog,
  SatRelation,
  SatRelationColumn,
  SatSubsReq,
  SatUnsubsReq,
  RootClientImpl,
  SatInStartReplicationReq_Dialect
} from '../_generated/protocol/satellite.js';
import {
  getObjFromString,
  getBufWithMsgTag,
  getTypeFromCode,
  getFullTypeName,
  startReplicationErrorToSatelliteError,
  shapeRequestToSatShapeReq,
  subsErrorToSatelliteError,
  msgToString,
  serverErrorToSatelliteError
} from '../util/proto.js';
import { PROTOCOL_VSN } from '../sockets/index.js';
import _m0 from "protobufjs/minimal.js";
import {
  DataChangeType,
  ReplicationStatus,
  SatelliteError,
  SatelliteErrorCode,
  isDataChange
} from '../util/types.js';
import {
  base64,
  sqliteTypeEncoder,
  sqliteTypeDecoder,
  bytesToNumber,
  pgTypeEncoder,
  pgTypeDecoder
} from '../util/encoders/index.js';
import { DEFAULT_LOG_POS } from '../util/common.js';
import { satelliteClientDefaults } from './config.js';
import Log from "loglevel";
import isequal from "lodash.isequal";
import {
  SUBSCRIPTION_DELIVERED,
  SUBSCRIPTION_ERROR
} from './shapes/types.js';
import { SubscriptionsDataCache } from './shapes/cache.js';
import { setMaskBit, getMaskBit } from '../util/bitmaskHelpers.js';
import { RPC, rpcRespond, withRpcRequestLogging } from './RPC.js';
import { Mutex } from "async-mutex";
import { PgBasicType, PgDateType } from '../client/conversions/types.js';
import { AsyncEventEmitter } from '../util/index.js';
import Long from "long";
const DEFAULT_ACK_PERIOD = 6e4;
const subscriptionError = [
  SatelliteErrorCode.UNEXPECTED_SUBSCRIPTION_STATE,
  SatelliteErrorCode.SUBSCRIPTION_ERROR,
  SatelliteErrorCode.SUBSCRIPTION_ALREADY_EXISTS,
  SatelliteErrorCode.SUBSCRIPTION_ID_ALREADY_EXISTS,
  SatelliteErrorCode.SUBSCRIPTION_NOT_FOUND,
  SatelliteErrorCode.SHAPE_DELIVERY_ERROR
];
class SatelliteClient {
  opts;
  dialect;
  encoder;
  decoder;
  emitter;
  socketFactory;
  socket;
  inbound;
  outbound;
  // can only handle a single subscription at a time
  subscriptionsDataCache;
  replicationTransforms = /* @__PURE__ */ new Map();
  socketHandler;
  throttledPushTransaction;
  rpcClient;
  service;
  incomingMutex = new Mutex();
  allowedMutexedRpcResponses = [];
  dbDescription;
  isDown = false;
  handlerForMessageType = Object.fromEntries(
    Object.entries({
      SatRelation: (msg) => this.handleRelation(msg),
      SatOpLog: (msg) => this.handleTransaction(msg),
      SatErrorResp: (error) => this.handleError(error),
      SatSubsDataError: (msg) => this.handleSubscriptionError(msg),
      SatSubsDataBegin: (msg) => this.handleSubscriptionDataBegin(msg),
      SatSubsDataEnd: (msg) => this.handleSubscriptionDataEnd(msg),
      SatShapeDataBegin: (msg) => this.handleShapeDataBegin(msg),
      SatShapeDataEnd: (msg) => this.handleShapeDataEnd(msg),
      SatRpcResponse: (msg) => this.rpcClient.handleResponse(msg),
      SatRpcRequest: (msg) => this.handleRpcRequest(msg),
      SatOpLogAck: (msg) => void 0,
      // Server doesn't send that
      SatUnsubsDataBegin: (msg) => this.handleUnsubsDataBegin(msg),
      SatUnsubsDataEnd: (msg) => this.handleUnsubsDataEnd(msg)
    }).map((e) => [getFullTypeName(e[0]), e[1]])
  );
  handlerForRpcRequests = {
    startReplication: this.handleStartReq.bind(this),
    stopReplication: this.handleStopReq.bind(this)
  };
  /* eslint-disable-next-line @typescript-eslint/ban-types --
   * This remapping actually is generic from a function to a function of the same type,
   * but there's no way to express that. It's needed because we're wrapping the original
   * callback in our own, which makes `.removeListener` not work.
   */
  listenerRemapping = /* @__PURE__ */ new Map();
  constructor(dbDescription, socketFactory, opts) {
    this.emitter = new AsyncEventEmitter();
    this.opts = { ...satelliteClientDefaults, ...opts };
    this.dialect = opts.dialect === "SQLite" ? SatInStartReplicationReq_Dialect.SQLITE : SatInStartReplicationReq_Dialect.POSTGRES;
    this.encoder = opts.dialect === "SQLite" ? sqliteTypeEncoder : pgTypeEncoder;
    this.decoder = opts.dialect === "SQLite" ? sqliteTypeDecoder : pgTypeDecoder;
    this.socketFactory = socketFactory;
    this.inbound = this.resetInboundReplication();
    this.outbound = this.resetReplication();
    this.dbDescription = dbDescription;
    this.subscriptionsDataCache = new SubscriptionsDataCache(
      dbDescription,
      this.decoder
    );
    this.rpcClient = new RPC(
      this.sendMessage.bind(this),
      this.opts.timeout,
      Log
    );
    this.service = withRpcRequestLogging(
      new RootClientImpl(this.rpcClient),
      Log
    );
  }
  resetReplication(last_lsn, isReplicating) {
    return {
      authenticated: false,
      isReplicating: isReplicating ? isReplicating : ReplicationStatus.STOPPED,
      relations: /* @__PURE__ */ new Map(),
      last_lsn,
      transactions: []
    };
  }
  resetInboundReplication(last_lsn, isReplicating) {
    return {
      ...this.resetReplication(last_lsn, isReplicating),
      lastTxId: void 0,
      lastAckedTxId: void 0,
      unackedTxs: 0,
      maxUnackedTxs: 30,
      ackPeriod: DEFAULT_ACK_PERIOD,
      ackTimer: setTimeout(
        () => this.maybeSendAck("timeout"),
        DEFAULT_ACK_PERIOD
      ),
      additionalData: [],
      goneBatch: [],
      receivingUnsubsBatch: false,
      unseenAdditionalDataRefs: /* @__PURE__ */ new Set(),
      seenAdditionalDataSinceLastTx: {
        dataRefs: [],
        subscriptions: [],
        gone: []
      }
    };
  }
  connect() {
    if (this.isDown) {
      throw new SatelliteError(
        SatelliteErrorCode.UNEXPECTED_STATE,
        "client has already shutdown"
      );
    }
    if (this.isConnected()) {
      this.disconnect();
    }
    return new Promise((resolve, reject) => {
      this.socket = new this.socketFactory(PROTOCOL_VSN);
      const onceError = (error) => {
        this.disconnect();
        reject(error);
      };
      const onceConnect = () => {
        if (!this.socket)
          throw new SatelliteError(
            SatelliteErrorCode.UNEXPECTED_STATE,
            "socket got unassigned somehow"
          );
        this.socket.removeErrorListener(onceError);
        this.socketHandler = (message) => this.handleIncoming(message);
        this.socket.onMessage(this.socketHandler);
        this.socket.onError((error) => {
          if (this.emitter.listenerCount("error") === 0) {
            this.disconnect();
            Log.error(
              `socket error but no listener is attached: ${error.message}`
            );
          }
          this.emitter.enqueueEmit("error", error);
        });
        this.socket.onClose((ev) => {
          this.disconnect();
          if (this.emitter.listenerCount("error") === 0) {
            Log.error(`socket closed but no listener is attached`);
          }
          this.emitter.enqueueEmit(
            "error",
            new SatelliteError(ev, "socket closed")
          );
        });
        resolve();
      };
      this.socket.onceError(onceError);
      this.socket.onceConnect(onceConnect);
      const { host, port, ssl } = this.opts;
      const url = `${ssl ? "wss" : "ws"}://${host}:${port}/ws`;
      this.socket.open({ url });
    });
  }
  disconnect() {
    this.outbound = this.resetReplication(this.outbound.last_lsn);
    this.inbound = this.resetInboundReplication(this.inbound.last_lsn);
    this.socketHandler = void 0;
    if (this.socket !== void 0) {
      this.socket.closeAndRemoveListeners();
      this.socket = void 0;
    }
  }
  isConnected() {
    return !!this.socketHandler;
  }
  getOutboundReplicationStatus() {
    return this.outbound.isReplicating;
  }
  async shutdown() {
    this.emitter.removeAllListeners();
    await this.emitter.waitForProcessing();
    this.disconnect();
    this.isDown = true;
  }
  startReplication(lsn, schemaVersion, subscriptionIds, observedTransactionData) {
    if (this.inbound.isReplicating !== ReplicationStatus.STOPPED) {
      return Promise.reject(
        new SatelliteError(
          SatelliteErrorCode.REPLICATION_ALREADY_STARTED,
          `replication already started`
        )
      );
    }
    let request;
    if (!lsn || lsn.length === 0) {
      Log.info(`no previous LSN, start replication from scratch`);
      if (subscriptionIds && subscriptionIds.length > 0) {
        return Promise.reject(
          new SatelliteError(
            SatelliteErrorCode.UNEXPECTED_SUBSCRIPTION_STATE,
            `Cannot start replication with subscription IDs but without previous LSN.`
          )
        );
      }
      request = SatInStartReplicationReq.fromPartial({
        schemaVersion,
        sqlDialect: this.dialect
      });
    } else {
      Log.info(
        `starting replication with lsn: ${base64.fromBytes(
          lsn
        )} subscriptions: ${subscriptionIds}`
      );
      request = SatInStartReplicationReq.fromPartial({
        lsn,
        subscriptionIds,
        observedTransactionData,
        sqlDialect: this.dialect
      });
    }
    this.inbound = this.resetInboundReplication(lsn, ReplicationStatus.STARTING);
    return this.delayIncomingMessages(
      async () => {
        const resp = await this.service.startReplication(request);
        return this.handleStartResp(resp);
      },
      { allowedRpcResponses: ["startReplication"] }
    );
  }
  stopReplication() {
    if (this.inbound.isReplicating !== ReplicationStatus.ACTIVE) {
      return Promise.reject(
        new SatelliteError(
          SatelliteErrorCode.REPLICATION_NOT_STARTED,
          `replication not active`
        )
      );
    }
    this.inbound.isReplicating = ReplicationStatus.STOPPING;
    const request = SatInStopReplicationReq.fromPartial({});
    return this.service.stopReplication(request).then(this.handleStopResp.bind(this));
  }
  authenticate({ clientId, token }) {
    const request = SatAuthReq.fromPartial({
      id: clientId,
      token,
      headers: []
    });
    return this.service.authenticate(request).then(this.handleAuthResp.bind(this));
  }
  subscribeToTransactions(callback) {
    this.emitter.on("transaction", async (txn, ackCb) => {
      await callback(txn);
      ackCb();
    });
  }
  unsubscribeToTransactions(callback) {
    this.emitter.removeListener("transaction", callback);
  }
  subscribeToAdditionalData(callback) {
    this.emitter.on("additionalData", async (data, ackCb) => {
      await callback(data);
      ackCb();
    });
  }
  unsubscribeToAdditionalData(_callback) {
  }
  subscribeToRelations(callback) {
    this.emitter.on("relation", callback);
  }
  unsubscribeToRelations(callback) {
    this.emitter.removeListener("relation", callback);
  }
  subscribeToGoneBatch(callback) {
    this.emitter.on("goneBatch", async (lsn, ids, changes, ack) => {
      await callback(lsn, ids, changes);
      ack();
    });
  }
  unsubscribeToGoneBatch(_callback) {
  }
  enqueueTransaction(transaction) {
    if (this.outbound.isReplicating !== ReplicationStatus.ACTIVE) {
      throw new SatelliteError(
        SatelliteErrorCode.REPLICATION_NOT_STARTED,
        "enqueuing a transaction while outbound replication has not started"
      );
    }
    transaction.changes = transaction.changes.map(
      (dc) => this._applyDataChangeTransform(dc, "outbound")
    );
    this.outbound.transactions.push(transaction);
    this.outbound.last_lsn = transaction.lsn;
    this.throttledPushTransaction?.();
  }
  pushTransactions() {
    if (this.outbound.isReplicating !== ReplicationStatus.ACTIVE) {
      throw new SatelliteError(
        SatelliteErrorCode.REPLICATION_NOT_STARTED,
        "sending a transaction while outbound replication has not started"
      );
    }
    let next;
    while (next = this.outbound.transactions.shift()) {
      this.sendMissingRelations(next, this.outbound);
      const satOpLog = this.transactionToSatOpLog(next);
      this.sendMessage(satOpLog);
    }
  }
  subscribeToError(callback) {
    this.emitter.on("error", callback);
  }
  unsubscribeToError(callback) {
    this.emitter.removeListener("error", callback);
  }
  subscribeToOutboundStarted(callback) {
    this.emitter.on("outbound_started", callback);
  }
  unsubscribeToOutboundStarted(callback) {
    this.emitter.removeListener("outbound_started", callback);
  }
  subscribeToSubscriptionEvents(successCallback, errorCallback) {
    const newCb = async (data) => {
      await successCallback(data);
      this.inbound.seenAdditionalDataSinceLastTx.subscriptions.push(
        data.subscriptionId
      );
      this.maybeSendAck("additionalData");
    };
    this.listenerRemapping.set(successCallback, newCb);
    this.emitter.on(SUBSCRIPTION_DELIVERED, newCb);
    this.subscriptionsDataCache.on(
      SUBSCRIPTION_DELIVERED,
      (data) => this.emitter.enqueueEmit(SUBSCRIPTION_DELIVERED, data)
    );
    this.emitter.on(SUBSCRIPTION_ERROR, errorCallback);
    this.subscriptionsDataCache.on(
      SUBSCRIPTION_ERROR,
      (error) => this.emitter.enqueueEmit(SUBSCRIPTION_ERROR, error)
    );
  }
  unsubscribeToSubscriptionEvents(successCallback, errorCallback) {
    this.emitter.removeListener(
      SUBSCRIPTION_DELIVERED,
      this.listenerRemapping.get(successCallback) || successCallback
    );
    this.emitter.removeListener(SUBSCRIPTION_ERROR, errorCallback);
    this.subscriptionsDataCache.removeAllListeners(SUBSCRIPTION_DELIVERED);
    this.subscriptionsDataCache.removeAllListeners(SUBSCRIPTION_ERROR);
  }
  async subscribe(subscriptionId, shapes) {
    if (this.inbound.isReplicating !== ReplicationStatus.ACTIVE) {
      return Promise.reject(
        new SatelliteError(
          SatelliteErrorCode.REPLICATION_NOT_STARTED,
          `replication not active`
        )
      );
    }
    const request = SatSubsReq.fromPartial({
      subscriptionId,
      shapeRequests: shapeRequestToSatShapeReq(shapes)
    });
    this.subscriptionsDataCache.subscriptionRequest(request);
    return this.delayIncomingMessages(
      async () => {
        const resp = await this.service.subscribe(request);
        return this.handleSubscription(resp);
      },
      { allowedRpcResponses: ["subscribe"] }
    );
  }
  unsubscribe(subscriptionIds) {
    if (this.inbound.isReplicating !== ReplicationStatus.ACTIVE) {
      return Promise.reject(
        new SatelliteError(
          SatelliteErrorCode.REPLICATION_NOT_STARTED,
          `replication not active`
        )
      );
    }
    const request = SatUnsubsReq.create({ subscriptionIds });
    return this.service.unsubscribe(request).then(this.handleUnsubscribeResponse.bind(this));
  }
  sendMissingRelations(transaction, replication) {
    transaction.changes.forEach((change) => {
      const relation = change.relation;
      if (
        // this is a new relation
        !this.outbound.relations.has(relation.id) || // or, the relation has changed
        !isequal(this.outbound.relations.get(relation.id), relation)
      ) {
        replication.relations.set(relation.id, relation);
        const satRelation = SatRelation.fromPartial({
          relationId: relation.id,
          schemaName: relation.schema,
          // TODO
          tableName: relation.table,
          tableType: relation.tableType,
          columns: relation.columns.map(
            (c) => SatRelationColumn.fromPartial({
              name: c.name,
              type: c.type,
              isNullable: c.isNullable
            })
          )
        });
        this.sendMessage(satRelation);
      }
    });
  }
  transactionToSatOpLog(transaction) {
    const ops = [
      SatTransOp.fromPartial({
        begin: {
          commitTimestamp: transaction.commit_timestamp.toString(),
          lsn: transaction.lsn
        }
      })
    ];
    transaction.changes.forEach((change) => {
      let changeOp, oldRecord, record;
      const relation = this.outbound.relations.get(change.relation.id);
      const tags = change.tags;
      if (change.oldRecord) {
        oldRecord = serializeRow(
          change.oldRecord,
          relation,
          this.dbDescription,
          this.encoder
        );
      }
      if (change.record) {
        record = serializeRow(
          change.record,
          relation,
          this.dbDescription,
          this.encoder
        );
      }
      switch (change.type) {
        case DataChangeType.DELETE:
          changeOp = SatTransOp.fromPartial({
            delete: {
              oldRowData: oldRecord,
              relationId: relation.id,
              tags
            }
          });
          break;
        case DataChangeType.INSERT:
          changeOp = SatTransOp.fromPartial({
            insert: {
              rowData: record,
              relationId: relation.id,
              tags
            }
          });
          break;
        case DataChangeType.UPDATE:
          changeOp = SatTransOp.fromPartial({
            update: {
              rowData: record,
              oldRowData: oldRecord,
              relationId: relation.id,
              tags
            }
          });
          break;
        case DataChangeType.COMPENSATION:
          changeOp = SatTransOp.fromPartial({
            compensation: {
              pkData: record,
              relationId: relation.id,
              tags
            }
          });
          break;
        case DataChangeType.GONE:
          throw new SatelliteError(
            SatelliteErrorCode.PROTOCOL_VIOLATION,
            "Client is not expected to send GONE messages"
          );
      }
      ops.push(changeOp);
    });
    ops.push(SatTransOp.fromPartial({ commit: {} }));
    return SatOpLog.fromPartial({ ops });
  }
  handleAuthResp(message) {
    let error, serverId;
    if (message.$type === SatAuthResp.$type) {
      serverId = message.id;
      this.inbound.authenticated = true;
    } else {
      error = new SatelliteError(
        SatelliteErrorCode.AUTH_ERROR,
        `An internal error occurred during authentication`
      );
    }
    return { serverId, error };
  }
  handleStartResp(resp) {
    if (this.inbound.isReplicating === ReplicationStatus.STARTING) {
      if (resp.err) {
        this.inbound.isReplicating = ReplicationStatus.STOPPED;
        return { error: startReplicationErrorToSatelliteError(resp.err) };
      } else {
        this.inbound.isReplicating = ReplicationStatus.ACTIVE;
        this.inbound.maxUnackedTxs = resp.unackedWindowSize ?? 30;
      }
    } else {
      return {
        error: new SatelliteError(
          SatelliteErrorCode.UNEXPECTED_STATE,
          `unexpected state ${this.inbound.isReplicating} handling 'start' response`
        )
      };
    }
    return {};
  }
  /**
   * Server may issue RPC requests to the client, and we're handling them here.
   */
  async handleRpcRequest(message) {
    const responder = rpcRespond(this.sendMessage.bind(this));
    if (message.method === "startReplication") {
      const decoded = SatInStartReplicationReq.decode(message.message);
      responder(
        message,
        await this.handlerForRpcRequests[message.method](decoded)
      );
    } else if (message.method === "stopReplication") {
      const decoded = SatInStopReplicationReq.decode(message.message);
      responder(
        message,
        await this.handlerForRpcRequests[message.method](decoded)
      );
    } else {
      Log.warn(
        `Server has sent an RPC request with a method that the client does not support: ${message.method}`
      );
      responder(
        message,
        SatErrorResp.create({
          errorType: SatErrorResp_ErrorCode.INVALID_REQUEST
        })
      );
    }
  }
  async handleStartReq(message) {
    Log.info(
      `Server sent a replication request to start from ${bytesToNumber(
        message.lsn
      )}, and options ${JSON.stringify(message.options)}`
    );
    if (this.outbound.isReplicating === ReplicationStatus.STOPPED) {
      this.outbound = this.resetReplication(
        message.lsn,
        ReplicationStatus.ACTIVE
      );
      this.throttledPushTransaction = throttle(
        () => this.pushTransactions(),
        this.opts.pushPeriod,
        { leading: true, trailing: true }
      );
      this.emitter.enqueueEmit("outbound_started");
      return SatInStartReplicationResp.create();
    } else {
      this.emitter.enqueueEmit(
        "error",
        new SatelliteError(
          SatelliteErrorCode.UNEXPECTED_STATE,
          `unexpected state ${this.outbound.isReplicating} handling 'start' request`
        )
      );
      return SatErrorResp.create({
        errorType: SatErrorResp_ErrorCode.REPLICATION_FAILED
      });
    }
  }
  async handleStopReq(_message) {
    if (this.outbound.isReplicating === ReplicationStatus.ACTIVE) {
      this.outbound.isReplicating = ReplicationStatus.STOPPED;
      if (this.throttledPushTransaction) {
        this.throttledPushTransaction = void 0;
      }
      return SatInStopReplicationResp.create();
    } else {
      this.emitter.enqueueEmit(
        "error",
        new SatelliteError(
          SatelliteErrorCode.UNEXPECTED_STATE,
          `unexpected state ${this.inbound.isReplicating} handling 'stop' request`
        )
      );
      return SatErrorResp.create({
        errorType: SatErrorResp_ErrorCode.REPLICATION_FAILED
      });
    }
  }
  handleStopResp() {
    if (this.inbound.isReplicating === ReplicationStatus.STOPPING) {
      this.inbound.isReplicating = ReplicationStatus.STOPPED;
      return {};
    }
    return {
      error: new SatelliteError(
        SatelliteErrorCode.UNEXPECTED_STATE,
        `unexpected state ${this.inbound.isReplicating} handling 'stop' response`
      )
    };
  }
  handleRelation(message) {
    if (this.inbound.isReplicating !== ReplicationStatus.ACTIVE) {
      this.emitter.enqueueEmit(
        "error",
        new SatelliteError(
          SatelliteErrorCode.UNEXPECTED_STATE,
          `unexpected state ${ReplicationStatus[this.inbound.isReplicating]} handling 'relation' message`
        )
      );
      return;
    }
    let pkPosition = 1;
    const relation = {
      id: message.relationId,
      schema: message.schemaName,
      table: message.tableName,
      tableType: message.tableType,
      columns: message.columns.map((c) => ({
        name: c.name,
        type: c.type,
        isNullable: c.isNullable,
        primaryKey: c.primaryKey ? pkPosition++ : void 0
      }))
    };
    this.inbound.relations.set(relation.id, relation);
    this.emitter.enqueueEmit("relation", relation);
  }
  handleTransaction(message) {
    if (this.inbound.receivingUnsubsBatch) {
      this.processUnsubsDataMessage(message);
    } else if (this.subscriptionsDataCache.isDelivering()) {
      try {
        this.subscriptionsDataCache.transaction(message.ops);
      } catch (e) {
        Log.info(
          `Error applying transaction message for subs ${JSON.stringify(e)}`
        );
      }
    } else {
      this.processOpLogMessage(message);
    }
  }
  handleError(error) {
    this.emitter.enqueueEmit("error", serverErrorToSatelliteError(error));
  }
  handleSubscription(msg) {
    if (msg.err) {
      const error = subsErrorToSatelliteError(msg.err);
      this.subscriptionsDataCache.subscriptionError(msg.subscriptionId);
      return { subscriptionId: msg.subscriptionId, error };
    } else {
      this.subscriptionsDataCache.subscriptionResponse(msg);
      return { subscriptionId: msg.subscriptionId };
    }
  }
  handleSubscriptionError(msg) {
    this.subscriptionsDataCache.subscriptionDataError(msg.subscriptionId, msg);
  }
  handleSubscriptionDataBegin(msg) {
    this.subscriptionsDataCache.subscriptionDataBegin(msg);
  }
  handleSubscriptionDataEnd(_msg) {
    this.subscriptionsDataCache.subscriptionDataEnd(this.inbound.relations);
  }
  handleShapeDataBegin(msg) {
    this.subscriptionsDataCache.shapeDataBegin(msg);
  }
  handleShapeDataEnd(_msg) {
    this.subscriptionsDataCache.shapeDataEnd();
  }
  // For now, unsubscribe responses doesn't send any information back
  // It might eventually confirm that the server processed it or was noop.
  handleUnsubscribeResponse(_msg) {
    return {};
  }
  handleUnsubsDataBegin(msg) {
    this.inbound.receivingUnsubsBatch = msg.subscriptionIds;
    this.inbound.last_lsn = msg.lsn;
  }
  handleUnsubsDataEnd(_msg) {
    if (!this.inbound.receivingUnsubsBatch)
      throw new SatelliteError(
        SatelliteErrorCode.PROTOCOL_VIOLATION,
        "Received a `SatUnsubsDataEnd` message but not the begin message"
      );
    const subscriptionIds = [...this.inbound.receivingUnsubsBatch];
    this.emitter.enqueueEmit(
      "goneBatch",
      this.inbound.last_lsn,
      subscriptionIds,
      this.inbound.goneBatch,
      () => {
        this.inbound.seenAdditionalDataSinceLastTx.gone.push(...subscriptionIds);
        this.maybeSendAck("additionalData");
      }
    );
    this.inbound.receivingUnsubsBatch = false;
    this.inbound.goneBatch = [];
  }
  delayIncomingMessages(fn, opts) {
    return this.incomingMutex.runExclusive(async () => {
      this.allowedMutexedRpcResponses = opts.allowedRpcResponses;
      try {
        return await fn();
      } finally {
        this.allowedMutexedRpcResponses = [];
      }
    });
  }
  // TODO: properly handle socket errors; update connectivity state
  async handleIncoming(data) {
    try {
      const message = toMessage(data);
      if (this.incomingMutex.isLocked() && !(message.$type === "Electric.Satellite.SatRpcResponse" && this.allowedMutexedRpcResponses.includes(message.method))) {
        await this.incomingMutex.waitForUnlock();
      }
      if (Log.getLevel() <= 1) {
        Log.debug(`[proto] recv: ${msgToString(message)}`);
      }
      this.handlerForMessageType[message.$type]?.(message);
    } catch (error) {
      if (error instanceof SatelliteError) {
        if (!subscriptionError.includes(error.code)) {
          this.emitter.enqueueEmit("error", error);
        }
      } else {
        throw error;
      }
    }
  }
  getRelation({ relationId }) {
    const rel = this.inbound.relations.get(relationId);
    if (!rel) {
      throw new SatelliteError(
        SatelliteErrorCode.PROTOCOL_VIOLATION,
        `missing relation ${relationId} for incoming operation`
      );
    }
    return rel;
  }
  processUnsubsDataMessage(msg) {
    msg.ops.forEach((op) => {
      if (!op.gone)
        throw new SatelliteError(
          SatelliteErrorCode.PROTOCOL_VIOLATION,
          "Expected to see only GONE messages in unsubscription data"
        );
      const rel = this.getRelation(op.gone);
      this.inbound.goneBatch.push({
        relation: rel,
        type: DataChangeType.GONE,
        oldRecord: deserializeRow(
          op.gone.pkData,
          rel,
          this.dbDescription,
          this.decoder
        ),
        tags: []
      });
    });
  }
  processOpLogMessage(opLogMessage) {
    const replication = this.inbound;
    opLogMessage.ops.map((op) => {
      if (op.begin) {
        const transaction = {
          commit_timestamp: op.begin.commitTimestamp,
          lsn: op.begin.lsn,
          changes: [],
          origin: op.begin.origin,
          id: op.begin.transactionId
        };
        replication.incomplete = "transaction";
        replication.transactions.push(transaction);
      }
      if (op.additionalBegin) {
        replication.incomplete = "additionalData";
        replication.additionalData.push({
          ref: op.additionalBegin.ref,
          changes: []
        });
      }
      const lastTxnIdx = replication.transactions.length - 1;
      const lastDataIdx = replication.additionalData.length - 1;
      if (op.commit) {
        if (replication.incomplete !== "transaction")
          throw new Error("Unexpected commit message while not waiting for txn");
        const { commit_timestamp, lsn, changes, origin, migrationVersion, id } = replication.transactions[lastTxnIdx];
        const transformedChanges = changes.map((change) => {
          if (!isDataChange(change))
            return change;
          return this._applyDataChangeTransform(change, "inbound");
        });
        const transaction = {
          commit_timestamp,
          lsn,
          changes: transformedChanges,
          origin,
          migrationVersion,
          id,
          additionalDataRef: op.commit.additionalDataRef.isZero() ? void 0 : op.commit.additionalDataRef
        };
        this.emitter.enqueueEmit("transaction", transaction, () => {
          this.inbound.last_lsn = transaction.lsn;
          this.inbound.lastTxId = transaction.id;
          this.inbound.unackedTxs++;
          this.inbound.seenAdditionalDataSinceLastTx = {
            dataRefs: [],
            subscriptions: [],
            gone: []
          };
          this.maybeSendAck();
        });
        replication.transactions.splice(lastTxnIdx);
        replication.incomplete = void 0;
        if (!op.commit.additionalDataRef.isZero())
          replication.unseenAdditionalDataRefs.add(
            op.commit.additionalDataRef.toString()
          );
      }
      if (op.additionalCommit) {
        if (replication.incomplete !== "additionalData")
          throw new Error(
            "Unexpected additionalCommit message while not waiting for additionalData"
          );
        const ref = op.additionalCommit.ref;
        this.emitter.enqueueEmit(
          "additionalData",
          replication.additionalData[lastDataIdx],
          () => {
            this.inbound.seenAdditionalDataSinceLastTx.dataRefs.push(ref);
            this.maybeSendAck("additionalData");
          }
        );
        replication.additionalData.splice(lastDataIdx);
        replication.incomplete = void 0;
        replication.unseenAdditionalDataRefs.delete(ref.toString());
      }
      if (op.insert) {
        const rel = this.getRelation(op.insert);
        const change = {
          relation: rel,
          type: DataChangeType.INSERT,
          record: deserializeRow(
            op.insert.rowData,
            rel,
            this.dbDescription,
            this.decoder
          ),
          tags: op.insert.tags
        };
        if (replication.incomplete === "transaction") {
          replication.transactions[lastTxnIdx].changes.push(change);
        } else {
          replication.additionalData[lastDataIdx].changes.push(change);
        }
      }
      if (op.update) {
        const rel = this.getRelation(op.update);
        const change = {
          relation: rel,
          type: DataChangeType.UPDATE,
          record: deserializeRow(
            op.update.rowData,
            rel,
            this.dbDescription,
            this.decoder
          ),
          oldRecord: deserializeRow(
            op.update.oldRowData,
            rel,
            this.dbDescription,
            this.decoder
          ),
          tags: op.update.tags
        };
        replication.transactions[lastTxnIdx].changes.push(change);
      }
      if (op.delete) {
        const rel = this.getRelation(op.delete);
        const change = {
          relation: rel,
          type: DataChangeType.DELETE,
          oldRecord: deserializeRow(
            op.delete.oldRowData,
            rel,
            this.dbDescription,
            this.decoder
          ),
          tags: op.delete.tags
        };
        replication.transactions[lastTxnIdx].changes.push(change);
      }
      if (op.gone) {
        const rel = this.getRelation(op.gone);
        const change = {
          relation: rel,
          type: DataChangeType.GONE,
          oldRecord: deserializeRow(
            op.gone.pkData,
            rel,
            this.dbDescription,
            this.decoder
          ),
          tags: []
        };
        replication.transactions[lastTxnIdx].changes.push(change);
      }
      if (op.migrate) {
        const tx = replication.transactions[lastTxnIdx];
        tx.migrationVersion = op.migrate.version;
        const stmts = op.migrate.stmts;
        stmts.forEach((stmt) => {
          const change = {
            table: op.migrate.table,
            migrationType: stmt.type,
            sql: stmt.sql
          };
          tx.changes.push(change);
        });
      }
    });
  }
  sendMessage(request) {
    if (Log.getLevel() <= 1)
      Log.debug(`[proto] send: ${msgToString(request)}`);
    if (!this.socket || !this.isConnected()) {
      throw new SatelliteError(
        SatelliteErrorCode.UNEXPECTED_STATE,
        "trying to send message, but client is closed"
      );
    }
    const obj = getObjFromString(request.$type);
    if (obj === void 0) {
      throw new SatelliteError(
        SatelliteErrorCode.UNEXPECTED_MESSAGE_TYPE,
        `${request.$type})`
      );
    }
    const type = getBufWithMsgTag(request);
    const msg = obj.encode(request, _m0.Writer.create()).finish();
    const buffer = new Uint8Array(type.length + msg.length);
    buffer.set(type, 0);
    buffer.set(msg, 1);
    this.socket.write(buffer);
  }
  getLastSentLsn() {
    return this.outbound.last_lsn ?? DEFAULT_LOG_POS;
  }
  maybeSendAck(reason) {
    if (reason === "timeout")
      this.inbound.ackTimer = setTimeout(
        () => this.maybeSendAck("timeout"),
        this.inbound.ackPeriod
      );
    if (!this.socket || !this.isConnected())
      return;
    if (this.inbound.lastTxId === void 0)
      return;
    if (this.inbound.lastAckedTxId?.eq(this.inbound.lastTxId))
      return;
    const boundary = Math.floor(this.inbound.maxUnackedTxs * 0.7);
    if (this.inbound.unackedTxs >= boundary || reason === "timeout" || reason === "additionalData") {
      const msg = {
        $type: "Electric.Satellite.SatOpLogAck",
        ackTimestamp: Long.UZERO.add((/* @__PURE__ */ new Date()).getTime()),
        lsn: this.inbound.last_lsn,
        transactionId: this.inbound.lastTxId,
        subscriptionIds: this.inbound.seenAdditionalDataSinceLastTx.subscriptions,
        additionalDataSourceIds: this.inbound.seenAdditionalDataSinceLastTx.dataRefs,
        goneSubscriptionIds: this.inbound.seenAdditionalDataSinceLastTx.gone
      };
      this.sendMessage(msg);
      this.inbound.lastAckedTxId = msg.transactionId;
    }
  }
  setReplicationTransform(tableName, transform) {
    this.replicationTransforms.set(tableName.tablename, transform);
  }
  clearReplicationTransform(tableName) {
    this.replicationTransforms.delete(tableName.tablename);
  }
  _applyDataChangeTransform(dataChange, dataFlow) {
    const transforms = this.replicationTransforms.get(dataChange.relation.table);
    if (!transforms)
      return dataChange;
    const transformToUse = dataFlow === "inbound" ? transforms.transformInbound : transforms.transformOutbound;
    try {
      return {
        ...dataChange,
        record: dataChange.record && transformToUse(dataChange.record),
        oldRecord: dataChange.oldRecord && transformToUse(dataChange.oldRecord)
      };
    } catch (err) {
      throw new SatelliteError(
        SatelliteErrorCode.REPLICATION_TRANSFORM_ERROR,
        err.message
      );
    }
  }
}
function getColumnType(dbDescription, table, column) {
  if (dbDescription.hasTable(table) && dbDescription.getFields(table).has(column.name)) {
    return dbDescription.getFields(table).get(column.name);
  } else {
    return column.type.toUpperCase();
  }
}
function serializeRow(rec, relation, dbDescription, encoder) {
  let recordNumColumn = 0;
  const recordNullBitMask = new Uint8Array(
    calculateNumBytes(relation.columns.length)
  );
  const recordValues = relation.columns.reduce(
    (acc, c) => {
      const columnValue = rec[c.name];
      if (columnValue !== null && columnValue !== void 0) {
        const pgColumnType = getColumnType(dbDescription, relation.table, c);
        acc.push(serializeColumnData(columnValue, pgColumnType, encoder));
      } else {
        acc.push(serializeNullData());
        setMaskBit(recordNullBitMask, recordNumColumn);
      }
      recordNumColumn = recordNumColumn + 1;
      return acc;
    },
    []
  );
  return SatOpRow.fromPartial({
    nullsBitmask: recordNullBitMask,
    values: recordValues
  });
}
function deserializeRow(row, relation, dbDescription, decoder) {
  if (row === void 0) {
    return void 0;
  }
  return relation.columns.reduce((deserializedRow, c, i) => {
    if (getMaskBit(row.nullsBitmask, i) === 1) {
      deserializedRow[c.name] = null;
    } else {
      const pgColumnType = getColumnType(dbDescription, relation.table, c);
      deserializedRow[c.name] = deserializeColumnData(
        row.values[i],
        pgColumnType,
        decoder
      );
    }
    return deserializedRow;
  }, {});
}
function calculateNumBytes(column_num) {
  const rem = column_num % 8;
  if (rem === 0) {
    return column_num / 8;
  } else {
    return 1 + (column_num - rem) / 8;
  }
}
function deserializeColumnData(column, columnType, decoder) {
  switch (columnType) {
    case PgBasicType.PG_BOOL:
      return decoder.bool(column);
    case PgBasicType.PG_INT:
    case PgBasicType.PG_INT2:
    case PgBasicType.PG_INT4:
    case PgBasicType.PG_INTEGER:
      return Number(decoder.text(column));
    case PgBasicType.PG_FLOAT4:
    case PgBasicType.PG_FLOAT8:
    case PgBasicType.PG_REAL:
      return decoder.float(column);
    case PgDateType.PG_TIMETZ:
      return decoder.timetz(column);
    case PgBasicType.PG_BYTEA:
      return decoder.bytea(column);
    case PgBasicType.PG_JSON:
    case PgBasicType.PG_JSONB:
      return decoder.json(column);
    default:
      return decoder.text(column);
  }
}
function serializeColumnData(columnValue, columnType, encoder) {
  switch (columnType) {
    case PgBasicType.PG_BOOL:
      return encoder.bool(columnValue);
    case PgDateType.PG_TIMETZ:
      return encoder.timetz(columnValue);
    case PgBasicType.PG_BYTEA:
      return encoder.bytea(columnValue);
    case PgBasicType.PG_JSON:
    case PgBasicType.PG_JSONB:
      return encoder.json(columnValue);
    default:
      return encoder.text(String(columnValue));
  }
}
function serializeNullData() {
  return new Uint8Array();
}
function toMessage(data) {
  const code = data[0];
  const type = getTypeFromCode(code);
  const obj = getObjFromString(type);
  if (obj === void 0) {
    throw new SatelliteError(
      SatelliteErrorCode.UNEXPECTED_MESSAGE_TYPE,
      `${code})`
    );
  }
  return obj.decode(data.subarray(1));
}
export {
  SatelliteClient,
  deserializeRow,
  serializeRow,
  toMessage
};
//# sourceMappingURL=client.js.map