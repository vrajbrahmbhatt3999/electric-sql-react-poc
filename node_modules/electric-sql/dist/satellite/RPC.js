import {
  SatRpcRequest,
  SatRpcResponse
} from '../_generated/protocol/satellite.js';
import { SatelliteError, SatelliteErrorCode } from '../util/types.js';
import { emptyPromise } from '../util/common.js';
import { encodeRpcResponse, msgToString } from '../util/index.js';
import { isDebuggingNode } from '../util/debug/index.js';
class RPC {
  constructor(sender, defaultTimeout, log) {
    this.sender = sender;
    this.defaultTimeout = defaultTimeout;
    this.log = log;
  }
  /** Monotonically increasing request id */
  nextRequestId = 1;
  /** Known pending requests and the promise resolvers for them */
  pendingRequests = /* @__PURE__ */ new Map();
  /** Set of request identifiers that had timed out, for better errors */
  timedOutCalls = /* @__PURE__ */ new Set();
  /**
   * Perform given RPC method using given message as data.
   *
   * This fulfills unexported generated interface `RPC` in `_generated/protocol/satellite.ts`.
   * The generated service instance expects to pass in an already-encoded message because RPC
   * is assumed to be part of the transport and not the protocol. Service instance also expects
   * to receive a still-encoded response.
   *
   * The details of the RPC contract are available in `.proto` file for the Satellite protocol,
   * but the gist is that there are two special messages in the Satellite protocol: `SatRpcRequest`
   * and `SatRpcResponse` that facilitate the call.
   */
  request(_service, method, message) {
    const requestId = this.nextRequestId++;
    const request = SatRpcRequest.create({
      method,
      requestId,
      message
    });
    this.sender(request);
    const { promise, resolve, reject } = emptyPromise();
    let timer = 0;
    if (!isDebuggingNode) {
      timer = setTimeout(
        () => this.timedOut(`${method}/${requestId}`),
        this.defaultTimeout
      );
    }
    this.pendingRequests.set(`${method}/${requestId}`, {
      reject,
      resolve,
      timer
    });
    return promise;
  }
  /**
   * Handle RPC response, dispatching it to the appropriate listener if relevant
   */
  handleResponse(rpc) {
    const callIdentifier = `${rpc.method}/${rpc.requestId}`;
    const pending = this.pendingRequests.get(callIdentifier);
    if (pending) {
      if (rpc.message) {
        pending.resolve(rpc.message);
      } else {
        this.log.warn(
          `RPC call ${callIdentifier} failed with ${msgToString(rpc.error)}`
        );
        pending.reject(rpc.error);
      }
      this.clearAndDelete(callIdentifier);
    } else if (this.timedOutCalls.has(callIdentifier)) {
      this.timedOutCalls.delete(callIdentifier);
      this.log.warn(`Got an RPC response for ${callIdentifier} after timeout`);
    } else {
      this.log.warn(`Got an unexpected RPC response for ${callIdentifier}`);
    }
  }
  clearAndDelete(callIdentifier) {
    const pending = this.pendingRequests.get(callIdentifier);
    if (pending) {
      clearTimeout(pending.timer);
      this.pendingRequests.delete(callIdentifier);
    }
  }
  timedOut(callIdentifier) {
    const pending = this.pendingRequests.get(callIdentifier);
    if (pending) {
      this.log.error(
        `Timed out after ${this.defaultTimeout}ms while waiting for RPC response to ${callIdentifier}`
      );
      this.timedOutCalls.add(callIdentifier);
      pending.reject(
        new SatelliteError(SatelliteErrorCode.TIMEOUT, callIdentifier)
      );
      this.clearAndDelete(callIdentifier);
    }
  }
}
const rpcRespond = (send) => (req, respOrError) => {
  const error = respOrError.$type === "Electric.Satellite.SatErrorResp" ? respOrError : void 0;
  const message = respOrError.$type !== "Electric.Satellite.SatErrorResp" ? encodeRpcResponse(respOrError) : void 0;
  send(
    SatRpcResponse.create({
      requestId: req.requestId,
      method: req.method,
      message,
      error
    })
  );
};
function withRpcRequestLogging(service, logger) {
  return new Proxy(service, {
    get(target, p, _receiver) {
      if (typeof target[p] === "function") {
        return new Proxy(target[p], {
          apply(target2, thisArg, argArray) {
            if (logger.getLevel() <= 1)
              logger.debug(`[rpc] send: ${msgToString(argArray[0])}`);
            return Reflect.apply(target2, thisArg, argArray).then(
              (x) => {
                if (logger.getLevel() <= 1)
                  logger.debug(`[rpc] recv: ${msgToString(x)}`);
                return x;
              }
            );
          }
        });
      } else {
        return Reflect.get(target, p);
      }
    }
  });
}
export {
  RPC,
  rpcRespond,
  withRpcRequestLogging
};
//# sourceMappingURL=RPC.js.map