import {
  localOperationsToTableChanges,
  remoteOperationsToTableChanges,
  generateTag,
  OPTYPES
} from './oplog.js';
import { difference, union } from '../util/sets.js';
function mergeEntries(localOrigin, local, incomingOrigin, incoming, relations) {
  const localTableChanges = localOperationsToTableChanges(
    local,
    (timestamp) => {
      return generateTag(localOrigin, timestamp);
    },
    relations
  );
  const incomingTableChanges = remoteOperationsToTableChanges(
    incoming,
    relations
  );
  for (const [tablename, incomingMapping] of Object.entries(
    incomingTableChanges
  )) {
    const localMapping = localTableChanges[tablename];
    if (localMapping === void 0) {
      continue;
    }
    for (const [primaryKey, incomingChanges] of Object.entries(
      incomingMapping
    )) {
      const localInfo = localMapping[primaryKey];
      if (localInfo === void 0) {
        continue;
      }
      const [_, localChanges] = localInfo;
      let changes;
      if (incomingChanges.optype === "GONE") {
        changes = localChanges.changes;
      } else {
        changes = mergeChangesLastWriteWins(
          localOrigin,
          localChanges.changes,
          incomingOrigin,
          incomingChanges.changes,
          incomingChanges.fullRow
        );
      }
      let optype;
      const tags = mergeOpTags(localChanges, incomingChanges);
      if (tags.length === 0) {
        optype = OPTYPES.delete;
      } else {
        optype = OPTYPES.upsert;
      }
      Object.assign(incomingChanges, { changes, optype, tags });
    }
  }
  return incomingTableChanges;
}
const mergeChangesLastWriteWins = (firstOrigin, first, secondOrigin, second, fullRow) => {
  const allKeys = Object.keys(first).concat(Object.keys(second));
  const uniqueKeys = Array.from(new Set(allKeys));
  const initialValue = {};
  return uniqueKeys.reduce((acc, key) => {
    const firstValue = first[key];
    const secondValue = second[key];
    if (firstValue === void 0 && secondValue === void 0) {
      return acc;
    }
    if (firstValue === void 0) {
      acc[key] = secondValue;
    } else if (secondValue === void 0) {
      acc[key] = firstValue;
    } else {
      if (firstValue.timestamp === secondValue.timestamp) {
        acc[key] = firstOrigin > secondOrigin ? firstValue : secondValue;
      } else {
        acc[key] = firstValue.timestamp > secondValue.timestamp ? firstValue : secondValue;
      }
    }
    fullRow[key] = acc[key].value;
    return acc;
  }, initialValue);
};
function mergeOpTags(local, remote) {
  if (remote.optype === "GONE")
    return [];
  return calculateTags(local.tag, remote.tags, local.clearTags);
}
function calculateTags(tag, tags, clear) {
  if (tag === null) {
    return difference(tags, clear);
  } else {
    return union([tag], difference(tags, clear));
  }
}
export {
  mergeChangesLastWriteWins,
  mergeEntries
};
//# sourceMappingURL=merge.js.map