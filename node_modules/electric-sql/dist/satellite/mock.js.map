{"version":3,"sources":["../../src/satellite/mock.ts"],"sourcesContent":["import { AuthState } from '../auth/index'\nimport { DatabaseAdapter } from '../electric/adapter'\nimport { Migrator } from '../migrators/index'\nimport { Notifier } from '../notifiers/index'\nimport { sleepAsync } from '../util/timer'\nimport {\n  AuthResponse,\n  DbName,\n  LSN,\n  SatelliteError,\n  DataTransaction,\n  Relation,\n  SatelliteErrorCode,\n  RelationsCache,\n  DbRecord as DataRecord,\n  StartReplicationResponse,\n  StopReplicationResponse,\n  OutboundStartedCallback,\n  TransactionCallback,\n  SocketCloseReason,\n  ReplicationStatus,\n  AdditionalDataCallback,\n  ConnectivityState,\n  ReplicatedRowTransformer,\n  GoneBatchCallback,\n  DataGone,\n  DataChangeType,\n  DbRecord,\n} from '../util/types'\nimport { ElectricConfig } from '../config/index'\n\nimport { Client, Satellite } from './index'\nimport { SatelliteOpts, SatelliteOverrides, satelliteDefaults } from './config'\nimport { BaseRegistry } from './registry'\nimport { SocketFactory } from '../sockets'\nimport {\n  DEFAULT_LOG_POS,\n  subsDataErrorToSatelliteError,\n  AsyncEventEmitter,\n  genUUID,\n  QualifiedTablename,\n} from '../util'\nimport { base64, bytesToNumber } from '../util/encoders'\nimport { generateTag } from './oplog'\nimport {\n  Shape,\n  InitialDataChange,\n  SUBSCRIPTION_DELIVERED,\n  SUBSCRIPTION_ERROR,\n  ShapeRequest,\n  SubscribeResponse,\n  SubscriptionData,\n  SubscriptionDeliveredCallback,\n  SubscriptionErrorCallback,\n  UnsubscribeResponse,\n} from './shapes/types'\nimport {\n  SatSubsDataError,\n  SatSubsDataError_Code,\n  SatSubsDataError_ShapeReqError,\n  SatSubsDataError_ShapeReqError_Code,\n} from '../_generated/protocol/satellite'\nimport { ShapeSubscription } from './process'\nimport { DbSchema } from '../client/model/schema'\nimport { SyncStatus } from '../client/model/shapes'\nimport { getTableNamesForShapes } from './shapes/shapeManager'\n\nexport const MOCK_BEHIND_WINDOW_LSN = 42\nexport const MOCK_INTERNAL_ERROR = 27\n\nexport class MockSatelliteProcess implements Satellite {\n  dbName: DbName\n  adapter: DatabaseAdapter\n  migrator: Migrator\n  notifier: Notifier\n  socketFactory: SocketFactory\n  opts: SatelliteOpts\n  token: string | undefined\n  connectivityState?: ConnectivityState\n\n  constructor(\n    dbName: DbName,\n    adapter: DatabaseAdapter,\n    migrator: Migrator,\n    notifier: Notifier,\n    socketFactory: SocketFactory,\n    opts: SatelliteOpts\n  ) {\n    this.dbName = dbName\n    this.adapter = adapter\n    this.migrator = migrator\n    this.notifier = notifier\n    this.socketFactory = socketFactory\n    this.opts = opts\n    this.connectivityState = { status: 'disconnected' }\n  }\n\n  syncStatus(_key: string): SyncStatus {\n    return undefined\n  }\n\n  subscribe(_shapeDefinitions: Shape[]): Promise<ShapeSubscription> {\n    return Promise.resolve({\n      key: 'test',\n      synced: Promise.resolve(),\n    })\n  }\n\n  unsubscribe(_shapeUuid: any): Promise<void> {\n    throw new Error('Method not implemented.')\n  }\n\n  async start(): Promise<void> {\n    await sleepAsync(50)\n  }\n\n  setToken(token: string): void {\n    this.token = token\n  }\n\n  hasToken() {\n    return this.token !== undefined\n  }\n\n  async connect(): Promise<void> {\n    await sleepAsync(50)\n  }\n\n  async connectWithBackoff(): Promise<void> {\n    await this.connect()\n  }\n\n  disconnect(): void {}\n  clientDisconnect(): void {}\n\n  authenticate(_token: string): Promise<void> {\n    return Promise.resolve()\n  }\n\n  async stop(): Promise<void> {\n    await sleepAsync(50)\n  }\n\n  setReplicationTransform(\n    _tableName: QualifiedTablename,\n    _transform: ReplicatedRowTransformer<DataRecord>\n  ): void {}\n\n  clearReplicationTransform(_tableName: QualifiedTablename): void {}\n}\n\nexport class MockRegistry extends BaseRegistry {\n  private shouldFailToStart = false\n\n  setShouldFailToStart(shouldFail: boolean): void {\n    this.shouldFailToStart = shouldFail\n  }\n\n  async startProcess(\n    dbName: DbName,\n    _dbDescription: DbSchema<any>,\n    adapter: DatabaseAdapter,\n    migrator: Migrator,\n    notifier: Notifier,\n    socketFactory: SocketFactory,\n    _config: ElectricConfig,\n    overrides?: SatelliteOverrides\n  ): Promise<Satellite> {\n    if (this.shouldFailToStart) {\n      throw new Error('Failed to start satellite process')\n    }\n\n    const namespace = migrator.queryBuilder.defaultNamespace\n    const opts = { ...satelliteDefaults(namespace), ...overrides }\n\n    const satellites = this.satellites\n    if (satellites[dbName] !== undefined) {\n      return satellites[dbName]\n    }\n\n    const satellite = new MockSatelliteProcess(\n      dbName,\n      adapter,\n      migrator,\n      notifier,\n      socketFactory,\n      opts\n    )\n    this.satellites[dbName] = satellite\n    await satellite.start()\n    return satellite\n  }\n}\n\ntype Events = {\n  [SUBSCRIPTION_DELIVERED]: (data: SubscriptionData) => void\n  [SUBSCRIPTION_ERROR]: (error: SatelliteError, subscriptionId: string) => void\n  outbound_started: OutboundStartedCallback\n  error: (error: SatelliteError) => void\n  goneBatch: GoneBatchCallback\n}\nexport class MockSatelliteClient\n  extends AsyncEventEmitter<Events>\n  implements Client\n{\n  isDown = false\n  replicating = false\n  disconnected = true\n  inboundAck: Uint8Array = DEFAULT_LOG_POS\n\n  outboundSent: Uint8Array = DEFAULT_LOG_POS\n  outboundTransactionsEnqueued: DataTransaction[] = []\n\n  // to clear any pending timeouts\n  timeouts: NodeJS.Timeout[] = []\n\n  relations: RelationsCache = {}\n  relationsCb?: (relation: Relation) => void\n  transactionsCb?: TransactionCallback\n  additionalDataCb?: AdditionalDataCallback\n\n  outboundStartedCallback?: OutboundStartedCallback\n\n  relationData: Record<string, DataRecord[]> = {}\n  goneBatches: Record<string, DataGone[]> = {}\n\n  deliverFirst = false\n  doSkipNextEmit = false\n\n  private startReplicationDelayMs: number | null = null\n\n  private replicationTransforms: Map<\n    string,\n    ReplicatedRowTransformer<DbRecord>\n  > = new Map()\n\n  setStartReplicationDelayMs(delayMs: number | null) {\n    this.startReplicationDelayMs = delayMs\n  }\n\n  setRelations(relations: RelationsCache): void {\n    this.relations = relations\n    if (this.relationsCb) {\n      Object.values(relations).forEach(this.relationsCb)\n    }\n  }\n\n  setRelationData(tablename: string, record: DataRecord): void {\n    if (!this.relationData[tablename]) {\n      this.relationData[tablename] = []\n    }\n    const data = this.relationData[tablename]\n\n    data.push(record)\n  }\n\n  setGoneBatch(\n    subscriptionId: string,\n    batch: { tablename: string; record: DataGone['oldRecord'] }[]\n  ): void {\n    this.goneBatches[subscriptionId] = batch.map((x) => ({\n      type: DataChangeType.GONE,\n      tags: [],\n      relation: this.relations[x.tablename],\n      oldRecord: x.record,\n    }))\n  }\n\n  enableDeliverFirst() {\n    this.deliverFirst = true\n  }\n\n  skipNextEmit() {\n    this.doSkipNextEmit = true\n  }\n\n  subscribe(\n    subscriptionId: string,\n    shapes: ShapeRequest[]\n  ): Promise<SubscribeResponse> {\n    const data: InitialDataChange[] = []\n    const shapeReqToUuid: Record<string, string> = {}\n\n    for (const shape of shapes) {\n      const tables = getTableNamesForShapes([shape.definition], 'main')\n      for (const { tablename } of tables) {\n        if (tablename === 'failure' || tablename === 'Items') {\n          return Promise.resolve({\n            subscriptionId,\n            error: new SatelliteError(SatelliteErrorCode.TABLE_NOT_FOUND),\n          })\n        } else if (tablename === 'another' || tablename === 'User') {\n          return new Promise((resolve) => {\n            this.sendErrorAfterTimeout(subscriptionId, 1)\n            resolve({\n              subscriptionId,\n            })\n          })\n        } else {\n          shapeReqToUuid[shape.requestId] = genUUID()\n          const records: DataRecord[] = this.relationData[tablename] ?? []\n\n          for (const record of records) {\n            const dataChange: InitialDataChange = {\n              relation: this.relations[tablename],\n              record,\n              tags: [generateTag('remote', new Date())],\n            }\n            data.push(dataChange)\n          }\n        }\n      }\n    }\n\n    return new Promise((resolve) => {\n      const emit = () => {\n        this.enqueueEmit(SUBSCRIPTION_DELIVERED, {\n          subscriptionId,\n          lsn: base64.toBytes('MTIz'), // base64.encode(\"123\")\n          data,\n          shapeReqToUuid,\n        } as SubscriptionData)\n      }\n\n      const resolveProm = () => {\n        resolve({\n          subscriptionId,\n        })\n      }\n\n      if (this.deliverFirst) {\n        // When the `deliverFirst` flag is set,\n        // we deliver the subscription before resolving the promise.\n        emit()\n        setTimeout(resolveProm, 1)\n      } else {\n        // Otherwise, we resolve the promise before delivering the subscription.\n        if (!this.doSkipNextEmit) setTimeout(emit, 1)\n        else this.doSkipNextEmit = false\n        resolveProm()\n      }\n    })\n  }\n\n  unsubscribe(subIds: string[]): Promise<UnsubscribeResponse> {\n    const gone: DataGone[] = []\n\n    for (const id of subIds) {\n      gone.push(...(this.goneBatches[id] ?? []))\n      delete this.goneBatches[id]\n    }\n\n    setTimeout(\n      () =>\n        this.enqueueEmit(\n          'goneBatch',\n          base64.toBytes(base64.encode('124')),\n          subIds,\n          gone\n        ),\n      1\n    )\n    return Promise.resolve({})\n  }\n\n  subscribeToSubscriptionEvents(\n    successCallback: SubscriptionDeliveredCallback,\n    errorCallback: SubscriptionErrorCallback\n  ): void {\n    this.on(SUBSCRIPTION_DELIVERED, successCallback)\n    this.on(SUBSCRIPTION_ERROR, errorCallback)\n  }\n\n  unsubscribeToSubscriptionEvents(\n    successCallback: SubscriptionDeliveredCallback,\n    errorCallback: SubscriptionErrorCallback\n  ): void {\n    this.removeListener(SUBSCRIPTION_DELIVERED, successCallback)\n    this.removeListener(SUBSCRIPTION_ERROR, errorCallback)\n  }\n\n  subscribeToGoneBatch(callback: GoneBatchCallback): void {\n    this.on('goneBatch', callback)\n  }\n\n  unsubscribeToGoneBatch(callback: GoneBatchCallback): void {\n    this.off('goneBatch', callback)\n  }\n\n  subscribeToError(cb: (error: SatelliteError) => void): void {\n    this.on('error', cb)\n  }\n\n  emitSocketClosedError(ev: SocketCloseReason): void {\n    this.enqueueEmit('error', new SatelliteError(ev, 'socket closed'))\n  }\n\n  unsubscribeToError(cb: (error: SatelliteError) => void): void {\n    this.removeListener('error', cb)\n  }\n\n  isConnected(): boolean {\n    return !this.disconnected\n  }\n\n  getOutboundReplicationStatus(): ReplicationStatus {\n    return this.isConnected() && this.replicating\n      ? ReplicationStatus.ACTIVE\n      : ReplicationStatus.STOPPED\n  }\n\n  async shutdown(): Promise<void> {\n    await this.waitForProcessing()\n    this.isDown = true\n  }\n\n  getLastSentLsn(): Uint8Array {\n    return this.outboundSent\n  }\n  connect(): Promise<void> {\n    if (this.isDown) {\n      throw new SatelliteError(SatelliteErrorCode.UNEXPECTED_STATE, 'FAKE DOWN')\n    }\n\n    this.disconnected = false\n    return Promise.resolve()\n  }\n  disconnect(): Promise<void> {\n    this.disconnected = true\n    for (const t of this.timeouts) {\n      clearTimeout(t)\n    }\n    return Promise.resolve()\n  }\n  authenticate(_authState: AuthState): Promise<AuthResponse> {\n    return Promise.resolve({})\n  }\n  async startReplication(lsn: LSN): Promise<StartReplicationResponse> {\n    if (this.startReplicationDelayMs) {\n      await sleepAsync(this.startReplicationDelayMs)\n    }\n\n    this.replicating = true\n    this.inboundAck = lsn\n\n    const t = setTimeout(() => this.enqueueEmit('outbound_started'), 100)\n    this.timeouts.push(t)\n\n    if (lsn && bytesToNumber(lsn) == MOCK_BEHIND_WINDOW_LSN) {\n      return {\n        error: new SatelliteError(\n          SatelliteErrorCode.BEHIND_WINDOW,\n          'MOCK BEHIND_WINDOW_LSN ERROR'\n        ),\n      }\n    }\n\n    if (lsn && bytesToNumber(lsn) == MOCK_INTERNAL_ERROR) {\n      return {\n        error: new SatelliteError(\n          SatelliteErrorCode.INTERNAL,\n          'MOCK INTERNAL_ERROR'\n        ),\n      }\n    }\n\n    return Promise.resolve({})\n  }\n\n  stopReplication(): Promise<StopReplicationResponse> {\n    this.replicating = false\n    return Promise.resolve({})\n  }\n\n  subscribeToRelations(callback: (relation: Relation) => void): void {\n    this.relationsCb = callback\n  }\n\n  unsubscribeToRelations(): void {\n    this.relationsCb = undefined\n  }\n\n  subscribeToTransactions(callback: TransactionCallback): void {\n    this.transactionsCb = callback\n  }\n\n  unsubscribeToTransactions(): void {\n    this.transactionsCb = undefined\n  }\n\n  subscribeToAdditionalData(callback: AdditionalDataCallback): void {\n    this.additionalDataCb = callback\n  }\n\n  unsubscribeToAdditionalData(_cb: AdditionalDataCallback): void {\n    this.additionalDataCb = undefined\n  }\n\n  enqueueTransaction(transaction: DataTransaction): void {\n    if (!this.replicating) {\n      throw new SatelliteError(\n        SatelliteErrorCode.REPLICATION_NOT_STARTED,\n        'enqueuing a transaction while outbound replication has not started'\n      )\n    }\n\n    this.outboundTransactionsEnqueued.push(transaction)\n    this.outboundSent = transaction.lsn\n  }\n\n  subscribeToOutboundStarted(callback: OutboundStartedCallback): void {\n    this.on('outbound_started', callback)\n    this.outboundStartedCallback = callback\n  }\n\n  unsubscribeToOutboundStarted(): void {\n    if (!this.outboundStartedCallback) return\n    this.removeListener('outbound_started', this.outboundStartedCallback)\n    this.outboundStartedCallback = undefined\n  }\n\n  sendErrorAfterTimeout(subscriptionId: string, timeout: number): void {\n    setTimeout(() => {\n      const satSubsError: SatSubsDataError = SatSubsDataError.fromPartial({\n        code: SatSubsDataError_Code.SHAPE_DELIVERY_ERROR,\n        message: 'there were shape errors',\n        subscriptionId,\n        shapeRequestError: [\n          SatSubsDataError_ShapeReqError.fromPartial({\n            code: SatSubsDataError_ShapeReqError_Code.SHAPE_SIZE_LIMIT_EXCEEDED,\n            message:\n              \"Requested shape for table 'another' exceeds the maximum allowed shape size\",\n          }),\n        ],\n      })\n\n      const satError = subsDataErrorToSatelliteError(satSubsError)\n      this.enqueueEmit(SUBSCRIPTION_ERROR, satError, subscriptionId)\n    }, timeout)\n  }\n\n  setReplicationTransform(\n    tableName: QualifiedTablename,\n    transform: ReplicatedRowTransformer<DataRecord>\n  ): void {\n    this.replicationTransforms.set(tableName.tablename, transform)\n  }\n  clearReplicationTransform(tableName: QualifiedTablename): void {\n    this.replicationTransforms.delete(tableName.tablename)\n  }\n}\n"],"mappings":"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","names":[]}