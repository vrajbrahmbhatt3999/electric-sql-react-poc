{"version":3,"sources":["../../../src/satellite/shapes/shapeManager.ts"],"sourcesContent":["import { hash } from 'ohash'\nimport {\n  PromiseWithResolvers,\n  QualifiedTablename,\n  emptyPromise,\n} from '../../util'\nimport { Shape } from './types'\nimport uniqWith from 'lodash.uniqwith'\nimport { SyncStatus } from '../../client/model/shapes'\n\ninterface RequestedSubscription {\n  serverId?: string\n  overshadowsFullKeys: string[]\n  shapes: Shape[]\n  shapeHash: string\n  fullKey: string\n}\n\ntype OnShapeSyncStatusUpdated = (key: string, status: SyncStatus) => void\n\ntype OptionalRecord<T> = Record<string, T | undefined>\n\nexport class ShapeManager {\n  /** Uses a full key (hash + key) for indexing */\n  private knownSubscriptions: OptionalRecord<RequestedSubscription> = {}\n\n  /** Maps a key without hash to the full key of latest requested subscription */\n  private requestedSubscriptions: OptionalRecord<string> = {}\n  /** Maps a key without hash to the full key of latest active subscription */\n  private activeSubscriptions: OptionalRecord<string> = {}\n  /** Maps a key to the full key of requested but not done subscription */\n  private unfulfilled: OptionalRecord<string> = {}\n\n  private promises: Record<string, PromiseWithResolvers<void>> = {}\n  private serverIds: Map<string, string> = new Map()\n  private incompleteUnsubs: Set<string> = new Set()\n\n  constructor(private onShapeSyncStatusUpdated?: OnShapeSyncStatusUpdated) {}\n\n  /** Set internal state using a string returned from {@link ShapeManager#serialize}. */\n  public initialize(serializedState: string): void {\n    const { unfulfilled, active, known, unsubscribes } =\n      JSON.parse(serializedState)\n    this.knownSubscriptions = known\n    this.unfulfilled = unfulfilled\n    this.activeSubscriptions = active\n    this.incompleteUnsubs = new Set(unsubscribes)\n    this.serverIds = new Map(\n      Object.values(this.knownSubscriptions).flatMap((x) =>\n        x?.serverId ? [[x.serverId, x.fullKey]] : []\n      )\n    )\n    this.promises = {}\n    this.requestedSubscriptions = {}\n  }\n\n  /** Serialize internal state for external storage. Can be later loaded with {@link ShapeManager#initialize} */\n  public serialize(): string {\n    return JSON.stringify({\n      known: this.knownSubscriptions,\n      unfulfilled: this.requestedSubscriptions,\n      active: this.activeSubscriptions,\n      unsubscribes: [...this.incompleteUnsubs],\n    })\n  }\n\n  /** Reset internal state when the client is reset. Returns all tables that were touched by any of subscriptions. */\n  public reset(opts: {\n    reestablishSubscribed?: boolean\n    defaultNamespace: string\n  }): QualifiedTablename[] {\n    const requested = Object.values(this.requestedSubscriptions)\n\n    const tables = getTableNamesForShapes(\n      Object.values(this.knownSubscriptions)\n        .filter((x) => !requested.includes(x?.fullKey))\n        .flatMap((x) => x?.shapes)\n        .filter(onlyDefined),\n      opts.defaultNamespace\n    )\n\n    let newKnown: OptionalRecord<RequestedSubscription> = {}\n    let unfulfilled: OptionalRecord<string> = {}\n\n    if (opts?.reestablishSubscribed) {\n      // We'll be taking only the latest for each key\n      const relevant = Object.values({\n        ...this.activeSubscriptions,\n        ...this.requestedSubscriptions,\n      })\n        .map((x) => this.knownSubscriptions[x!]!)\n        .map(\n          (x) =>\n            [splitFullKey(x.fullKey)[1], { ...x, serverId: undefined }] as const\n        )\n\n      newKnown = Object.fromEntries(relevant)\n      unfulfilled = Object.fromEntries(relevant.map(([k, v]) => [k, v.fullKey]))\n    }\n\n    this.knownSubscriptions = newKnown\n    this.requestedSubscriptions = {}\n    this.activeSubscriptions = {}\n    this.unfulfilled = unfulfilled\n    this.promises = {}\n    this.serverIds = new Map()\n    this.incompleteUnsubs = new Set()\n\n    return tables\n  }\n\n  // undefined | \"requested\" | \"active\" | \"modifying\" | \"cancelling\"\n\n  public status(key: string): SyncStatus {\n    const active = this.activeSubscriptions[key]\n      ? this.knownSubscriptions[this.activeSubscriptions[key]!]!\n      : undefined\n    const requested = this.requestedSubscriptions[key]\n      ? this.knownSubscriptions[this.requestedSubscriptions[key]!]!\n      : undefined\n\n    if (active && requested && requested.serverId)\n      return {\n        status: 'establishing',\n        progress: 'receiving_data',\n        serverId: requested.serverId,\n        oldServerId: active.serverId,\n      } as const\n    else if (requested && requested.serverId)\n      return {\n        status: 'establishing',\n        progress: 'receiving_data',\n        serverId: requested.serverId,\n      }\n    else if (active && active?.overshadowsFullKeys.length !== 0)\n      return {\n        status: 'establishing',\n        progress: 'removing_data',\n        serverId: active.serverId!,\n      } as const\n    else if (active && this.incompleteUnsubs.has(active.serverId!))\n      return { status: 'cancelling', serverId: active.serverId! }\n    else if (active) return { status: 'active', serverId: active.serverId! }\n    else return undefined\n  }\n\n  /** Get a list of established subscriptions we can continue on reconnection */\n  public listContinuedSubscriptions(): string[] {\n    return Object.values(this.activeSubscriptions).map(\n      (x) => this.knownSubscriptions[x!]!.serverId!\n    )\n  }\n\n  /**\n   * List actions that still need to be made after a restart.\n   *\n   * This should be done after initializing, but before any additional sync requests.\n   */\n  public listPendingActions(): {\n    subscribe: { key: string; shapes: Shape[] }[]\n    unsubscribe: string[]\n  } {\n    return {\n      subscribe: Object.entries(this.unfulfilled).map(([key, fullKey]) => ({\n        key,\n        shapes: this.knownSubscriptions[fullKey!]!.shapes,\n      })),\n      unsubscribe: Object.values(this.activeSubscriptions)\n        .flatMap((x) => this.knownSubscriptions[x!]!.overshadowsFullKeys)\n        .concat([...this.incompleteUnsubs]),\n    }\n  }\n\n  /**\n   * List all subscriptions as defined along with their simple key and sync status\n   */\n  public listAllSubscriptions(): {\n    key: string\n    shapes: Shape[]\n    status: SyncStatus\n  }[] {\n    const allKeys = Object.keys(this.activeSubscriptions).concat(\n      Object.keys(this.requestedSubscriptions)\n    )\n    return allKeys.map((key) => ({\n      shapes:\n        this.knownSubscriptions[\n          (this.activeSubscriptions[key] ?? this.requestedSubscriptions[key])!\n        ]!.shapes,\n      status: this.status(key),\n      key,\n    }))\n  }\n\n  /**\n   * Store a request to sync a list of shapes.\n   *\n   * This should be done before any actual API requests in order to correctly deduplicate concurrent calls\n   * using the same shape.\n   *\n   * A unique key can be used to identify the sync request. If duplicating sync requests with the same key\n   * have been made in the past, then all previous ones will be unsubscribed as soon as this one is fulfilled.\n   *\n   * @param shapes List of shapes to be included in this sync call\n   * @param key Unique key to identify the sync request by\n   * @returns A stored promise object that should be resolved when data arrives\n   */\n  public syncRequested(\n    shapes: Shape[],\n    key?: string\n  ):\n    | { key: string; existing: Promise<void> }\n    | {\n        key: string\n        setServerId: (id: string) => void\n        syncFailed: () => void\n        promise: Promise<void>\n      } {\n    const shapeHash = this.hashShapes(shapes)\n    const keyOrHash = key ?? shapeHash\n    /* Since multiple requests may have the same key, we'll need to differentiate them\n     * based on both hash and key. We use `:` to join them because hash is base64 that\n     * won't use this symbol. This is a poor man's tuple to use as an object key.\n     */\n    const fullKey = makeFullKey(shapeHash, keyOrHash)\n\n    const sub = this.getLatestSubscription(keyOrHash)\n\n    if (sub && sub.shapeHash === shapeHash) {\n      // Known & latest subscription with same key and hash.\n      // Return an in-flight promise if it's in flight, or a resolved one if not\n      return {\n        key: keyOrHash,\n        existing: this.promises[fullKey]?.promise ?? Promise.resolve(),\n      }\n    } else {\n      let overshadowsFullKeys: string[] = []\n\n      if (sub !== undefined) {\n        // A known subscription with same key, but with a different hash\n        // This means we'll be unsubscribing any previous subscriptions\n        // NOTE: order matters here, we depend on it in `syncFailed`.\n        overshadowsFullKeys = [sub.fullKey, ...sub.overshadowsFullKeys]\n      }\n\n      this.knownSubscriptions[fullKey] = {\n        shapes,\n        shapeHash,\n        overshadowsFullKeys,\n        fullKey,\n      }\n\n      this.requestedSubscriptions[keyOrHash] = fullKey\n\n      let notified = false\n\n      this.promises[fullKey] = emptyPromise()\n      return {\n        key: keyOrHash,\n        setServerId: (id) => {\n          this.setServerId(fullKey, id)\n          if (!notified) {\n            notified = true\n            this.onShapeSyncStatusUpdated?.(keyOrHash, this.status(keyOrHash))\n          }\n        },\n        syncFailed: () => this.syncFailed(keyOrHash, fullKey),\n        promise: this.promises[fullKey].promise,\n      }\n    }\n  }\n\n  private syncFailed(key: string, fullKey: string): void {\n    delete this.promises[fullKey]\n    const sub = this.knownSubscriptions[fullKey]!\n\n    // We're storing full keys of any subscriptions we were meant to unsubscribe from\n    // in `sub.overshadowsFullKeys`, with last subscription's key being the first element.\n    // If that last subscription is a requested subscription that still may arrive\n    // (i.e. not active), then we're falling back to it so that previous sync call is not\n    // invalidated by this one.\n    const shadowedKey: string | undefined = sub.overshadowsFullKeys[0]\n    if (\n      shadowedKey &&\n      this.requestedSubscriptions[key] === fullKey &&\n      this.activeSubscriptions[key] !== shadowedKey\n    ) {\n      this.requestedSubscriptions[key] = shadowedKey\n    } else if (this.requestedSubscriptions[key] === fullKey) {\n      delete this.requestedSubscriptions[key]\n    }\n    delete this.knownSubscriptions[fullKey]\n  }\n\n  /** Return latest known subscription for the key - requested first, active next. */\n  private getLatestSubscription(\n    key: string\n  ): RequestedSubscription | undefined {\n    const fullKey =\n      this.requestedSubscriptions[key] ?? this.activeSubscriptions[key]\n\n    return fullKey ? this.knownSubscriptions[fullKey] : undefined\n  }\n\n  private setServerId(fullKey: string, id: string) {\n    this.knownSubscriptions[fullKey]!.serverId ??= id\n    this.serverIds.set(this.knownSubscriptions[fullKey]!.serverId!, fullKey)\n  }\n\n  /**\n   * Mark the subscription as delivered and resolve waiting promises.\n   *\n   * If the delivered subscription was overshadowing some other previous subscriptions,\n   * the `synced` promise will not be resolved until the unsubscribe was successfully issued.\n   */\n  public dataDelivered(serverId: string): () => string[] {\n    const fullKey = this.serverIds.get(serverId)\n    if (fullKey === undefined || this.knownSubscriptions[fullKey] === undefined)\n      throw new Error('Data received for an unknown subscription')\n\n    const [_hash, key] = splitFullKey(fullKey)\n    const sub = this.knownSubscriptions[fullKey]!\n\n    if (this.requestedSubscriptions[key] === fullKey)\n      delete this.requestedSubscriptions[key]\n    this.activeSubscriptions[key] = fullKey\n\n    if (sub.overshadowsFullKeys.length === 0) {\n      this.onShapeSyncStatusUpdated?.(key, this.status(key))\n      return () => {\n        this.promises[fullKey].resolve()\n        delete this.promises[fullKey]\n        return []\n      }\n    } else {\n      const ids = sub.overshadowsFullKeys\n        .map((x) => this.knownSubscriptions[x]?.serverId)\n        .filter(onlyDefined)\n      return () => ids\n    }\n  }\n\n  public unsubscribeMade(serverIds: string[]) {\n    for (const id of serverIds) {\n      this.incompleteUnsubs.add(id)\n\n      if (this.onShapeSyncStatusUpdated) {\n        const key = this.getKeyForServerID(id)\n        if (!key) continue\n        this.onShapeSyncStatusUpdated(key, this.status(key))\n      }\n    }\n  }\n\n  /**\n   * Mark a GONE batch as received from the server after an unsubscribe.\n   *\n   */\n  public goneBatchDelivered(serverIds: string[]) {\n    for (const id of serverIds) {\n      const fullKey = this.serverIds.get(id)\n      if (fullKey === undefined) continue\n\n      const [_hash, key] = splitFullKey(fullKey)\n      delete this.knownSubscriptions[fullKey]\n      this.serverIds.delete(id)\n      this.incompleteUnsubs.delete(id)\n      if (this.activeSubscriptions[key] === fullKey)\n        delete this.activeSubscriptions[key]\n\n      for (const sub of this.getSubscriptionsWaitingForUnsub(fullKey)) {\n        sub.overshadowsFullKeys.splice(\n          sub.overshadowsFullKeys.indexOf(fullKey),\n          1\n        )\n\n        if (\n          sub.overshadowsFullKeys.length === 0 &&\n          this.activeSubscriptions[key] === sub.fullKey\n        ) {\n          this.promises[sub.fullKey].resolve()\n        }\n      }\n\n      this.onShapeSyncStatusUpdated?.(key, this.status(key))\n    }\n  }\n\n  private getSubscriptionsWaitingForUnsub(\n    fullKey: string\n  ): RequestedSubscription[] {\n    return Object.values(this.knownSubscriptions)\n      .filter(onlyDefined)\n      .filter((x) => x.overshadowsFullKeys.some((y) => y === fullKey))\n  }\n\n  public getOnFailureCallback(serverId: string) {\n    const fullKey = this.serverIds.get(serverId)\n    return fullKey ? this.promises[fullKey]?.reject : undefined\n  }\n\n  public getServerIDs(keys: string[]): string[] {\n    return keys\n      .map((k) => this.activeSubscriptions[k])\n      .map((k) => (k !== undefined ? this.knownSubscriptions[k] : k))\n      .map((x) => (x ? x.serverId : x))\n      .filter(onlyDefined)\n  }\n\n  public getServerIDsForShapes(shapes: Shape[]): string[] {\n    const shapeHash = this.hashShapes(shapes)\n    const fullKey = makeFullKey(shapeHash, shapeHash)\n    const serverId = this.knownSubscriptions[fullKey]?.serverId\n    return serverId ? [serverId] : []\n  }\n\n  public getKeyForServerID(serverId: string): string | undefined {\n    const fullKey = this.serverIds.get(serverId)\n    if (fullKey === undefined) return\n    const [_hash, key] = splitFullKey(fullKey)\n    return key\n  }\n\n  public hashShapes(shapes: Shape[]): string {\n    // TODO: This sorts the shapes objects for hashing to make sure that order of includes\n    //       does not affect the hash. This has the unfortunate consequence of sorting the FK spec,\n    //       but the chance of a table having two multi-column FKs over same columns BUT in a\n    //       different order feels much lower than people using includes in an arbitrary order.\n    return hash(shapes, { unorderedArrays: true })\n  }\n}\n\nfunction onlyDefined<T>(x: T | undefined): x is T {\n  return x !== undefined\n}\n\nfunction makeFullKey(hash: string, key: string): string {\n  return hash + ':' + key\n}\n\nfunction splitFullKey(fullKey: string): [hash: string, key: string] {\n  return splitOnce(fullKey, ':')\n}\n\nfunction splitOnce(str: string, on: string): [string, string] {\n  const found = str.indexOf(on)\n  if (found === -1) return [str, '']\n  else return [str.slice(0, found), str.slice(found + 1)]\n}\n\nexport function getTableNamesForShapes(\n  shapes: Shape[],\n  schema: string\n): QualifiedTablename[] {\n  return uniqWith(\n    shapes.flatMap((x) => doGetTableNamesForShape(x, schema)),\n    (a, b) => a.isEqual(b)\n  )\n}\n\nfunction doGetTableNamesForShape(\n  shape: Shape,\n  schema: string\n): QualifiedTablename[] {\n  const includes =\n    shape.include?.flatMap((x) => doGetTableNamesForShape(x.select, schema)) ??\n    []\n  includes.push(new QualifiedTablename(schema, shape.tablename))\n  return includes\n}\n"],"mappings":"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","names":["hash"]}