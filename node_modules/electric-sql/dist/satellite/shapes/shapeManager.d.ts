import { QualifiedTablename } from '../../util/index.js';
import { Shape } from './types.js';
import { SyncStatus } from '../../client/model/shapes.js';
type OnShapeSyncStatusUpdated = (key: string, status: SyncStatus) => void;
export declare class ShapeManager {
    private onShapeSyncStatusUpdated?;
    /** Uses a full key (hash + key) for indexing */
    private knownSubscriptions;
    /** Maps a key without hash to the full key of latest requested subscription */
    private requestedSubscriptions;
    /** Maps a key without hash to the full key of latest active subscription */
    private activeSubscriptions;
    /** Maps a key to the full key of requested but not done subscription */
    private unfulfilled;
    private promises;
    private serverIds;
    private incompleteUnsubs;
    constructor(onShapeSyncStatusUpdated?: OnShapeSyncStatusUpdated | undefined);
    /** Set internal state using a string returned from {@link ShapeManager#serialize}. */
    initialize(serializedState: string): void;
    /** Serialize internal state for external storage. Can be later loaded with {@link ShapeManager#initialize} */
    serialize(): string;
    /** Reset internal state when the client is reset. Returns all tables that were touched by any of subscriptions. */
    reset(opts: {
        reestablishSubscribed?: boolean;
        defaultNamespace: string;
    }): QualifiedTablename[];
    status(key: string): SyncStatus;
    /** Get a list of established subscriptions we can continue on reconnection */
    listContinuedSubscriptions(): string[];
    /**
     * List actions that still need to be made after a restart.
     *
     * This should be done after initializing, but before any additional sync requests.
     */
    listPendingActions(): {
        subscribe: {
            key: string;
            shapes: Shape[];
        }[];
        unsubscribe: string[];
    };
    /**
     * List all subscriptions as defined along with their simple key and sync status
     */
    listAllSubscriptions(): {
        key: string;
        shapes: Shape[];
        status: SyncStatus;
    }[];
    /**
     * Store a request to sync a list of shapes.
     *
     * This should be done before any actual API requests in order to correctly deduplicate concurrent calls
     * using the same shape.
     *
     * A unique key can be used to identify the sync request. If duplicating sync requests with the same key
     * have been made in the past, then all previous ones will be unsubscribed as soon as this one is fulfilled.
     *
     * @param shapes List of shapes to be included in this sync call
     * @param key Unique key to identify the sync request by
     * @returns A stored promise object that should be resolved when data arrives
     */
    syncRequested(shapes: Shape[], key?: string): {
        key: string;
        existing: Promise<void>;
    } | {
        key: string;
        setServerId: (id: string) => void;
        syncFailed: () => void;
        promise: Promise<void>;
    };
    private syncFailed;
    /** Return latest known subscription for the key - requested first, active next. */
    private getLatestSubscription;
    private setServerId;
    /**
     * Mark the subscription as delivered and resolve waiting promises.
     *
     * If the delivered subscription was overshadowing some other previous subscriptions,
     * the `synced` promise will not be resolved until the unsubscribe was successfully issued.
     */
    dataDelivered(serverId: string): () => string[];
    unsubscribeMade(serverIds: string[]): void;
    /**
     * Mark a GONE batch as received from the server after an unsubscribe.
     *
     */
    goneBatchDelivered(serverIds: string[]): void;
    private getSubscriptionsWaitingForUnsub;
    getOnFailureCallback(serverId: string): ((reason?: any) => void) | undefined;
    getServerIDs(keys: string[]): string[];
    getServerIDsForShapes(shapes: Shape[]): string[];
    getKeyForServerID(serverId: string): string | undefined;
    hashShapes(shapes: Shape[]): string;
}
export declare function getTableNamesForShapes(shapes: Shape[], schema: string): QualifiedTablename[];
export {};
