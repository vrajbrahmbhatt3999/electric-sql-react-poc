import { hash } from "ohash";
import {
  QualifiedTablename,
  emptyPromise
} from '../../util/index.js';
import uniqWith from "lodash.uniqwith";
class ShapeManager {
  constructor(onShapeSyncStatusUpdated) {
    this.onShapeSyncStatusUpdated = onShapeSyncStatusUpdated;
  }
  /** Uses a full key (hash + key) for indexing */
  knownSubscriptions = {};
  /** Maps a key without hash to the full key of latest requested subscription */
  requestedSubscriptions = {};
  /** Maps a key without hash to the full key of latest active subscription */
  activeSubscriptions = {};
  /** Maps a key to the full key of requested but not done subscription */
  unfulfilled = {};
  promises = {};
  serverIds = /* @__PURE__ */ new Map();
  incompleteUnsubs = /* @__PURE__ */ new Set();
  /** Set internal state using a string returned from {@link ShapeManager#serialize}. */
  initialize(serializedState) {
    const { unfulfilled, active, known, unsubscribes } = JSON.parse(serializedState);
    this.knownSubscriptions = known;
    this.unfulfilled = unfulfilled;
    this.activeSubscriptions = active;
    this.incompleteUnsubs = new Set(unsubscribes);
    this.serverIds = new Map(
      Object.values(this.knownSubscriptions).flatMap(
        (x) => x?.serverId ? [[x.serverId, x.fullKey]] : []
      )
    );
    this.promises = {};
    this.requestedSubscriptions = {};
  }
  /** Serialize internal state for external storage. Can be later loaded with {@link ShapeManager#initialize} */
  serialize() {
    return JSON.stringify({
      known: this.knownSubscriptions,
      unfulfilled: this.requestedSubscriptions,
      active: this.activeSubscriptions,
      unsubscribes: [...this.incompleteUnsubs]
    });
  }
  /** Reset internal state when the client is reset. Returns all tables that were touched by any of subscriptions. */
  reset(opts) {
    const requested = Object.values(this.requestedSubscriptions);
    const tables = getTableNamesForShapes(
      Object.values(this.knownSubscriptions).filter((x) => !requested.includes(x?.fullKey)).flatMap((x) => x?.shapes).filter(onlyDefined),
      opts.defaultNamespace
    );
    let newKnown = {};
    let unfulfilled = {};
    if (opts?.reestablishSubscribed) {
      const relevant = Object.values({
        ...this.activeSubscriptions,
        ...this.requestedSubscriptions
      }).map((x) => this.knownSubscriptions[x]).map(
        (x) => [splitFullKey(x.fullKey)[1], { ...x, serverId: void 0 }]
      );
      newKnown = Object.fromEntries(relevant);
      unfulfilled = Object.fromEntries(relevant.map(([k, v]) => [k, v.fullKey]));
    }
    this.knownSubscriptions = newKnown;
    this.requestedSubscriptions = {};
    this.activeSubscriptions = {};
    this.unfulfilled = unfulfilled;
    this.promises = {};
    this.serverIds = /* @__PURE__ */ new Map();
    this.incompleteUnsubs = /* @__PURE__ */ new Set();
    return tables;
  }
  // undefined | "requested" | "active" | "modifying" | "cancelling"
  status(key) {
    const active = this.activeSubscriptions[key] ? this.knownSubscriptions[this.activeSubscriptions[key]] : void 0;
    const requested = this.requestedSubscriptions[key] ? this.knownSubscriptions[this.requestedSubscriptions[key]] : void 0;
    if (active && requested && requested.serverId)
      return {
        status: "establishing",
        progress: "receiving_data",
        serverId: requested.serverId,
        oldServerId: active.serverId
      };
    else if (requested && requested.serverId)
      return {
        status: "establishing",
        progress: "receiving_data",
        serverId: requested.serverId
      };
    else if (active && active?.overshadowsFullKeys.length !== 0)
      return {
        status: "establishing",
        progress: "removing_data",
        serverId: active.serverId
      };
    else if (active && this.incompleteUnsubs.has(active.serverId))
      return { status: "cancelling", serverId: active.serverId };
    else if (active)
      return { status: "active", serverId: active.serverId };
    else
      return void 0;
  }
  /** Get a list of established subscriptions we can continue on reconnection */
  listContinuedSubscriptions() {
    return Object.values(this.activeSubscriptions).map(
      (x) => this.knownSubscriptions[x].serverId
    );
  }
  /**
   * List actions that still need to be made after a restart.
   *
   * This should be done after initializing, but before any additional sync requests.
   */
  listPendingActions() {
    return {
      subscribe: Object.entries(this.unfulfilled).map(([key, fullKey]) => ({
        key,
        shapes: this.knownSubscriptions[fullKey].shapes
      })),
      unsubscribe: Object.values(this.activeSubscriptions).flatMap((x) => this.knownSubscriptions[x].overshadowsFullKeys).concat([...this.incompleteUnsubs])
    };
  }
  /**
   * List all subscriptions as defined along with their simple key and sync status
   */
  listAllSubscriptions() {
    const allKeys = Object.keys(this.activeSubscriptions).concat(
      Object.keys(this.requestedSubscriptions)
    );
    return allKeys.map((key) => ({
      shapes: this.knownSubscriptions[this.activeSubscriptions[key] ?? this.requestedSubscriptions[key]].shapes,
      status: this.status(key),
      key
    }));
  }
  /**
   * Store a request to sync a list of shapes.
   *
   * This should be done before any actual API requests in order to correctly deduplicate concurrent calls
   * using the same shape.
   *
   * A unique key can be used to identify the sync request. If duplicating sync requests with the same key
   * have been made in the past, then all previous ones will be unsubscribed as soon as this one is fulfilled.
   *
   * @param shapes List of shapes to be included in this sync call
   * @param key Unique key to identify the sync request by
   * @returns A stored promise object that should be resolved when data arrives
   */
  syncRequested(shapes, key) {
    const shapeHash = this.hashShapes(shapes);
    const keyOrHash = key ?? shapeHash;
    const fullKey = makeFullKey(shapeHash, keyOrHash);
    const sub = this.getLatestSubscription(keyOrHash);
    if (sub && sub.shapeHash === shapeHash) {
      return {
        key: keyOrHash,
        existing: this.promises[fullKey]?.promise ?? Promise.resolve()
      };
    } else {
      let overshadowsFullKeys = [];
      if (sub !== void 0) {
        overshadowsFullKeys = [sub.fullKey, ...sub.overshadowsFullKeys];
      }
      this.knownSubscriptions[fullKey] = {
        shapes,
        shapeHash,
        overshadowsFullKeys,
        fullKey
      };
      this.requestedSubscriptions[keyOrHash] = fullKey;
      let notified = false;
      this.promises[fullKey] = emptyPromise();
      return {
        key: keyOrHash,
        setServerId: (id) => {
          this.setServerId(fullKey, id);
          if (!notified) {
            notified = true;
            this.onShapeSyncStatusUpdated?.(keyOrHash, this.status(keyOrHash));
          }
        },
        syncFailed: () => this.syncFailed(keyOrHash, fullKey),
        promise: this.promises[fullKey].promise
      };
    }
  }
  syncFailed(key, fullKey) {
    delete this.promises[fullKey];
    const sub = this.knownSubscriptions[fullKey];
    const shadowedKey = sub.overshadowsFullKeys[0];
    if (shadowedKey && this.requestedSubscriptions[key] === fullKey && this.activeSubscriptions[key] !== shadowedKey) {
      this.requestedSubscriptions[key] = shadowedKey;
    } else if (this.requestedSubscriptions[key] === fullKey) {
      delete this.requestedSubscriptions[key];
    }
    delete this.knownSubscriptions[fullKey];
  }
  /** Return latest known subscription for the key - requested first, active next. */
  getLatestSubscription(key) {
    const fullKey = this.requestedSubscriptions[key] ?? this.activeSubscriptions[key];
    return fullKey ? this.knownSubscriptions[fullKey] : void 0;
  }
  setServerId(fullKey, id) {
    this.knownSubscriptions[fullKey].serverId ??= id;
    this.serverIds.set(this.knownSubscriptions[fullKey].serverId, fullKey);
  }
  /**
   * Mark the subscription as delivered and resolve waiting promises.
   *
   * If the delivered subscription was overshadowing some other previous subscriptions,
   * the `synced` promise will not be resolved until the unsubscribe was successfully issued.
   */
  dataDelivered(serverId) {
    const fullKey = this.serverIds.get(serverId);
    if (fullKey === void 0 || this.knownSubscriptions[fullKey] === void 0)
      throw new Error("Data received for an unknown subscription");
    const [_hash, key] = splitFullKey(fullKey);
    const sub = this.knownSubscriptions[fullKey];
    if (this.requestedSubscriptions[key] === fullKey)
      delete this.requestedSubscriptions[key];
    this.activeSubscriptions[key] = fullKey;
    if (sub.overshadowsFullKeys.length === 0) {
      this.onShapeSyncStatusUpdated?.(key, this.status(key));
      return () => {
        this.promises[fullKey].resolve();
        delete this.promises[fullKey];
        return [];
      };
    } else {
      const ids = sub.overshadowsFullKeys.map((x) => this.knownSubscriptions[x]?.serverId).filter(onlyDefined);
      return () => ids;
    }
  }
  unsubscribeMade(serverIds) {
    for (const id of serverIds) {
      this.incompleteUnsubs.add(id);
      if (this.onShapeSyncStatusUpdated) {
        const key = this.getKeyForServerID(id);
        if (!key)
          continue;
        this.onShapeSyncStatusUpdated(key, this.status(key));
      }
    }
  }
  /**
   * Mark a GONE batch as received from the server after an unsubscribe.
   *
   */
  goneBatchDelivered(serverIds) {
    for (const id of serverIds) {
      const fullKey = this.serverIds.get(id);
      if (fullKey === void 0)
        continue;
      const [_hash, key] = splitFullKey(fullKey);
      delete this.knownSubscriptions[fullKey];
      this.serverIds.delete(id);
      this.incompleteUnsubs.delete(id);
      if (this.activeSubscriptions[key] === fullKey)
        delete this.activeSubscriptions[key];
      for (const sub of this.getSubscriptionsWaitingForUnsub(fullKey)) {
        sub.overshadowsFullKeys.splice(
          sub.overshadowsFullKeys.indexOf(fullKey),
          1
        );
        if (sub.overshadowsFullKeys.length === 0 && this.activeSubscriptions[key] === sub.fullKey) {
          this.promises[sub.fullKey].resolve();
        }
      }
      this.onShapeSyncStatusUpdated?.(key, this.status(key));
    }
  }
  getSubscriptionsWaitingForUnsub(fullKey) {
    return Object.values(this.knownSubscriptions).filter(onlyDefined).filter((x) => x.overshadowsFullKeys.some((y) => y === fullKey));
  }
  getOnFailureCallback(serverId) {
    const fullKey = this.serverIds.get(serverId);
    return fullKey ? this.promises[fullKey]?.reject : void 0;
  }
  getServerIDs(keys) {
    return keys.map((k) => this.activeSubscriptions[k]).map((k) => k !== void 0 ? this.knownSubscriptions[k] : k).map((x) => x ? x.serverId : x).filter(onlyDefined);
  }
  getServerIDsForShapes(shapes) {
    const shapeHash = this.hashShapes(shapes);
    const fullKey = makeFullKey(shapeHash, shapeHash);
    const serverId = this.knownSubscriptions[fullKey]?.serverId;
    return serverId ? [serverId] : [];
  }
  getKeyForServerID(serverId) {
    const fullKey = this.serverIds.get(serverId);
    if (fullKey === void 0)
      return;
    const [_hash, key] = splitFullKey(fullKey);
    return key;
  }
  hashShapes(shapes) {
    return hash(shapes, { unorderedArrays: true });
  }
}
function onlyDefined(x) {
  return x !== void 0;
}
function makeFullKey(hash2, key) {
  return hash2 + ":" + key;
}
function splitFullKey(fullKey) {
  return splitOnce(fullKey, ":");
}
function splitOnce(str, on) {
  const found = str.indexOf(on);
  if (found === -1)
    return [str, ""];
  else
    return [str.slice(0, found), str.slice(found + 1)];
}
function getTableNamesForShapes(shapes, schema) {
  return uniqWith(
    shapes.flatMap((x) => doGetTableNamesForShape(x, schema)),
    (a, b) => a.isEqual(b)
  );
}
function doGetTableNamesForShape(shape, schema) {
  const includes = shape.include?.flatMap((x) => doGetTableNamesForShape(x.select, schema)) ?? [];
  includes.push(new QualifiedTablename(schema, shape.tablename));
  return includes;
}
export {
  ShapeManager,
  getTableNamesForShapes
};
//# sourceMappingURL=shapeManager.js.map