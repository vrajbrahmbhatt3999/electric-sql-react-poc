import EventEmitter from "events";
import {
  SatelliteError,
  SatelliteErrorCode,
  subsDataErrorToSatelliteError
} from '../../util/index.js';
import { deserializeRow } from '../client.js';
import {
  SUBSCRIPTION_DELIVERED,
  SUBSCRIPTION_ERROR
} from './types.js';
class SubscriptionsDataCache extends EventEmitter {
  constructor(dbDescription, decoder) {
    super();
    this.decoder = decoder;
    this.requestedSubscriptions = {};
    this.remainingShapes = /* @__PURE__ */ new Set();
    this.dbDescription = dbDescription;
  }
  requestedSubscriptions;
  remainingShapes;
  currentShapeRequestId;
  inDelivery;
  dbDescription;
  isDelivering() {
    return this.inDelivery !== void 0;
  }
  subscriptionRequest(subsRequest) {
    const { subscriptionId, shapeRequests } = subsRequest;
    const requestedShapes = new Set(
      shapeRequests.map((shape) => shape.requestId)
    );
    this.requestedSubscriptions[subscriptionId] = requestedShapes;
  }
  subscriptionResponse({ subscriptionId }) {
    if (!this.requestedSubscriptions[subscriptionId]) {
      this.internalError(
        SatelliteErrorCode.UNEXPECTED_SUBSCRIPTION_STATE,
        `Received subscribe response for unknown subscription ${subscriptionId}`,
        subscriptionId
      );
    }
  }
  subscriptionDataBegin({ subscriptionId, lsn }) {
    if (!this.requestedSubscriptions[subscriptionId]) {
      this.internalError(
        SatelliteErrorCode.UNEXPECTED_SUBSCRIPTION_STATE,
        `Received SatSubsDataBegin but for unknown subscription ${subscriptionId}`,
        subscriptionId
      );
    }
    if (this.inDelivery) {
      this.internalError(
        SatelliteErrorCode.UNEXPECTED_SUBSCRIPTION_STATE,
        `received SatSubsDataStart for subscription ${subscriptionId} but a subscription (${this.inDelivery.subscriptionId}) is already being delivered`,
        subscriptionId
      );
    }
    this.remainingShapes = this.requestedSubscriptions[subscriptionId];
    this.inDelivery = {
      subscriptionId,
      lsn,
      transaction: [],
      shapeReqToUuid: {}
    };
  }
  subscriptionDataEnd(relations) {
    if (!this.inDelivery) {
      this.internalError(
        SatelliteErrorCode.UNEXPECTED_SUBSCRIPTION_STATE,
        `Received SatSubDataEnd but no subscription is being delivered`
      );
    }
    if (this.remainingShapes.size > 0) {
      this.internalError(
        SatelliteErrorCode.UNEXPECTED_SUBSCRIPTION_STATE,
        `Received SatSubDataEnd but not all shapes have been delivered`
      );
    }
    const delivered = this.inDelivery;
    const subscriptionData = {
      subscriptionId: delivered.subscriptionId,
      lsn: delivered.lsn,
      data: delivered.transaction.map(
        (t) => this.processShapeDataOperations(t, relations)
      ),
      shapeReqToUuid: delivered.shapeReqToUuid
    };
    this.reset(subscriptionData.subscriptionId);
    this.emit(SUBSCRIPTION_DELIVERED, subscriptionData);
    return delivered;
  }
  shapeDataBegin(shape) {
    if (!this.inDelivery) {
      this.internalError(
        SatelliteErrorCode.UNEXPECTED_SUBSCRIPTION_STATE,
        `Received SatShapeDataBegin but no subscription is being delivered`
      );
    }
    if (this.remainingShapes.size === 0) {
      this.internalError(
        SatelliteErrorCode.UNEXPECTED_SUBSCRIPTION_STATE,
        `Received SatShapeDataBegin but all shapes have been delivered for this subscription`
      );
    }
    if (this.currentShapeRequestId) {
      this.internalError(
        SatelliteErrorCode.UNEXPECTED_SUBSCRIPTION_STATE,
        `Received SatShapeDataBegin for shape with uuid ${shape.uuid} but a shape is already being delivered`
      );
    }
    if (this.inDelivery.shapeReqToUuid[shape.requestId]) {
      this.internalError(
        SatelliteErrorCode.UNEXPECTED_SUBSCRIPTION_STATE,
        `Received SatShapeDataBegin for shape with uuid ${shape.uuid} but shape has already been delivered`
      );
    }
    this.inDelivery.shapeReqToUuid[shape.requestId] = shape.uuid;
    this.currentShapeRequestId = shape.requestId;
  }
  shapeDataEnd() {
    if (!this.inDelivery) {
      this.internalError(
        SatelliteErrorCode.UNEXPECTED_SUBSCRIPTION_STATE,
        `Received SatShapeDataEnd but no subscription is being delivered`
      );
    }
    if (!this.currentShapeRequestId) {
      this.internalError(
        SatelliteErrorCode.UNEXPECTED_SUBSCRIPTION_STATE,
        `Received SatShapeDataEnd but no shape is being delivered`
      );
    }
    this.remainingShapes.delete(this.currentShapeRequestId);
    this.currentShapeRequestId = void 0;
  }
  transaction(ops) {
    if (this.remainingShapes.size === 0 || !this.inDelivery || !this.currentShapeRequestId) {
      this.internalError(
        SatelliteErrorCode.UNEXPECTED_SUBSCRIPTION_STATE,
        `Received SatOpLog but no shape is being delivered`
      );
    }
    for (const op of ops) {
      if (op.begin || op.commit || op.update || op.delete) {
        this.internalError(
          SatelliteErrorCode.UNEXPECTED_MESSAGE_TYPE,
          `Received begin, commit, update or delete message, but these messages are not valid in subscriptions`
        );
      }
      this.inDelivery.transaction.push(op);
    }
  }
  internalError(code, msg, subId = this.inDelivery?.subscriptionId) {
    this.reset(subId);
    const error = new SatelliteError(code, msg);
    this.emit(SUBSCRIPTION_ERROR, error);
    throw error;
  }
  // It is safe to reset the cache state without throwing.
  // However, if message is unexpected, we emit the error
  subscriptionError(subId) {
    if (!this.requestedSubscriptions[subId]) {
      this.internalError(
        SatelliteErrorCode.SUBSCRIPTION_NOT_FOUND,
        `received subscription error for unknown subscription ${subId}`,
        subId
      );
    }
    this.reset(subId);
  }
  subscriptionDataError(subId, msg) {
    let error = subsDataErrorToSatelliteError(msg);
    if (!this.inDelivery) {
      error = new SatelliteError(
        SatelliteErrorCode.UNEXPECTED_SUBSCRIPTION_STATE,
        `received subscription data error, but no subscription is being delivered: ${error.message}`
      );
    }
    this.reset(subId);
    this.emit(SUBSCRIPTION_ERROR, error, msg.subscriptionId);
    throw error;
  }
  reset(subscriptionId) {
    if (subscriptionId)
      delete this.requestedSubscriptions[subscriptionId];
    if (subscriptionId === this.inDelivery?.subscriptionId) {
      this.remainingShapes = /* @__PURE__ */ new Set();
      this.currentShapeRequestId = void 0;
      this.inDelivery = void 0;
    }
  }
  processShapeDataOperations(op, relations) {
    if (!op.insert) {
      this.internalError(
        SatelliteErrorCode.UNEXPECTED_MESSAGE_TYPE,
        "invalid shape data operation"
      );
    }
    const { relationId, rowData, tags } = op.insert;
    const relation = relations.get(relationId);
    if (!relation) {
      this.internalError(
        SatelliteErrorCode.PROTOCOL_VIOLATION,
        `missing relation ${relationId} for incoming operation`
      );
    }
    const record = deserializeRow(
      rowData,
      relation,
      this.dbDescription,
      this.decoder
    );
    if (!record) {
      this.internalError(
        SatelliteErrorCode.PROTOCOL_VIOLATION,
        "INSERT operations has no data"
      );
    }
    return {
      relation,
      record,
      tags
    };
  }
}
export {
  SubscriptionsDataCache
};
//# sourceMappingURL=cache.js.map