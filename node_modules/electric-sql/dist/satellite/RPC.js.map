{"version":3,"sources":["../../src/satellite/RPC.ts"],"sourcesContent":["import {\n  Root,\n  SatErrorResp,\n  SatRpcRequest,\n  SatRpcResponse,\n} from '../_generated/protocol/satellite'\nimport { SatelliteError, SatelliteErrorCode } from '../util/types'\nimport { emptyPromise } from '../util/common'\nimport Log, { Logger } from 'loglevel'\nimport { ClientRpcResponse, encodeRpcResponse, msgToString } from '../util'\nimport { isDebuggingNode } from '../util/debug'\n\ntype RequestId = `${string}/${number}`\ntype SenderFn = (msg: SatRpcRequest | SatRpcResponse) => void\n\n/**\n * Wrapper class that exposes a `request` method for generated RPC services to use.\n *\n * Any `SatRpcResponse` messages should be forwarded to this class to be correctly marked\n * as fulfilled.\n */\nexport class RPC {\n  /** Monotonically increasing request id */\n  private nextRequestId = 1\n  /** Known pending requests and the promise resolvers for them */\n  private pendingRequests = new Map<\n    RequestId,\n    {\n      resolve: (value: Uint8Array) => void\n      reject: (reason?: any) => void\n      timer: any\n    }\n  >()\n  /** Set of request identifiers that had timed out, for better errors */\n  private timedOutCalls = new Set<RequestId>()\n\n  constructor(\n    private sender: SenderFn,\n    private defaultTimeout: number,\n    private log: Log.Logger\n  ) {}\n\n  /**\n   * Perform given RPC method using given message as data.\n   *\n   * This fulfills unexported generated interface `RPC` in `_generated/protocol/satellite.ts`.\n   * The generated service instance expects to pass in an already-encoded message because RPC\n   * is assumed to be part of the transport and not the protocol. Service instance also expects\n   * to receive a still-encoded response.\n   *\n   * The details of the RPC contract are available in `.proto` file for the Satellite protocol,\n   * but the gist is that there are two special messages in the Satellite protocol: `SatRpcRequest`\n   * and `SatRpcResponse` that facilitate the call.\n   */\n  public request(\n    _service: string,\n    method: string,\n    message: Uint8Array\n  ): Promise<Uint8Array> {\n    const requestId = this.nextRequestId++\n\n    const request = SatRpcRequest.create({\n      method,\n      requestId,\n      message,\n    })\n\n    // This line may throw, which is why setting global state is done right after\n    this.sender(request)\n\n    const { promise, resolve, reject } = emptyPromise<Uint8Array>()\n    let timer: any = 0\n\n    // Don't time requests out if debugger is attached to Node instance\n    if (!isDebuggingNode) {\n      timer = setTimeout(\n        () => this.timedOut(`${method}/${requestId}`),\n        this.defaultTimeout\n      )\n    }\n    this.pendingRequests.set(`${method}/${requestId}`, {\n      reject,\n      resolve,\n      timer,\n    })\n\n    return promise\n  }\n\n  /**\n   * Handle RPC response, dispatching it to the appropriate listener if relevant\n   */\n  public handleResponse(rpc: SatRpcResponse) {\n    const callIdentifier: RequestId = `${rpc.method}/${rpc.requestId}`\n    const pending = this.pendingRequests.get(callIdentifier)\n    if (pending) {\n      if (rpc.message) {\n        pending.resolve(rpc.message)\n      } else {\n        this.log.warn(\n          `RPC call ${callIdentifier} failed with ${msgToString(rpc.error!)}`\n        )\n        pending.reject(rpc.error)\n      }\n      this.clearAndDelete(callIdentifier)\n    } else if (this.timedOutCalls.has(callIdentifier)) {\n      this.timedOutCalls.delete(callIdentifier)\n      this.log.warn(`Got an RPC response for ${callIdentifier} after timeout`)\n    } else {\n      this.log.warn(`Got an unexpected RPC response for ${callIdentifier}`)\n    }\n  }\n\n  private clearAndDelete(callIdentifier: RequestId) {\n    const pending = this.pendingRequests.get(callIdentifier)\n\n    if (pending) {\n      clearTimeout(pending.timer)\n      this.pendingRequests.delete(callIdentifier)\n    }\n  }\n\n  private timedOut(callIdentifier: RequestId) {\n    const pending = this.pendingRequests.get(callIdentifier)\n\n    if (pending) {\n      this.log.error(\n        `Timed out after ${this.defaultTimeout}ms while waiting for RPC response to ${callIdentifier}`\n      )\n      this.timedOutCalls.add(callIdentifier)\n      pending.reject(\n        new SatelliteError(SatelliteErrorCode.TIMEOUT, callIdentifier)\n      )\n      this.clearAndDelete(callIdentifier)\n    }\n  }\n}\n\n/**\n * Build an RPC responder to reply to server-sent RPC requests.\n *\n * The responder function itself just correctly wraps the result or error in\n * a SatRpcResponse object, and then sends it.\n *\n * @param send function to send the response to the server\n * @returns function that builds and sends the RPC response\n */\nexport const rpcRespond =\n  (send: SenderFn) =>\n  (req: SatRpcRequest, respOrError: ClientRpcResponse | SatErrorResp) => {\n    const error =\n      respOrError.$type === 'Electric.Satellite.SatErrorResp'\n        ? respOrError\n        : undefined\n    const message =\n      respOrError.$type !== 'Electric.Satellite.SatErrorResp'\n        ? encodeRpcResponse(respOrError)\n        : undefined\n\n    send(\n      SatRpcResponse.create({\n        requestId: req.requestId,\n        method: req.method,\n        message,\n        error,\n      })\n    )\n  }\n\n/**\n * Wrap an RPC service instance to log decoded RPC request & response\n *\n * `proto-ts`-generated server instance passes to and expects to receive from\n * the RPC client an already encoded request/response object. To centrally log the decoded\n * version of the object, we wrap the service with a proxy, logging the yet-decoded request\n * before the function call and already-decoded response from the function return.\n *\n * @param service Service instance to wrap\n * @returns A proxy around the service instance\n */\nexport function withRpcRequestLogging(service: Root, logger: Logger): Root {\n  return new Proxy(service, {\n    get(target, p, _receiver) {\n      if (typeof target[p as keyof Root] === 'function') {\n        return new Proxy(target[p as keyof Root], {\n          apply(target, thisArg, argArray) {\n            if (logger.getLevel() <= 1)\n              logger.debug(`[rpc] send: ${msgToString(argArray[0])}`)\n            // All methods on the `RootClientImpl` service return promises that contain the response, so we can do this if we return the value\n            return Reflect.apply(target, thisArg, argArray).then(\n              (x: Awaited<ReturnType<Root[keyof Root]>>) => {\n                if (logger.getLevel() <= 1)\n                  logger.debug(`[rpc] recv: ${msgToString(x)}`)\n                return x\n              }\n            )\n          },\n        })\n      } else {\n        return Reflect.get(target, p)\n      }\n    },\n  })\n}\n"],"mappings":"AAAA;AAAA,EAGE;AAAA,EACA;AAAA,OACK;AACP,SAAS,gBAAgB,0BAA0B;AACnD,SAAS,oBAAoB;AAE7B,SAA4B,mBAAmB,mBAAmB;AAClE,SAAS,uBAAuB;AAWzB,MAAM,IAAI;AAAA,EAef,YACU,QACA,gBACA,KACR;AAHQ;AACA;AACA;AAAA,EACP;AAAA;AAAA,EAjBK,gBAAgB;AAAA;AAAA,EAEhB,kBAAkB,oBAAI,IAO5B;AAAA;AAAA,EAEM,gBAAgB,oBAAI,IAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAoBpC,QACL,UACA,QACA,SACqB;AACrB,UAAM,YAAY,KAAK;AAEvB,UAAM,UAAU,cAAc,OAAO;AAAA,MACnC;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AAGD,SAAK,OAAO,OAAO;AAEnB,UAAM,EAAE,SAAS,SAAS,OAAO,IAAI,aAAyB;AAC9D,QAAI,QAAa;AAGjB,QAAI,CAAC,iBAAiB;AACpB,cAAQ;AAAA,QACN,MAAM,KAAK,SAAS,GAAG,MAAM,IAAI,SAAS,EAAE;AAAA,QAC5C,KAAK;AAAA,MACP;AAAA,IACF;AACA,SAAK,gBAAgB,IAAI,GAAG,MAAM,IAAI,SAAS,IAAI;AAAA,MACjD;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AAED,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKO,eAAe,KAAqB;AACzC,UAAM,iBAA4B,GAAG,IAAI,MAAM,IAAI,IAAI,SAAS;AAChE,UAAM,UAAU,KAAK,gBAAgB,IAAI,cAAc;AACvD,QAAI,SAAS;AACX,UAAI,IAAI,SAAS;AACf,gBAAQ,QAAQ,IAAI,OAAO;AAAA,MAC7B,OAAO;AACL,aAAK,IAAI;AAAA,UACP,YAAY,cAAc,gBAAgB,YAAY,IAAI,KAAM,CAAC;AAAA,QACnE;AACA,gBAAQ,OAAO,IAAI,KAAK;AAAA,MAC1B;AACA,WAAK,eAAe,cAAc;AAAA,IACpC,WAAW,KAAK,cAAc,IAAI,cAAc,GAAG;AACjD,WAAK,cAAc,OAAO,cAAc;AACxC,WAAK,IAAI,KAAK,2BAA2B,cAAc,gBAAgB;AAAA,IACzE,OAAO;AACL,WAAK,IAAI,KAAK,sCAAsC,cAAc,EAAE;AAAA,IACtE;AAAA,EACF;AAAA,EAEQ,eAAe,gBAA2B;AAChD,UAAM,UAAU,KAAK,gBAAgB,IAAI,cAAc;AAEvD,QAAI,SAAS;AACX,mBAAa,QAAQ,KAAK;AAC1B,WAAK,gBAAgB,OAAO,cAAc;AAAA,IAC5C;AAAA,EACF;AAAA,EAEQ,SAAS,gBAA2B;AAC1C,UAAM,UAAU,KAAK,gBAAgB,IAAI,cAAc;AAEvD,QAAI,SAAS;AACX,WAAK,IAAI;AAAA,QACP,mBAAmB,KAAK,cAAc,wCAAwC,cAAc;AAAA,MAC9F;AACA,WAAK,cAAc,IAAI,cAAc;AACrC,cAAQ;AAAA,QACN,IAAI,eAAe,mBAAmB,SAAS,cAAc;AAAA,MAC/D;AACA,WAAK,eAAe,cAAc;AAAA,IACpC;AAAA,EACF;AACF;AAWO,MAAM,aACX,CAAC,SACD,CAAC,KAAoB,gBAAkD;AACrE,QAAM,QACJ,YAAY,UAAU,oCAClB,cACA;AACN,QAAM,UACJ,YAAY,UAAU,oCAClB,kBAAkB,WAAW,IAC7B;AAEN;AAAA,IACE,eAAe,OAAO;AAAA,MACpB,WAAW,IAAI;AAAA,MACf,QAAQ,IAAI;AAAA,MACZ;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH;AACF;AAaK,SAAS,sBAAsB,SAAe,QAAsB;AACzE,SAAO,IAAI,MAAM,SAAS;AAAA,IACxB,IAAI,QAAQ,GAAG,WAAW;AACxB,UAAI,OAAO,OAAO,CAAe,MAAM,YAAY;AACjD,eAAO,IAAI,MAAM,OAAO,CAAe,GAAG;AAAA,UACxC,MAAMA,SAAQ,SAAS,UAAU;AAC/B,gBAAI,OAAO,SAAS,KAAK;AACvB,qBAAO,MAAM,eAAe,YAAY,SAAS,CAAC,CAAC,CAAC,EAAE;AAExD,mBAAO,QAAQ,MAAMA,SAAQ,SAAS,QAAQ,EAAE;AAAA,cAC9C,CAAC,MAA6C;AAC5C,oBAAI,OAAO,SAAS,KAAK;AACvB,yBAAO,MAAM,eAAe,YAAY,CAAC,CAAC,EAAE;AAC9C,uBAAO;AAAA,cACT;AAAA,YACF;AAAA,UACF;AAAA,QACF,CAAC;AAAA,MACH,OAAO;AACL,eAAO,QAAQ,IAAI,QAAQ,CAAC;AAAA,MAC9B;AAAA,IACF;AAAA,EACF,CAAC;AACH;","names":["target"]}