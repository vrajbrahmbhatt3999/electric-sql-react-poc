{"version":3,"sources":["../../../src/cli/migrations/builder.ts"],"sourcesContent":["import * as z from 'zod'\nimport path from 'path'\nimport * as fs from 'fs/promises'\nimport {\n  Migration,\n  parseMetadata,\n  MetaData,\n  makeMigration,\n} from '../../migrators'\nimport { isObject } from '../../util'\nimport { QueryBuilder } from '../../migrators/query-builder'\n\n/*\n * This file defines functions to build migrations\n * that were fetched from Electric's endpoint.\n * To this end, we read and write files using NodeJS' `fs` module.\n * However, Electric applications do not necessarily run on NodeJS.\n * Thus, this functionality should only be used in dev mode\n * to build migrations from files using NodeJS.\n * In production, the built migrations are directly imported\n * and thus this file is not used.\n *\n * IMPORTANT: Only use this file for building the migrations.\n *            Do not to import or export this file from a file\n *            that is being imported by Electric applications\n *            as NodeJS may not be present which will cause\n *            the app to crash with a require not defined error.\n */\n\n/**\n * Loads the migrations from the provided `migrationsFolder`,\n * and updates the specified configuration file `configFile` accordingly.\n * @param migrationsFolder Folder containing the migrations.\n * @param migrationsFile File containing the built migrations of an electric application.\n *                       Built migrations contain the DDL statements and the triggers.\n */\nexport async function buildMigrations(\n  migrationsFolder: string,\n  migrationsFile: string,\n  builder: QueryBuilder\n) {\n  try {\n    const migrations = await loadMigrations(migrationsFolder, builder)\n    // Update the configuration file\n    await fs.writeFile(\n      migrationsFile,\n      `export default ${JSON.stringify(migrations, null, 2)}`\n    )\n  } catch (e) {\n    if (e instanceof z.ZodError)\n      throw new Error('Could not build migrations:\\n' + e.message)\n    else throw e\n  }\n}\n\n/**\n * Reads the provided `migrationsFolder` and returns an array\n * of all the migrations that are present in that folder.\n * Each of those migrations are in their respective folder.\n * @param migrationsFolder\n */\nexport async function getMigrationNames(\n  migrationsFolder: string\n): Promise<string[]> {\n  const contents = await fs.readdir(migrationsFolder, { withFileTypes: true })\n  const dirs = contents.filter((dirent) => dirent.isDirectory())\n  // the directory names encode the order of the migrations\n  // therefore we sort them by name to get them in chronological order\n  return dirs.map((dir) => dir.name).sort()\n}\n\n/**\n * Loads all migrations that are present in the provided migrations folder.\n * @param migrationsFolder Folder where migrations are stored.\n * @returns An array of migrations.\n */\nexport async function loadMigrations(\n  migrationsFolder: string,\n  builder: QueryBuilder\n): Promise<Migration[]> {\n  const dirNames = await getMigrationNames(migrationsFolder)\n  const migrationPaths = dirNames.map((dirName) =>\n    path.join(migrationsFolder, dirName, 'metadata.json')\n  )\n  const migrationMetaDatas = await Promise.all(\n    migrationPaths.map(readMetadataFile)\n  )\n  return migrationMetaDatas.map((data) => makeMigration(data, builder))\n}\n\n/**\n * Reads the specified metadata file.\n * @param path Path to the metadata file.\n * @returns A promise that resolves with the metadata.\n */\nasync function readMetadataFile(path: string): Promise<MetaData> {\n  try {\n    const data = await fs.readFile(path, 'utf8')\n    const jsonData = JSON.parse(data)\n\n    if (isObject(jsonData)) {\n      return parseMetadata(jsonData)\n    } else {\n      throw new Error(\n        `Migration file ${path} has wrong format, expected JSON object but found something else.`\n      )\n    }\n  } catch (e) {\n    if (e instanceof SyntaxError)\n      throw new Error(`Error while parsing migration file ${path}`)\n    else throw e\n  }\n}\n"],"mappings":"AAAA,YAAY,OAAO;AACnB,OAAO,UAAU;AACjB,YAAY,QAAQ;AACpB;AAAA,EAEE;AAAA,EAEA;AAAA,OACK;AACP,SAAS,gBAAgB;AA2BzB,eAAsB,gBACpB,kBACA,gBACA,SACA;AACA,MAAI;AACF,UAAM,aAAa,MAAM,eAAe,kBAAkB,OAAO;AAEjE,UAAM,GAAG;AAAA,MACP;AAAA,MACA,kBAAkB,KAAK,UAAU,YAAY,MAAM,CAAC,CAAC;AAAA,IACvD;AAAA,EACF,SAAS,GAAG;AACV,QAAI,aAAa,EAAE;AACjB,YAAM,IAAI,MAAM,kCAAkC,EAAE,OAAO;AAAA;AACxD,YAAM;AAAA,EACb;AACF;AAQA,eAAsB,kBACpB,kBACmB;AACnB,QAAM,WAAW,MAAM,GAAG,QAAQ,kBAAkB,EAAE,eAAe,KAAK,CAAC;AAC3E,QAAM,OAAO,SAAS,OAAO,CAAC,WAAW,OAAO,YAAY,CAAC;AAG7D,SAAO,KAAK,IAAI,CAAC,QAAQ,IAAI,IAAI,EAAE,KAAK;AAC1C;AAOA,eAAsB,eACpB,kBACA,SACsB;AACtB,QAAM,WAAW,MAAM,kBAAkB,gBAAgB;AACzD,QAAM,iBAAiB,SAAS;AAAA,IAAI,CAAC,YACnC,KAAK,KAAK,kBAAkB,SAAS,eAAe;AAAA,EACtD;AACA,QAAM,qBAAqB,MAAM,QAAQ;AAAA,IACvC,eAAe,IAAI,gBAAgB;AAAA,EACrC;AACA,SAAO,mBAAmB,IAAI,CAAC,SAAS,cAAc,MAAM,OAAO,CAAC;AACtE;AAOA,eAAe,iBAAiBA,OAAiC;AAC/D,MAAI;AACF,UAAM,OAAO,MAAM,GAAG,SAASA,OAAM,MAAM;AAC3C,UAAM,WAAW,KAAK,MAAM,IAAI;AAEhC,QAAI,SAAS,QAAQ,GAAG;AACtB,aAAO,cAAc,QAAQ;AAAA,IAC/B,OAAO;AACL,YAAM,IAAI;AAAA,QACR,kBAAkBA,KAAI;AAAA,MACxB;AAAA,IACF;AAAA,EACF,SAAS,GAAG;AACV,QAAI,aAAa;AACf,YAAM,IAAI,MAAM,sCAAsCA,KAAI,EAAE;AAAA;AACzD,YAAM;AAAA,EACb;AACF;","names":["path"]}