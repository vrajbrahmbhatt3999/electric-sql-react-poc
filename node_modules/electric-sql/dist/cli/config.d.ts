import type { Command } from 'commander';
import { extractDatabaseURL, extractServiceURL } from './util/index.js';
import { configOptions } from './config-options.js';
export type ConfigMap = Record<string, string | number | boolean>;
export interface AnyConfigOption {
    doc: string;
    valueType: typeof String | typeof Number | typeof Boolean;
    valueTypeName?: string;
    shortForm?: string;
    inferVal?: (options: ConfigMap) => string | number | boolean | undefined;
    defaultVal?: string | number | boolean | ((options: ConfigMap) => string | number | boolean);
    constructedDefault?: string;
    secret?: true;
    groups?: Readonly<string[]>;
}
export type ConfigOptions = typeof configOptions;
export type ConfigOptionName = keyof ConfigOptions;
type ConfigOption<T extends ConfigOptionName> = ConfigOptions[T];
type ConfigOptionValue<T extends ConfigOptionName> = ConfigOption<T> extends {
    inferVal: undefined;
    defaultVal: undefined;
} ? ReturnType<ConfigOption<T>['valueType']> | undefined : ReturnType<ConfigOption<T>['valueType']>;
export declare function inferDbUrlPart<K extends keyof ReturnType<typeof extractDatabaseURL>>(part: K, options?: any, defaultValue?: ReturnType<typeof extractDatabaseURL>[K]): ReturnType<typeof extractDatabaseURL>[K] | undefined;
export declare function inferProxyUrlPart<K extends keyof ReturnType<typeof extractDatabaseURL>>(part: K, options?: any, defaultValue?: ReturnType<typeof extractDatabaseURL>[K]): ReturnType<typeof extractDatabaseURL>[K] | undefined;
export declare function inferServiceUrlPart<K extends keyof ReturnType<typeof extractServiceURL>>(part: K, options?: any, defaultValue?: ReturnType<typeof extractServiceURL>[K]): ReturnType<typeof extractServiceURL>[K] | undefined;
export declare function getConfigValue<K extends ConfigOptionName>(name: K, options?: any): ConfigOptionValue<K>;
export type Config = {
    [K in ConfigOptionName]: ConfigOptionValue<K>;
};
type ConfigCamelCase = {
    [K in ConfigOptionName as `${Camelize<Lowercase<K>>}`]: ConfigOptionValue<K>;
};
type GetConfigOptions = Partial<Config & ConfigCamelCase>;
export type Group = ConfigOptions[ConfigOptionName]['groups'][number];
export type ConfigForGroup<G extends Group> = {
    [K in ConfigOptionName as G extends ConfigOptions[K]['groups'][number] ? K : never]: ConfigOptionValue<K>;
};
export type GetConfigOptionsForGroup<G extends Group> = Partial<ConfigForGroup<G> & {
    [K in ConfigOptionName as G extends ConfigOptions[K]['groups'][number] ? `${Camelize<Lowercase<K>>}` : never]: ConfigOptionValue<K>;
}>;
/**
 * Get the current configuration for Electric from environment variables and
 * any passed options.
 * @param options Object containing options to override the environment variables
 * @returns The current configuration
 */
export declare function getConfig(options?: GetConfigOptions): Config;
export declare function envFromConfig(config: Config): {
    [k: string]: any;
};
/**
 * Redacts sensitive information like secrets and passwords from the
 * config and returns a separate, redacted version.
 *
 * Redaction is done based on the `secret` property of the
 * configuration option.
 */
export declare function redactConfigSecrets(config: Config): Config;
/**
 * Prints the provided `config` taking care to redact any
 * sensitive values
 */
export declare function printConfig(config: Config): void;
export declare function addOptionToCommand(command: Command, optionName: ConfigOptionName): void;
export declare function addOptionGroupToCommand(command: Command, groupName: string): void;
type Camelize<T extends string> = T extends `${infer A}_${infer B}` ? `${A}${Camelize<Capitalize<B>>}` : T;
export {};
