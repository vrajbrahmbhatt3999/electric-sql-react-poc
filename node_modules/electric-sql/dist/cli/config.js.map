{"version":3,"sources":["../../src/cli/config.ts"],"sourcesContent":["import type { Command } from 'commander'\nimport { extractDatabaseURL, extractServiceURL } from './util'\nimport { configOptions } from './config-options'\n\nexport type ConfigMap = Record<string, string | number | boolean>\n\nexport interface AnyConfigOption {\n  doc: string\n  valueType: typeof String | typeof Number | typeof Boolean\n  valueTypeName?: string\n  shortForm?: string\n  inferVal?: (options: ConfigMap) => string | number | boolean | undefined\n  defaultVal?:\n    | string\n    | number\n    | boolean\n    | ((options: ConfigMap) => string | number | boolean)\n  constructedDefault?: string\n  secret?: true\n  groups?: Readonly<string[]>\n}\n\nexport type ConfigOptions = typeof configOptions\n\nexport type ConfigOptionName = keyof ConfigOptions\n\ntype ConfigOption<T extends ConfigOptionName> = ConfigOptions[T]\n\ntype ConfigOptionValue<T extends ConfigOptionName> = ConfigOption<T> extends {\n  inferVal: undefined\n  defaultVal: undefined\n}\n  ? ReturnType<ConfigOption<T>['valueType']> | undefined\n  : ReturnType<ConfigOption<T>['valueType']>\n\nexport function inferDbUrlPart<\n  K extends keyof ReturnType<typeof extractDatabaseURL>\n>(\n  part: K,\n  options: any = {},\n  defaultValue?: ReturnType<typeof extractDatabaseURL>[K]\n): ReturnType<typeof extractDatabaseURL>[K] | undefined {\n  const url =\n    options.databaseUrl ||\n    options.DATABASE_URL ||\n    process.env.ELECTRIC_DATABASE_URL\n  if (url) {\n    return extractDatabaseURL(url)?.[part] ?? defaultValue\n  }\n  return defaultValue\n}\n\nexport function inferProxyUrlPart<\n  K extends keyof ReturnType<typeof extractDatabaseURL>\n>(\n  part: K,\n  options: any = {},\n  defaultValue?: ReturnType<typeof extractDatabaseURL>[K]\n): ReturnType<typeof extractDatabaseURL>[K] | undefined {\n  const url = options.proxy || options.PROXY || process.env.ELECTRIC_PROXY\n  if (url) {\n    return extractDatabaseURL(url)?.[part] ?? defaultValue\n  }\n  return defaultValue\n}\n\nexport function inferServiceUrlPart<\n  K extends keyof ReturnType<typeof extractServiceURL>\n>(\n  part: K,\n  options: any = {},\n  defaultValue?: ReturnType<typeof extractServiceURL>[K]\n): ReturnType<typeof extractServiceURL>[K] | undefined {\n  const url = options.service || options.SERVICE || process.env.ELECTRIC_SERVICE\n  if (url) {\n    return extractServiceURL(url)?.[part] ?? defaultValue\n  }\n  return defaultValue\n}\n\nexport function getConfigValue<K extends ConfigOptionName>(\n  name: K,\n  options?: any\n): ConfigOptionValue<K> {\n  // First check if the option was passed as a command line argument\n  if (options) {\n    const strippedName = name.startsWith('ELECTRIC_')\n      ? name.slice('ELECTRIC_'.length)\n      : name\n    const optName = snakeToCamel(strippedName.toLocaleLowerCase())\n    if (options[optName] !== undefined) {\n      return options[optName] as ConfigOptionValue<K>\n    } else if (options[name] !== undefined) {\n      return options[name] as ConfigOptionValue<K>\n    }\n  }\n\n  // Then check if the option has an method to infer a value from other options.\n  // If we get a value from this method, use it.\n  const inferVal = (configOptions[name] as AnyConfigOption).inferVal as (\n    options: ConfigMap\n  ) => ConfigOptionValue<K> | undefined\n  if (inferVal) {\n    const val = inferVal(options)\n    if (val !== undefined) {\n      return val\n    }\n  }\n\n  // Then check if the option was passed as an environment variable\n  const envName = name.startsWith('ELECTRIC_') ? name : `ELECTRIC_${name}`\n  const envVal = process.env[envName]\n  if (configOptions[name].valueType === Boolean) {\n    return (!!envVal &&\n      !['f', 'false', '0', '', 'no'].includes(\n        envVal?.toLocaleLowerCase()\n      )) as ConfigOptionValue<K>\n  }\n  if (envVal !== undefined) {\n    if (configOptions[name].valueType === Number) {\n      return parseInt(envVal) as ConfigOptionValue<K>\n    } else {\n      return envVal as ConfigOptionValue<K>\n    }\n  }\n\n  // Finally, check if the option has a default value\n  const defaultVal = (configOptions[name] as AnyConfigOption).defaultVal as\n    | ConfigOptionValue<K>\n    | ((options: ConfigMap) => ConfigOptionValue<K>)\n  if (typeof defaultVal === 'function') {\n    return defaultVal(options)\n  }\n  return defaultVal\n}\n\nexport type Config = {\n  [K in ConfigOptionName]: ConfigOptionValue<K>\n}\n\ntype ConfigCamelCase = {\n  [K in ConfigOptionName as `${Camelize<Lowercase<K>>}`]: ConfigOptionValue<K>\n}\n\ntype GetConfigOptions = Partial<Config & ConfigCamelCase>\n\nexport type Group = ConfigOptions[ConfigOptionName]['groups'][number]\n\nexport type ConfigForGroup<G extends Group> = {\n  [K in ConfigOptionName as G extends ConfigOptions[K]['groups'][number]\n    ? K\n    : never]: ConfigOptionValue<K>\n}\n\nexport type GetConfigOptionsForGroup<G extends Group> = Partial<\n  ConfigForGroup<G> & {\n    [K in ConfigOptionName as G extends ConfigOptions[K]['groups'][number]\n      ? `${Camelize<Lowercase<K>>}`\n      : never]: ConfigOptionValue<K>\n  }\n>\n\n/**\n * Get the current configuration for Electric from environment variables and\n * any passed options.\n * @param options Object containing options to override the environment variables\n * @returns The current configuration\n */\nexport function getConfig(options?: GetConfigOptions): Config {\n  return Object.fromEntries(\n    Object.keys(configOptions).map((name) => [\n      name,\n      getConfigValue(name as ConfigOptionName, options ?? {}),\n    ])\n  ) as Config\n}\n\nexport function envFromConfig(config: Config) {\n  return Object.fromEntries(\n    Object.keys(config).map((name) => [\n      name.startsWith('ELECTRIC_') ? name : `ELECTRIC_${name}`,\n      config[name as ConfigOptionName]?.toString(),\n    ])\n  )\n}\n\n/**\n * Redacts the given `stringToRedact` from the `config` _in place_,\n * replacing any mention of the string with `******`.\n */\nfunction redactConfigValue(config: Config, stringToRedact: string): void {\n  Object.entries(config).forEach(([key, value]) => {\n    if (typeof value === 'string' && value.includes(stringToRedact)) {\n      config[key] = value.replaceAll(stringToRedact, '******')\n    }\n  })\n}\n\n/**\n * Redacts sensitive information like secrets and passwords from the\n * config and returns a separate, redacted version.\n *\n * Redaction is done based on the `secret` property of the\n * configuration option.\n */\nexport function redactConfigSecrets(config: Config): Config {\n  const valuesToRedact = Object.keys(config)\n    .filter((k) => configOptions[k]?.secret)\n    .map((k) => config[k])\n  const redactedConfig = { ...config }\n  valuesToRedact.forEach((v) => redactConfigValue(redactedConfig, v))\n  return redactedConfig\n}\n\n/**\n * Prints the provided `config` taking care to redact any\n * sensitive values\n */\nexport function printConfig(config: Config): void {\n  console.log(redactConfigSecrets(config))\n}\n\nfunction snakeToCamel(s: string) {\n  return s\n    .toLocaleLowerCase()\n    .replace(/(_+\\w)/g, (m) => m.slice(-1).toUpperCase())\n}\n\nexport function addOptionToCommand(\n  command: Command,\n  optionName: ConfigOptionName\n) {\n  let argName = optionName.toLocaleLowerCase().replace(/_/g, '-')\n  if (argName.startsWith('electric-')) {\n    argName = argName.slice('electric-'.length)\n  }\n  let localName: string = optionName\n  if (!optionName.startsWith('ELECTRIC_')) {\n    localName = `ELECTRIC_${optionName}`\n  }\n  const opt = configOptions[optionName] as AnyConfigOption\n  let flags\n  if (opt.shortForm) {\n    flags = `-${opt.shortForm}, --${argName}`\n  } else {\n    flags = `--${argName}`\n  }\n  if (opt.valueType !== Boolean) {\n    if (opt.valueTypeName !== undefined) {\n      flags += ` <${opt.valueTypeName}>`\n    } else if (opt.valueType === Number) {\n      flags += ` <number>`\n    } else if (opt.valueType === String) {\n      flags += ` <string>`\n    } else {\n      throw new Error(`Unknown value type: ${opt.valueType}`)\n    }\n  }\n  let doc = `${opt.doc}\\nEnv var: ${localName}`\n  if (opt.constructedDefault) {\n    doc += `\\nDefault: ${opt.constructedDefault}`\n  } else if (typeof opt.defaultVal !== 'function') {\n    doc += `\\nDefault: ${opt.defaultVal}`\n  }\n  command.option(flags, doc)\n}\n\nexport function addOptionGroupToCommand(command: Command, groupName: string) {\n  Object.entries(configOptions).forEach(([name, opt]) => {\n    const groups: Readonly<string[]> = opt.groups ?? []\n    if (groups.includes(groupName)) {\n      addOptionToCommand(command, name as ConfigOptionName)\n    }\n  })\n}\n\ntype Camelize<T extends string> = T extends `${infer A}_${infer B}`\n  ? `${A}${Camelize<Capitalize<B>>}`\n  : T\n"],"mappings":"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","names":[]}