import * as z from "zod";
import { SatOpMigrate } from '../_generated/protocol/satellite.js';
import { base64 } from '../util/encoders/index.js';
import { getProtocolVersion } from '../util/index.js';
import { generateTriggersForTable } from '../satellite/process.js';
import { sqliteBuilder, pgBuilder, QueryBuilder } from './query-builder/index.js';
const metaDataSchema = z.object({
  format: z.string(),
  ops: z.string().array(),
  protocol_version: z.string(),
  version: z.string()
}).strict();
const format = "SatOpMigrate";
const protocolVersion = getProtocolVersion();
function parseMetadata(data) {
  try {
    const parsed = metaDataSchema.parse(data);
    if (parsed.format !== format)
      throw new Error("Unsupported migration format: " + parsed.format);
    if (parsed.protocol_version !== protocolVersion)
      throw new Error(
        "Protocol version mismatch for migration. Expected: " + protocolVersion + ". Got: " + parsed.protocol_version
      );
    const decoded = {
      format: parsed.format,
      ops: parsed.ops.map(decode),
      protocolVersion: parsed.protocol_version,
      version: parsed.version
    };
    return decoded;
  } catch (e) {
    if (e instanceof z.ZodError) {
      throw new Error("Failed to parse migration data, due to:\n" + e.message);
    } else {
      throw e;
    }
  }
}
function makeMigration(migration, builder) {
  const statements = migration.ops.map((op) => op.stmts.map((stmt) => stmt.sql)).flat();
  const tables = migration.ops.filter((op) => op.table !== void 0).map((op) => op.table).filter((tbl, idx, arr) => {
    return arr.findIndex((t) => t?.name === tbl?.name) === idx;
  });
  const triggers = tables.map((tbl) => generateTriggersForTable(tbl, builder)).flat().map((stmt) => stmt.sql);
  return {
    statements: [...statements, ...triggers],
    version: migration.version
  };
}
function decode(data) {
  const bytes = base64.toBytes(data);
  const dataOrError = SatOpMigrate.decode(bytes);
  if (dataOrError instanceof Error)
    throw dataOrError;
  return dataOrError;
}
export {
  QueryBuilder,
  makeMigration,
  parseMetadata,
  pgBuilder,
  sqliteBuilder
};
//# sourceMappingURL=builder.js.map