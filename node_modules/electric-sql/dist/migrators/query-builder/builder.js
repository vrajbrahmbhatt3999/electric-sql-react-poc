import { QualifiedTablename } from '../../util/index.js';
class QueryBuilder {
  /**
   * Creates or replaces a trigger that prevents updates to the primary key.
   */
  createOrReplaceNoFkUpdateTrigger(table, pk) {
    return [
      this.dropTriggerIfExists(
        `update_ensure_${table.namespace}_${table.tablename}_primarykey`,
        table
      ),
      ...this.createNoFkUpdateTrigger(table, pk)
    ];
  }
  createOrReplaceOplogTrigger(opType, table, newPKs, newRows, oldRows) {
    return [
      this.dropTriggerIfExists(
        `${opType.toLowerCase()}_${table.namespace}_${table.tablename}_into_oplog`,
        table
      ),
      ...this.createOplogTrigger(opType, table, newPKs, newRows, oldRows)
    ];
  }
  /**
   * Creates or replaces a trigger that logs insertions into the oplog.
   */
  createOrReplaceInsertTrigger = this.createOrReplaceOplogTrigger.bind(
    this,
    "INSERT"
  );
  /**
   * Creates or replaces a trigger that logs updates into the oplog.
   */
  createOrReplaceUpdateTrigger = this.createOrReplaceOplogTrigger.bind(
    this,
    "UPDATE"
  );
  /**
   * Creates or replaces a trigger that logs deletions into the oplog.
   */
  createOrReplaceDeleteTrigger = this.createOrReplaceOplogTrigger.bind(
    this,
    "DELETE"
  );
  createOrReplaceFkCompensationTrigger(opType, table, childKey, fkTable, joinedFkPKs, foreignKey) {
    return [
      this.dropTriggerIfExists(
        `compensation_${opType.toLowerCase()}_${table.namespace}_${table.tablename}_${childKey}_into_oplog`,
        table
      ),
      ...this.createFkCompensationTrigger(
        opType,
        table,
        childKey,
        fkTable,
        joinedFkPKs,
        foreignKey
      )
    ];
  }
  /**
   * Creates a trigger that logs compensations for insertions into the oplog.
   */
  createOrReplaceInsertCompensationTrigger = this.createOrReplaceFkCompensationTrigger.bind(this, "INSERT");
  /**
   * Creates a trigger that logs compensations for updates into the oplog.
   */
  createOrReplaceUpdateCompensationTrigger = this.createOrReplaceFkCompensationTrigger.bind(this, "UPDATE");
  /**
   * Prepare multiple batched insert statements for an array of records.
   *
   * Since SQLite only supports a limited amount of positional `?` parameters,
   * we generate multiple insert statements with each one being filled as much
   * as possible from the given data. All statements are derived from same `baseSql` -
   * the positional parameters will be appended to this string.
   *
   * @param baseSql base SQL string to which inserts should be appended
   * @param columns columns that describe records
   * @param records records to be inserted
   * @param maxParameters max parameters this SQLite can accept - determines batching factor
   * @param suffixSql optional SQL string to append to each insert statement
   * @returns array of statements ready to be executed by the adapter
   */
  prepareInsertBatchedStatements(baseSql, columns, records, maxParameters, suffixSql = "") {
    const stmts = [];
    const columnCount = columns.length;
    const recordCount = records.length;
    const batchMaxSize = Math.floor(maxParameters / columnCount);
    const tempColJoinArray = Array.from({ length: columnCount });
    let processed = 0;
    let prevInsertCount = -1;
    let insertPattern = "";
    while (processed < recordCount) {
      const currentInsertCount = Math.min(recordCount - processed, batchMaxSize);
      if (currentInsertCount !== prevInsertCount) {
        insertPattern = Array.from(
          { length: currentInsertCount },
          (_, recordIdx) => {
            for (let i = 0; i < columnCount; i++) {
              tempColJoinArray[i] = this.makePositionalParam(
                recordIdx * columnCount + i + 1
              );
            }
            return ` (${tempColJoinArray.join(", ")})`;
          }
        ).join(",");
      }
      let sql = baseSql + insertPattern;
      if (suffixSql !== "") {
        sql += " " + suffixSql;
      }
      const args = [];
      for (let i = 0; i < currentInsertCount; i++) {
        for (let j = 0; j < columnCount; j++) {
          args.push(records[processed + i][columns[j]]);
        }
      }
      processed += currentInsertCount;
      prevInsertCount = currentInsertCount;
      stmts.push({ sql, args });
    }
    return stmts;
  }
  /**
   * Prepare multiple batched DELETE statements for an array of records.
   *
   * Since SQLite only supports a limited amount of positional `?` parameters,
   * we generate multiple delete statements with each one being filled as much
   * as possible from the given data. This function only supports column equality checks
   *
   * @param baseSql base SQL string to which inserts should be appended
   * @param columns columns that describe records
   * @param records records to be inserted
   * @param maxParameters max parameters this SQLite can accept - determines batching factor
   * @param suffixSql optional SQL string to append to each insert statement
   * @returns array of statements ready to be executed by the adapter
   */
  prepareDeleteBatchedStatements(baseSql, columns, records, maxParameters, suffixSql = "") {
    const stmts = [];
    const columnCount = columns.length;
    const recordCount = records.length;
    const batchMaxSize = Math.floor(maxParameters / columnCount);
    const tempColumnComparisonJoinArr = Array.from({ length: columnCount });
    let processed = 0;
    let prevDeleteCount = -1;
    let deletePattern = "";
    while (processed < recordCount) {
      const currentDeleteCount = Math.min(recordCount - processed, batchMaxSize);
      if (currentDeleteCount !== prevDeleteCount) {
        deletePattern = Array.from(
          { length: currentDeleteCount },
          (_, recordIdx) => {
            for (let i = 0; i < columnCount; i++) {
              tempColumnComparisonJoinArr[i] = `"${columns[i]}" = ${this.makePositionalParam(recordIdx * columnCount + i + 1)}`;
            }
            return ` (${tempColumnComparisonJoinArr.join(" AND ")})`;
          }
        ).join(" OR");
      }
      let sql = baseSql + deletePattern;
      if (suffixSql !== "") {
        sql += " " + suffixSql;
      }
      const args = [];
      for (let i = 0; i < currentDeleteCount; i++) {
        for (let j = 0; j < columnCount; j++) {
          args.push(records[processed + i][columns[j]]);
        }
      }
      processed += currentDeleteCount;
      prevDeleteCount = currentDeleteCount;
      stmts.push({ sql, args });
    }
    return stmts;
  }
  makeQT(tablename) {
    return new QualifiedTablename(this.defaultNamespace, tablename);
  }
}
export {
  QueryBuilder
};
//# sourceMappingURL=builder.js.map