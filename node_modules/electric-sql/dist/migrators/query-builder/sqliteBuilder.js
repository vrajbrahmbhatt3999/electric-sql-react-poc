import { dedent } from "ts-dedent";
import { QueryBuilder } from './builder.js';
class SqliteBuilder extends QueryBuilder {
  dialect = "SQLite";
  AUTOINCREMENT_PK = "INTEGER PRIMARY KEY AUTOINCREMENT";
  BLOB = "BLOB";
  deferOrDisableFKsForTx = "PRAGMA defer_foreign_keys = ON;";
  getVersion = "SELECT sqlite_version() AS version";
  maxSqlParameters = 65535;
  paramSign = "?";
  defaultNamespace = "main";
  metaTables = [
    "sqlite_schema",
    "sqlite_sequence",
    "sqlite_temp_schema"
  ];
  pgOnly(_query) {
    return "";
  }
  pgOnlyQuery(_query) {
    return [];
  }
  sqliteOnly(query) {
    return query;
  }
  sqliteOnlyQuery(query) {
    return [query];
  }
  tableExists(table) {
    return {
      sql: `SELECT 1 FROM sqlite_master WHERE type = 'table' AND name = ?`,
      args: [table.tablename]
    };
  }
  countTablesIn(tableNames) {
    const sql = dedent`
      SELECT count(name) as "count" FROM sqlite_master
        WHERE type='table'
        AND name IN (${tableNames.map(() => "?").join(", ")})
    `;
    return {
      sql,
      args: tableNames
    };
  }
  toHex(column) {
    return `hex(${column})`;
  }
  hexValue(hexString) {
    return `x'${hexString}'`;
  }
  getTableInfo(table) {
    return {
      sql: `SELECT name, type, "notnull", dflt_value, pk FROM pragma_table_info(?)`,
      args: [table.tablename]
    };
  }
  createIndex(indexName, onTable, columns) {
    const namespace = onTable.namespace;
    const tablename = onTable.tablename;
    return `CREATE INDEX IF NOT EXISTS ${namespace}.${indexName} ON ${tablename} (${columns.join(
      ", "
    )})`;
  }
  getLocalTableNames(notIn = []) {
    const ignore = this.metaTables.concat(notIn);
    const tables = `
      SELECT name FROM sqlite_master
        WHERE type = 'table' AND
              name NOT IN (${ignore.map(() => "?").join(",")})
    `;
    return {
      sql: tables,
      args: ignore
    };
  }
  insertOrIgnore(table, columns, values) {
    return {
      sql: dedent`
        INSERT OR IGNORE INTO ${table} (${columns.join(", ")})
          VALUES (${columns.map(() => "?").join(", ")});
      `,
      args: values
    };
  }
  insertOrReplace(table, columns, values, _conflictCols, _updateCols) {
    return {
      sql: dedent`
        INSERT OR REPLACE INTO ${table} (${columns.join(", ")})
        VALUES (${columns.map(() => "?").join(", ")})
      `,
      args: values
    };
  }
  insertOrReplaceWith(table, columns, values, conflictCols, updateCols, updateVals) {
    const { sql: baseSql, args } = this.insertOrReplace(
      table,
      columns,
      values,
      conflictCols,
      updateCols
    );
    return {
      sql: baseSql + ` ON CONFLICT DO UPDATE SET ${updateCols.map((col) => `${col} = ?`).join(", ")}`,
      args: args.concat(updateVals)
    };
  }
  batchedInsertOrReplace(table, columns, records, _conflictCols, _updateCols, maxSqlParameters) {
    const baseSql = `INSERT OR REPLACE INTO ${table} (${columns.join(
      ", "
    )}) VALUES `;
    return this.prepareInsertBatchedStatements(
      baseSql,
      columns,
      records,
      maxSqlParameters
    );
  }
  dropTriggerIfExists(triggerName, _tablename) {
    return `DROP TRIGGER IF EXISTS ${triggerName};`;
  }
  createNoFkUpdateTrigger(table, pk) {
    const { namespace, tablename } = table;
    return [
      dedent`
        CREATE TRIGGER update_ensure_${namespace}_${tablename}_primarykey
          BEFORE UPDATE ON ${table}
        BEGIN
          SELECT
            CASE
              ${pk.map(
        (col) => `WHEN old."${col}" != new."${col}" THEN
		RAISE (ABORT, 'cannot change the value of column ${col} as it belongs to the primary key')`
      ).join("\n")}
            END;
        END;
      `
    ];
  }
  createJsonObject(rows) {
    return `json_object(${rows})`;
  }
  // removes null values from the JSON
  // to be consistent with PG behaviour
  removeSpaceAndNullValuesFromJson(json) {
    return `json_patch('{}', ${json})`;
  }
  createPKJsonObject(rows) {
    return this.removeSpaceAndNullValuesFromJson(this.createJsonObject(rows));
  }
  setTriggerSetting(table, value) {
    const { namespace, tablename } = table;
    return `INSERT OR IGNORE INTO _electric_trigger_settings (namespace, tablename, flag) VALUES ('${namespace}', '${tablename}', ${value});`;
  }
  createOplogTrigger(opType, table, newPKs, newRows, oldRows) {
    const { namespace, tablename } = table;
    const opTypeLower = opType.toLowerCase();
    const pk = this.createPKJsonObject(newPKs);
    const newRecord = opType === "DELETE" ? "NULL" : this.createJsonObject(newRows);
    const oldRecord = opType === "INSERT" ? "NULL" : this.createJsonObject(oldRows);
    return [
      dedent`
        CREATE TRIGGER ${opTypeLower}_${namespace}_${tablename}_into_oplog
           AFTER ${opType} ON ${table}
           WHEN 1 = (SELECT flag from _electric_trigger_settings WHERE namespace = '${namespace}' AND tablename = '${tablename}')
        BEGIN
          INSERT INTO _electric_oplog (namespace, tablename, optype, primaryKey, newRow, oldRow, timestamp)
          VALUES ('${namespace}', '${tablename}', '${opType}', ${pk}, ${newRecord}, ${oldRecord}, NULL);
        END;
      `
    ];
  }
  createFkCompensationTrigger(opType, table, childKey, fkTable, joinedFkPKs, foreignKey) {
    const { namespace, tablename } = table;
    const { namespace: fkTableNamespace, tablename: fkTableName } = fkTable;
    const opTypeLower = opType.toLowerCase();
    return [
      dedent`
        CREATE TRIGGER compensation_${opTypeLower}_${namespace}_${tablename}_${childKey}_into_oplog
          AFTER ${opType} ON ${table}
          WHEN 1 = (SELECT flag from _electric_trigger_settings WHERE namespace = '${namespace}' AND tablename = '${tablename}') AND
               1 = (SELECT value from _electric_meta WHERE key = 'compensations')
        BEGIN
          INSERT INTO _electric_oplog (namespace, tablename, optype, primaryKey, newRow, oldRow, timestamp)
          SELECT '${fkTableNamespace}', '${fkTableName}', 'COMPENSATION', ${this.createPKJsonObject(
        joinedFkPKs
      )}, json_object(${joinedFkPKs}), NULL, NULL
          FROM ${fkTable} WHERE "${foreignKey.parentKey}" = new."${foreignKey.childKey}";
        END;
      `
    ];
  }
  setTagsForShadowRows(oplog, shadow) {
    return dedent`
      INSERT OR REPLACE INTO ${shadow} (namespace, tablename, primaryKey, tags)
      SELECT namespace, tablename, primaryKey, ?
        FROM ${oplog} AS op
        WHERE timestamp = ?
        GROUP BY namespace, tablename, primaryKey
        HAVING rowid = max(rowid) AND optype != 'DELETE'
    `;
  }
  removeDeletedShadowRows(oplog, shadow) {
    return dedent`
      WITH _to_be_deleted (rowid) AS (
        SELECT shadow.rowid
          FROM ${oplog} AS op
          INNER JOIN ${shadow} AS shadow
            ON shadow.namespace = op.namespace AND shadow.tablename = op.tablename AND shadow.primaryKey = op.primaryKey
          WHERE op.timestamp = ?
          GROUP BY op.namespace, op.tablename, op.primaryKey
          HAVING op.rowid = max(op.rowid) AND op.optype = 'DELETE'
      )
  
      DELETE FROM ${shadow}
      WHERE rowid IN _to_be_deleted
    `;
  }
  makePositionalParam(_i) {
    return this.paramSign;
  }
}
var sqliteBuilder_default = new SqliteBuilder();
export {
  sqliteBuilder_default as default
};
//# sourceMappingURL=sqliteBuilder.js.map