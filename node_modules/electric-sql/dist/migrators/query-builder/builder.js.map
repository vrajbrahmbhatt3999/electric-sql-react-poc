{"version":3,"sources":["../../../src/migrators/query-builder/builder.ts"],"sourcesContent":["import { ForeignKey } from '../triggers'\nimport { QualifiedTablename, SqlValue, Statement } from '../../util'\n\nexport type Dialect = 'SQLite' | 'Postgres'\nexport abstract class QueryBuilder {\n  abstract readonly dialect: Dialect\n  abstract readonly paramSign: '?' | '$'\n  abstract readonly defaultNamespace: 'main' | 'public'\n\n  /**\n   * The autoincrementing integer primary key type for the current SQL dialect.\n   */\n  abstract readonly AUTOINCREMENT_PK: string\n\n  /**\n   * The type to use for BLOB for the current SQL dialect.\n   */\n  abstract readonly BLOB: string\n\n  /**\n   * Queries the version of SQLite/Postgres we are using.\n   */\n  abstract readonly getVersion: string\n\n  /**\n   * Depending on the dialect, defers or disables foreign key checks for the duration of the transaction.\n   */\n  abstract readonly deferOrDisableFKsForTx: string\n\n  /**\n   * Returns the given query if the current SQL dialect is PostgreSQL.\n   */\n  abstract pgOnly(query: string): string\n\n  /**\n   * Returns the given query if the current SQL dialect is SQLite.\n   */\n  abstract sqliteOnly(query: string): string\n\n  /**\n   * Makes the i-th positional parameter,\n   * e.g. '$3' For Postgres when `i` is 3\n   *      and always '?' for SQLite\n   */\n  abstract makePositionalParam(i: number): string\n\n  /**\n   * Checks if the given table exists.\n   */\n  abstract tableExists(table: QualifiedTablename): Statement\n\n  /**\n   * Counts tables whose name is included in `tableNames`.\n   */\n  abstract countTablesIn(tableNames: string[]): Statement\n\n  /**\n   * Converts a column value to a hexidecimal string.\n   */\n  abstract toHex(column: string): string\n\n  /**\n   * Converts a hexidecimal string to a hex value.\n   */\n  abstract hexValue(hexString: string): string\n\n  /**\n   * Create an index on a table.\n   */\n  abstract createIndex(\n    indexName: string,\n    onTable: QualifiedTablename,\n    columns: string[]\n  ): string\n\n  /**\n   * Fetches the names of all tables that are not in `notIn`.\n   */\n  abstract getLocalTableNames(notIn?: string[]): Statement\n\n  /**\n   * Fetches information about the columns of a table.\n   * The information includes all column names, their type,\n   * whether or not they are nullable, and whether they are part of the PK.\n   */\n  abstract getTableInfo(table: QualifiedTablename): Statement\n\n  /**\n   * Insert a row into a table, ignoring it if it already exists.\n   */\n  abstract insertOrIgnore(\n    table: QualifiedTablename,\n    columns: string[],\n    values: SqlValue[]\n  ): Statement\n\n  /**\n   * Insert a row into a table, replacing it if it already exists.\n   */\n  abstract insertOrReplace(\n    table: QualifiedTablename,\n    columns: string[],\n    values: Array<SqlValue>,\n    conflictCols: string[],\n    updateCols: string[]\n  ): Statement\n\n  /**\n   * Insert a row into a table.\n   * If it already exists we update the provided columns `updateCols`\n   * with the provided values `updateVals`\n   */\n  abstract insertOrReplaceWith(\n    table: QualifiedTablename,\n    columns: string[],\n    values: Array<SqlValue>,\n    conflictCols: string[],\n    updateCols: string[],\n    updateVals: SqlValue[]\n  ): Statement\n\n  /**\n   * Inserts a batch of rows into a table, replacing them if they already exist.\n   */\n  abstract batchedInsertOrReplace(\n    table: QualifiedTablename,\n    columns: string[],\n    records: Array<Record<string, SqlValue>>,\n    conflictCols: string[],\n    updateCols: string[],\n    maxSqlParameters: number\n  ): Statement[]\n\n  /**\n   * Drop a trigger if it exists.\n   */\n  abstract dropTriggerIfExists(\n    triggerName: string,\n    table: QualifiedTablename\n  ): string\n\n  /**\n   * Create a trigger that prevents updates to the primary key.\n   */\n  abstract createNoFkUpdateTrigger(\n    table: QualifiedTablename,\n    pk: string[]\n  ): string[]\n\n  /**\n   * Creates or replaces a trigger that prevents updates to the primary key.\n   */\n  createOrReplaceNoFkUpdateTrigger(\n    table: QualifiedTablename,\n    pk: string[]\n  ): string[] {\n    return [\n      this.dropTriggerIfExists(\n        `update_ensure_${table.namespace}_${table.tablename}_primarykey`,\n        table\n      ),\n      ...this.createNoFkUpdateTrigger(table, pk),\n    ]\n  }\n\n  /**\n   * Modifies the trigger setting for the table identified by its tablename and namespace.\n   */\n  abstract setTriggerSetting(table: QualifiedTablename, value: 0 | 1): string\n\n  /**\n   * Create a trigger that logs operations into the oplog.\n   */\n  abstract createOplogTrigger(\n    opType: 'INSERT' | 'UPDATE' | 'DELETE',\n    table: QualifiedTablename,\n    newPKs: string,\n    newRows: string,\n    oldRows: string\n  ): string[]\n\n  createOrReplaceOplogTrigger(\n    opType: 'INSERT' | 'UPDATE' | 'DELETE',\n    table: QualifiedTablename,\n    newPKs: string,\n    newRows: string,\n    oldRows: string\n  ): string[] {\n    return [\n      this.dropTriggerIfExists(\n        `${opType.toLowerCase()}_${table.namespace}_${\n          table.tablename\n        }_into_oplog`,\n        table\n      ),\n      ...this.createOplogTrigger(opType, table, newPKs, newRows, oldRows),\n    ]\n  }\n\n  /**\n   * Creates or replaces a trigger that logs insertions into the oplog.\n   */\n  createOrReplaceInsertTrigger = this.createOrReplaceOplogTrigger.bind(\n    this,\n    'INSERT'\n  )\n\n  /**\n   * Creates or replaces a trigger that logs updates into the oplog.\n   */\n  createOrReplaceUpdateTrigger = this.createOrReplaceOplogTrigger.bind(\n    this,\n    'UPDATE'\n  )\n\n  /**\n   * Creates or replaces a trigger that logs deletions into the oplog.\n   */\n  createOrReplaceDeleteTrigger = this.createOrReplaceOplogTrigger.bind(\n    this,\n    'DELETE'\n  )\n\n  /**\n   * Creates a trigger that logs compensations for operations into the oplog.\n   */\n  abstract createFkCompensationTrigger(\n    opType: 'INSERT' | 'UPDATE',\n    table: QualifiedTablename,\n    childKey: string,\n    fkTable: QualifiedTablename,\n    joinedFkPKs: string,\n    foreignKey: ForeignKey\n  ): string[]\n\n  createOrReplaceFkCompensationTrigger(\n    opType: 'INSERT' | 'UPDATE',\n    table: QualifiedTablename,\n    childKey: string,\n    fkTable: QualifiedTablename,\n    joinedFkPKs: string,\n    foreignKey: ForeignKey\n  ): string[] {\n    return [\n      this.dropTriggerIfExists(\n        `compensation_${opType.toLowerCase()}_${table.namespace}_${\n          table.tablename\n        }_${childKey}_into_oplog`,\n        table\n      ),\n      ...this.createFkCompensationTrigger(\n        opType,\n        table,\n        childKey,\n        fkTable,\n        joinedFkPKs,\n        foreignKey\n      ),\n    ]\n  }\n\n  /**\n   * Creates a trigger that logs compensations for insertions into the oplog.\n   */\n  createOrReplaceInsertCompensationTrigger =\n    this.createOrReplaceFkCompensationTrigger.bind(this, 'INSERT')\n\n  /**\n   * Creates a trigger that logs compensations for updates into the oplog.\n   */\n  createOrReplaceUpdateCompensationTrigger =\n    this.createOrReplaceFkCompensationTrigger.bind(this, 'UPDATE')\n\n  /**\n   * For each affected shadow row, set new tag array, unless the last oplog operation was a DELETE\n   */\n  abstract setTagsForShadowRows(\n    oplogTable: QualifiedTablename,\n    shadowTable: QualifiedTablename\n  ): string\n\n  /**\n   * Deletes any shadow rows where the last oplog operation was a `DELETE`\n   */\n  abstract removeDeletedShadowRows(\n    oplogTable: QualifiedTablename,\n    shadowTable: QualifiedTablename\n  ): string\n\n  /**\n   * Prepare multiple batched insert statements for an array of records.\n   *\n   * Since SQLite only supports a limited amount of positional `?` parameters,\n   * we generate multiple insert statements with each one being filled as much\n   * as possible from the given data. All statements are derived from same `baseSql` -\n   * the positional parameters will be appended to this string.\n   *\n   * @param baseSql base SQL string to which inserts should be appended\n   * @param columns columns that describe records\n   * @param records records to be inserted\n   * @param maxParameters max parameters this SQLite can accept - determines batching factor\n   * @param suffixSql optional SQL string to append to each insert statement\n   * @returns array of statements ready to be executed by the adapter\n   */\n  prepareInsertBatchedStatements(\n    baseSql: string,\n    columns: string[],\n    records: Record<string, SqlValue>[],\n    maxParameters: number,\n    suffixSql = ''\n  ): Statement[] {\n    const stmts: Statement[] = []\n    const columnCount = columns.length\n    const recordCount = records.length\n    // Amount of rows we can insert at once\n    const batchMaxSize = Math.floor(maxParameters / columnCount)\n\n    // keep a temporary join array for joining strings, to avoid\n    // the overhead of generating a new array every time\n    const tempColJoinArray = Array.from({ length: columnCount })\n\n    let processed = 0\n    let prevInsertCount = -1\n    let insertPattern = ''\n    while (processed < recordCount) {\n      const currentInsertCount = Math.min(recordCount - processed, batchMaxSize)\n\n      // cache insert pattern as it is going to be the same for every batch\n      // of `batchMaxSize` - ideally we can externalize this cache since for a\n      // given adapter this is _always_ going to be the same\n      if (currentInsertCount !== prevInsertCount) {\n        insertPattern = Array.from(\n          { length: currentInsertCount },\n          (_, recordIdx) => {\n            for (let i = 0; i < columnCount; i++) {\n              tempColJoinArray[i] = this.makePositionalParam(\n                recordIdx * columnCount + i + 1\n              )\n            }\n            return ` (${tempColJoinArray.join(', ')})`\n          }\n        ).join(',')\n      }\n\n      let sql = baseSql + insertPattern\n\n      if (suffixSql !== '') {\n        sql += ' ' + suffixSql\n      }\n\n      const args = []\n      for (let i = 0; i < currentInsertCount; i++) {\n        for (let j = 0; j < columnCount; j++) {\n          args.push(records[processed + i][columns[j]] as SqlValue)\n        }\n      }\n\n      processed += currentInsertCount\n      prevInsertCount = currentInsertCount\n      stmts.push({ sql, args })\n    }\n    return stmts\n  }\n\n  /**\n   * Prepare multiple batched DELETE statements for an array of records.\n   *\n   * Since SQLite only supports a limited amount of positional `?` parameters,\n   * we generate multiple delete statements with each one being filled as much\n   * as possible from the given data. This function only supports column equality checks\n   *\n   * @param baseSql base SQL string to which inserts should be appended\n   * @param columns columns that describe records\n   * @param records records to be inserted\n   * @param maxParameters max parameters this SQLite can accept - determines batching factor\n   * @param suffixSql optional SQL string to append to each insert statement\n   * @returns array of statements ready to be executed by the adapter\n   */\n  public prepareDeleteBatchedStatements<T extends object>(\n    baseSql: string,\n    columns: Array<keyof T>,\n    records: T[],\n    maxParameters: number,\n    suffixSql = ''\n  ): Statement[] {\n    const stmts: Statement[] = []\n    const columnCount = columns.length\n    const recordCount = records.length\n    // Amount of rows we can delete at once\n    const batchMaxSize = Math.floor(maxParameters / columnCount)\n\n    // keep a temporary join array for joining strings, to avoid\n    // the overhead of generating a new array every time\n    const tempColumnComparisonJoinArr = Array.from({ length: columnCount })\n\n    let processed = 0\n    let prevDeleteCount = -1\n    let deletePattern = ''\n    while (processed < recordCount) {\n      const currentDeleteCount = Math.min(recordCount - processed, batchMaxSize)\n\n      // cache delete pattern as it is going to be the same for every batch\n      // of `batchMaxSize` - ideally we can externalize this cache since for a\n      // given adapter this is _always_ going to be the same\n      if (currentDeleteCount !== prevDeleteCount) {\n        deletePattern = Array.from(\n          { length: currentDeleteCount },\n          (_, recordIdx) => {\n            for (let i = 0; i < columnCount; i++) {\n              tempColumnComparisonJoinArr[i] = `\"${\n                columns[i] as string\n              }\" = ${this.makePositionalParam(recordIdx * columnCount + i + 1)}`\n            }\n            return ` (${tempColumnComparisonJoinArr.join(' AND ')})`\n          }\n        ).join(' OR')\n      }\n      let sql = baseSql + deletePattern\n\n      if (suffixSql !== '') {\n        sql += ' ' + suffixSql\n      }\n\n      const args = []\n      for (let i = 0; i < currentDeleteCount; i++) {\n        for (let j = 0; j < columnCount; j++) {\n          args.push(records[processed + i][columns[j]] as SqlValue)\n        }\n      }\n\n      processed += currentDeleteCount\n      prevDeleteCount = currentDeleteCount\n      stmts.push({ sql, args })\n    }\n    return stmts\n  }\n\n  public makeQT(tablename: string): QualifiedTablename {\n    return new QualifiedTablename(this.defaultNamespace, tablename)\n  }\n}\n"],"mappings":"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","names":[]}