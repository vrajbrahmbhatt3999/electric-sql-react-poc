{"version":3,"sources":["../../../src/migrators/query-builder/sqliteBuilder.ts"],"sourcesContent":["import { dedent } from 'ts-dedent'\nimport { QualifiedTablename, SqlValue, Statement } from '../../util'\nimport { QueryBuilder } from './builder'\nimport { ForeignKey } from '../triggers'\n\nclass SqliteBuilder extends QueryBuilder {\n  readonly dialect = 'SQLite'\n  readonly AUTOINCREMENT_PK = 'INTEGER PRIMARY KEY AUTOINCREMENT'\n  readonly BLOB = 'BLOB'\n  readonly deferOrDisableFKsForTx = 'PRAGMA defer_foreign_keys = ON;'\n  readonly getVersion = 'SELECT sqlite_version() AS version'\n  readonly maxSqlParameters = 65535\n  readonly paramSign = '?'\n  readonly defaultNamespace = 'main'\n  readonly metaTables = [\n    'sqlite_schema',\n    'sqlite_sequence',\n    'sqlite_temp_schema',\n  ]\n\n  pgOnly(_query: string) {\n    return ''\n  }\n\n  pgOnlyQuery(_query: string) {\n    return []\n  }\n\n  sqliteOnly(query: string) {\n    return query\n  }\n\n  sqliteOnlyQuery(query: string) {\n    return [query]\n  }\n\n  tableExists(table: QualifiedTablename): Statement {\n    return {\n      sql: `SELECT 1 FROM sqlite_master WHERE type = 'table' AND name = ?`,\n      args: [table.tablename],\n    }\n  }\n\n  countTablesIn(tableNames: string[]): Statement {\n    const sql = dedent`\n      SELECT count(name) as \"count\" FROM sqlite_master\n        WHERE type='table'\n        AND name IN (${tableNames.map(() => '?').join(', ')})\n    `\n    return {\n      sql,\n      args: tableNames,\n    }\n  }\n\n  toHex(column: string): string {\n    return `hex(${column})`\n  }\n\n  hexValue(hexString: string): string {\n    return `x'${hexString}'`\n  }\n\n  getTableInfo(table: QualifiedTablename): Statement {\n    return {\n      sql: `SELECT name, type, \"notnull\", dflt_value, pk FROM pragma_table_info(?)`,\n      args: [table.tablename],\n    }\n  }\n\n  createIndex(\n    indexName: string,\n    onTable: QualifiedTablename,\n    columns: string[]\n  ) {\n    const namespace = onTable.namespace\n    const tablename = onTable.tablename\n    return `CREATE INDEX IF NOT EXISTS ${namespace}.${indexName} ON ${tablename} (${columns.join(\n      ', '\n    )})`\n  }\n\n  getLocalTableNames(notIn: string[] = []): Statement {\n    const ignore = this.metaTables.concat(notIn)\n    const tables = `\n      SELECT name FROM sqlite_master\n        WHERE type = 'table' AND\n              name NOT IN (${ignore.map(() => '?').join(',')})\n    `\n    return {\n      sql: tables,\n      args: ignore,\n    }\n  }\n\n  insertOrIgnore(\n    table: QualifiedTablename,\n    columns: string[],\n    values: SqlValue[]\n  ): Statement {\n    return {\n      sql: dedent`\n        INSERT OR IGNORE INTO ${table} (${columns.join(', ')})\n          VALUES (${columns.map(() => '?').join(', ')});\n      `,\n      args: values,\n    }\n  }\n\n  insertOrReplace(\n    table: QualifiedTablename,\n    columns: string[],\n    values: Array<SqlValue>,\n    _conflictCols: string[],\n    _updateCols: string[]\n  ): Statement {\n    return {\n      sql: dedent`\n        INSERT OR REPLACE INTO ${table} (${columns.join(', ')})\n        VALUES (${columns.map(() => '?').join(', ')})\n      `,\n      args: values,\n    }\n  }\n\n  insertOrReplaceWith(\n    table: QualifiedTablename,\n    columns: string[],\n    values: Array<SqlValue>,\n    conflictCols: string[],\n    updateCols: string[],\n    updateVals: SqlValue[]\n  ): Statement {\n    const { sql: baseSql, args } = this.insertOrReplace(\n      table,\n      columns,\n      values,\n      conflictCols,\n      updateCols\n    )\n    return {\n      sql:\n        baseSql +\n        ` ON CONFLICT DO UPDATE SET ${updateCols\n          .map((col) => `${col} = ?`)\n          .join(', ')}`,\n      args: args!.concat(updateVals),\n    }\n  }\n\n  batchedInsertOrReplace(\n    table: QualifiedTablename,\n    columns: string[],\n    records: Array<Record<string, SqlValue>>,\n    _conflictCols: string[],\n    _updateCols: string[],\n    maxSqlParameters: number\n  ): Statement[] {\n    const baseSql = `INSERT OR REPLACE INTO ${table} (${columns.join(\n      ', '\n    )}) VALUES `\n    return this.prepareInsertBatchedStatements(\n      baseSql,\n      columns,\n      records,\n      maxSqlParameters\n    )\n  }\n\n  dropTriggerIfExists(triggerName: string, _tablename: QualifiedTablename) {\n    return `DROP TRIGGER IF EXISTS ${triggerName};`\n  }\n\n  createNoFkUpdateTrigger(table: QualifiedTablename, pk: string[]): string[] {\n    const { namespace, tablename } = table\n    return [\n      dedent`\n        CREATE TRIGGER update_ensure_${namespace}_${tablename}_primarykey\n          BEFORE UPDATE ON ${table}\n        BEGIN\n          SELECT\n            CASE\n              ${pk\n                .map(\n                  (col) =>\n                    `WHEN old.\"${col}\" != new.\"${col}\" THEN\\n\\t\\tRAISE (ABORT, 'cannot change the value of column ${col} as it belongs to the primary key')`\n                )\n                .join('\\n')}\n            END;\n        END;\n      `,\n    ]\n  }\n\n  createJsonObject(rows: string) {\n    return `json_object(${rows})`\n  }\n\n  // removes null values from the JSON\n  // to be consistent with PG behaviour\n  removeSpaceAndNullValuesFromJson(json: string): string {\n    return `json_patch('{}', ${json})`\n  }\n\n  createPKJsonObject(rows: string) {\n    return this.removeSpaceAndNullValuesFromJson(this.createJsonObject(rows))\n  }\n\n  setTriggerSetting(table: QualifiedTablename, value: 0 | 1): string {\n    const { namespace, tablename } = table\n    return `INSERT OR IGNORE INTO _electric_trigger_settings (namespace, tablename, flag) VALUES ('${namespace}', '${tablename}', ${value});`\n  }\n\n  createOplogTrigger(\n    opType: 'INSERT' | 'UPDATE' | 'DELETE',\n    table: QualifiedTablename,\n    newPKs: string,\n    newRows: string,\n    oldRows: string\n  ): string[] {\n    const { namespace, tablename } = table\n    const opTypeLower = opType.toLowerCase()\n    const pk = this.createPKJsonObject(newPKs)\n    // Update has both the old and the new row\n    // Delete only has the old row\n    const newRecord =\n      opType === 'DELETE' ? 'NULL' : this.createJsonObject(newRows)\n    // Insert only has the new row\n    const oldRecord =\n      opType === 'INSERT' ? 'NULL' : this.createJsonObject(oldRows)\n\n    return [\n      dedent`\n        CREATE TRIGGER ${opTypeLower}_${namespace}_${tablename}_into_oplog\n           AFTER ${opType} ON ${table}\n           WHEN 1 = (SELECT flag from _electric_trigger_settings WHERE namespace = '${namespace}' AND tablename = '${tablename}')\n        BEGIN\n          INSERT INTO _electric_oplog (namespace, tablename, optype, primaryKey, newRow, oldRow, timestamp)\n          VALUES ('${namespace}', '${tablename}', '${opType}', ${pk}, ${newRecord}, ${oldRecord}, NULL);\n        END;\n      `,\n    ]\n  }\n\n  createFkCompensationTrigger(\n    opType: 'INSERT' | 'UPDATE',\n    table: QualifiedTablename,\n    childKey: string,\n    fkTable: QualifiedTablename,\n    joinedFkPKs: string,\n    foreignKey: ForeignKey\n  ): string[] {\n    const { namespace, tablename } = table\n    const { namespace: fkTableNamespace, tablename: fkTableName } = fkTable\n    const opTypeLower = opType.toLowerCase()\n    return [\n      dedent`\n        CREATE TRIGGER compensation_${opTypeLower}_${namespace}_${tablename}_${childKey}_into_oplog\n          AFTER ${opType} ON ${table}\n          WHEN 1 = (SELECT flag from _electric_trigger_settings WHERE namespace = '${namespace}' AND tablename = '${tablename}') AND\n               1 = (SELECT value from _electric_meta WHERE key = 'compensations')\n        BEGIN\n          INSERT INTO _electric_oplog (namespace, tablename, optype, primaryKey, newRow, oldRow, timestamp)\n          SELECT '${fkTableNamespace}', '${fkTableName}', 'COMPENSATION', ${this.createPKJsonObject(\n        joinedFkPKs\n      )}, json_object(${joinedFkPKs}), NULL, NULL\n          FROM ${fkTable} WHERE \"${foreignKey.parentKey}\" = new.\"${\n        foreignKey.childKey\n      }\";\n        END;\n      `,\n    ]\n  }\n\n  setTagsForShadowRows(\n    oplog: QualifiedTablename,\n    shadow: QualifiedTablename\n  ): string {\n    return dedent`\n      INSERT OR REPLACE INTO ${shadow} (namespace, tablename, primaryKey, tags)\n      SELECT namespace, tablename, primaryKey, ?\n        FROM ${oplog} AS op\n        WHERE timestamp = ?\n        GROUP BY namespace, tablename, primaryKey\n        HAVING rowid = max(rowid) AND optype != 'DELETE'\n    `\n  }\n\n  removeDeletedShadowRows(\n    oplog: QualifiedTablename,\n    shadow: QualifiedTablename\n  ): string {\n    // We do an inner join in a CTE instead of a `WHERE EXISTS (...)`\n    // since this is not reliant on re-executing a query\n    // for every row in the shadow table, but uses a PK join instead.\n    return dedent`\n      WITH _to_be_deleted (rowid) AS (\n        SELECT shadow.rowid\n          FROM ${oplog} AS op\n          INNER JOIN ${shadow} AS shadow\n            ON shadow.namespace = op.namespace AND shadow.tablename = op.tablename AND shadow.primaryKey = op.primaryKey\n          WHERE op.timestamp = ?\n          GROUP BY op.namespace, op.tablename, op.primaryKey\n          HAVING op.rowid = max(op.rowid) AND op.optype = 'DELETE'\n      )\n  \n      DELETE FROM ${shadow}\n      WHERE rowid IN _to_be_deleted\n    `\n  }\n\n  makePositionalParam(_i: number): string {\n    return this.paramSign\n  }\n}\n\nexport default new SqliteBuilder()\n"],"mappings":"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","names":[]}