{"version":3,"sources":["../../../src/migrators/query-builder/pgBuilder.ts"],"sourcesContent":["import { dedent } from 'ts-dedent'\nimport { QualifiedTablename, SqlValue, Statement } from '../../util'\nimport { QueryBuilder } from './builder'\nimport { ForeignKey } from '../triggers'\n\nconst quote = (col: string) => `\"${col}\"`\n\nclass PgBuilder extends QueryBuilder {\n  readonly dialect = 'Postgres'\n  readonly AUTOINCREMENT_PK = 'SERIAL PRIMARY KEY'\n  readonly BLOB = 'TEXT'\n  readonly getVersion = 'SELECT version();'\n  readonly paramSign = '$'\n  readonly defaultNamespace = 'public'\n\n  /** **Disables** FKs for the duration of the transaction */\n  readonly deferOrDisableFKsForTx =\n    'SET LOCAL session_replication_role = replica;'\n\n  pgOnly(query: string) {\n    return query\n  }\n\n  sqliteOnly(_query: string) {\n    return ''\n  }\n\n  tableExists(table: QualifiedTablename): Statement {\n    return {\n      sql: `SELECT 1 FROM information_schema.tables WHERE table_schema = $1 AND table_name = $2`,\n      args: [table.namespace, table.tablename],\n    }\n  }\n\n  countTablesIn(tableNames: string[]): Statement {\n    const sql = dedent`\n      SELECT COUNT(table_name)::integer AS \"count\"\n        FROM information_schema.tables\n          WHERE\n            table_type = 'BASE TABLE' AND\n            table_name IN (${tableNames.map((_, i) => `$${i + 1}`).join(', ')});\n    `\n    return {\n      sql,\n      args: tableNames,\n    }\n  }\n\n  toHex(column: string): string {\n    return `encode(${column}::bytea, 'hex')`\n  }\n\n  hexValue(hexString: string): string {\n    return `'\\\\x${hexString}'`\n  }\n\n  createIndex(\n    indexName: string,\n    onTable: QualifiedTablename,\n    columns: string[]\n  ) {\n    return `CREATE INDEX IF NOT EXISTS ${indexName} ON ${onTable} (${columns\n      .map(quote)\n      .join(', ')})`\n  }\n\n  getLocalTableNames(notIn: string[] = []): Statement {\n    let tables = dedent`\n      SELECT relname AS name\n      FROM pg_class\n      JOIN pg_namespace ON relnamespace = pg_namespace.oid\n      WHERE\n        relkind = 'r'\n        AND nspname <> 'pg_catalog'\n        AND nspname <> 'information_schema'\n    `\n    if (notIn.length > 0) {\n      tables += `\\n  AND relname NOT IN (${notIn\n        .map((_, i) => `$${i + 1}`)\n        .join(', ')})`\n    }\n    return {\n      sql: tables,\n      args: notIn,\n    }\n  }\n\n  getTableInfo(table: QualifiedTablename): Statement {\n    return {\n      sql: dedent`\n        SELECT\n          c.column_name AS name,\n          UPPER(c.data_type) AS type,\n          CASE\n            WHEN c.is_nullable = 'YES' THEN 0\n            ELSE 1\n          END AS notnull,\n          c.column_default AS dflt_value,\n          COALESCE(\n            (\n              -- Subquery to determine if the column is part of the primary key and \n              -- its position. We +1 to the position as we return 0 if the column \n              -- is not part of the primary key.\n              SELECT array_position(ind.indkey, att.attnum) + 1\n              FROM pg_class cl\n              JOIN pg_attribute att ON cl.oid = att.attrelid\n              JOIN pg_index ind ON cl.oid = ind.indrelid\n              JOIN pg_constraint con ON con.conindid = ind.indexrelid\n              WHERE cl.relname = c.table_name  -- Match the table name\n                AND att.attname = c.column_name  -- Match the column name\n                AND cl.relnamespace = (\n                  SELECT oid FROM pg_namespace WHERE nspname = c.table_schema\n                )  -- Match the schema\n                AND con.contype = 'p'  -- Only consider primary key constraints\n            ), \n            0  -- If the column is not part of the primary key, return 0\n        ) AS pk\n        FROM information_schema.columns AS c\n        WHERE\n          c.table_name = $1 AND\n          c.table_schema = $2;\n      `,\n      args: [table.tablename, table.namespace],\n    }\n  }\n\n  insertOrIgnore(\n    table: QualifiedTablename,\n    columns: string[],\n    values: SqlValue[]\n  ): Statement {\n    return {\n      sql: dedent`\n        INSERT INTO ${table} (${columns.map(quote).join(', ')})\n          VALUES (${columns.map((_, i) => `$${i + 1}`).join(', ')})\n          ON CONFLICT DO NOTHING;\n      `,\n      args: values,\n    }\n  }\n\n  insertOrReplace(\n    table: QualifiedTablename,\n    columns: string[],\n    values: Array<SqlValue>,\n    conflictCols: string[],\n    updateCols: string[]\n  ): Statement {\n    return {\n      sql: dedent`\n        INSERT INTO ${table} (${columns.map(quote).join(', ')})\n          VALUES (${columns.map((_, i) => `$${i + 1}`).join(', ')})\n        ON CONFLICT (${conflictCols.map(quote).join(', ')}) DO UPDATE\n          SET ${updateCols\n            .map((col) => `${quote(col)} = EXCLUDED.${quote(col)}`)\n            .join(', ')};\n      `,\n      args: values,\n    }\n  }\n\n  insertOrReplaceWith(\n    table: QualifiedTablename,\n    columns: string[],\n    values: Array<SqlValue>,\n    conflictCols: string[],\n    updateCols: string[],\n    updateVals: SqlValue[]\n  ): Statement {\n    return {\n      sql: dedent`\n        INSERT INTO ${table} (${columns.map(quote).join(', ')})\n          VALUES (${columns.map((_, i) => `$${i + 1}`).join(', ')})\n        ON CONFLICT (${conflictCols.map(quote).join(', ')}) DO UPDATE\n          SET ${updateCols\n            .map((col, i) => `${quote(col)} = $${columns.length + i + 1}`)\n            .join(', ')};\n      `,\n      args: values.concat(updateVals),\n    }\n  }\n\n  batchedInsertOrReplace(\n    table: QualifiedTablename,\n    columns: string[],\n    records: Array<Record<string, SqlValue>>,\n    conflictCols: string[],\n    updateCols: string[],\n    maxSqlParameters: number\n  ): Statement[] {\n    const baseSql = `INSERT INTO ${table} (${columns\n      .map(quote)\n      .join(', ')}) VALUES `\n    const statements = this.prepareInsertBatchedStatements(\n      baseSql,\n      columns,\n      records,\n      maxSqlParameters\n    )\n    return statements.map(({ sql, args }) => ({\n      sql: dedent`\n        ${sql}\n        ON CONFLICT (${conflictCols.map(quote).join(', ')}) DO UPDATE\n        SET ${updateCols\n          .map((col) => `${quote(col)} = EXCLUDED.${quote(col)}`)\n          .join(', ')};\n      `,\n      args,\n    }))\n  }\n\n  dropTriggerIfExists(triggerName: string, table: QualifiedTablename) {\n    return `DROP TRIGGER IF EXISTS ${triggerName} ON ${table};`\n  }\n\n  createNoFkUpdateTrigger(table: QualifiedTablename, pk: string[]): string[] {\n    const { namespace, tablename } = table\n    return [\n      dedent`\n        CREATE OR REPLACE FUNCTION update_ensure_${namespace}_${tablename}_primarykey_function()\n        RETURNS TRIGGER AS $$\n        BEGIN\n          ${pk\n            .map(\n              (col) =>\n                dedent`IF OLD.\"${col}\" IS DISTINCT FROM NEW.\"${col}\" THEN\n                  RAISE EXCEPTION 'Cannot change the value of column ${col} as it belongs to the primary key';\n                END IF;`\n            )\n            .join('\\n')}\n          RETURN NEW;\n        END;\n        $$ LANGUAGE plpgsql;\n      `,\n      dedent`\n      CREATE TRIGGER update_ensure_${namespace}_${tablename}_primarykey\n        BEFORE UPDATE ON ${table}\n          FOR EACH ROW\n            EXECUTE FUNCTION update_ensure_${namespace}_${tablename}_primarykey_function();\n      `,\n    ]\n  }\n\n  // This creates a JSON object that is equivalent\n  // to the JSON objects created by SQLite\n  // in that it does not re-order the keys\n  // and removes whitespaces between keys and values.\n  createPKJsonObject(rows: string) {\n    // `json_build_object` introduces whitespaces\n    // e.g. `{\"a\" : 5, \"b\" : 6}`\n    // But the json produced by SQLite is `{\"a\":5,\"b\":6}`.\n    // So this may lead to problems because we use this JSON string\n    // of the primary key to compare local and remote entries.\n    // But the changes for the same PK would be considered to be different PKs\n    // if e.g. the local change is PG and the remote change is SQLite.\n    // We use `json_strip_nulls` on the PK as it removes the whitespaces.\n    // It also removes `null` values from the PK. Therefore, it is important\n    // that the SQLite oplog triggers also remove `null` values from the PK.\n    return `json_strip_nulls(json_build_object(${rows}))`\n  }\n\n  createJsonbObject(rows: string) {\n    return `jsonb_build_object(${rows})`\n  }\n\n  // removes null values from the json object\n  // but most importantly also removes whitespaces introduced by `jsonb_build_object`\n  removeSpaceAndNullValuesFromJson(json: string): string {\n    return `json_strip_nulls(${json})`\n  }\n\n  setTriggerSetting(table: QualifiedTablename, value: 0 | 1): string {\n    const { namespace, tablename } = table\n    return dedent`\n      INSERT INTO \"${namespace}\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n        VALUES ('${namespace}', '${tablename}', ${value})\n        ON CONFLICT DO NOTHING;\n    `\n  }\n\n  createOplogTrigger(\n    opType: 'INSERT' | 'UPDATE' | 'DELETE',\n    table: QualifiedTablename,\n    newPKs: string,\n    newRows: string,\n    oldRows: string\n  ): string[] {\n    const { namespace, tablename } = table\n    const opTypeLower = opType.toLowerCase()\n    const pk = this.createPKJsonObject(newPKs)\n    // Update has both the old and the new row\n    // Delete only has the old row\n    const newRecord =\n      opType === 'DELETE' ? 'NULL' : this.createJsonbObject(newRows)\n    // Insert only has the new row\n    const oldRecord =\n      opType === 'INSERT' ? 'NULL' : this.createJsonbObject(oldRows)\n\n    return [\n      dedent`\n        CREATE OR REPLACE FUNCTION ${opTypeLower}_${namespace}_${tablename}_into_oplog_function()\n        RETURNS TRIGGER AS $$\n        BEGIN\n          DECLARE\n            flag_value INTEGER;\n          BEGIN\n            -- Get the flag value from _electric_trigger_settings\n            SELECT flag INTO flag_value FROM \"${namespace}\"._electric_trigger_settings WHERE namespace = '${namespace}' AND tablename = '${tablename}';\n    \n            IF flag_value = 1 THEN\n              -- Insert into _electric_oplog\n              INSERT INTO \"${namespace}\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n              VALUES (\n                '${namespace}',\n                '${tablename}',\n                '${opType}',\n                ${pk},\n                ${newRecord},\n                ${oldRecord},\n                NULL\n              );\n            END IF;\n    \n            RETURN NEW;\n          END;\n        END;\n        $$ LANGUAGE plpgsql;\n      `,\n      dedent`\n        CREATE TRIGGER ${opTypeLower}_${namespace}_${tablename}_into_oplog\n          AFTER ${opType} ON ${table}\n            FOR EACH ROW\n              EXECUTE FUNCTION ${opTypeLower}_${namespace}_${tablename}_into_oplog_function();\n      `,\n    ]\n  }\n\n  createFkCompensationTrigger(\n    opType: 'INSERT' | 'UPDATE',\n    table: QualifiedTablename,\n    childKey: string,\n    fkTable: QualifiedTablename,\n    joinedFkPKs: string,\n    foreignKey: ForeignKey\n  ): string[] {\n    const { namespace, tablename } = table\n    const { namespace: fkTableNamespace, tablename: fkTableName } = fkTable\n    const opTypeLower = opType.toLowerCase()\n\n    return [\n      dedent`\n        CREATE OR REPLACE FUNCTION compensation_${opTypeLower}_${namespace}_${tablename}_${childKey}_into_oplog_function()\n        RETURNS TRIGGER AS $$\n        BEGIN\n          DECLARE\n            flag_value INTEGER;\n            meta_value INTEGER;\n          BEGIN\n            SELECT flag INTO flag_value FROM \"${namespace}\"._electric_trigger_settings WHERE namespace = '${namespace}' AND tablename = '${tablename}';\n    \n            SELECT value INTO meta_value FROM \"${namespace}\"._electric_meta WHERE key = 'compensations';\n    \n            IF flag_value = 1 AND meta_value = 1 THEN\n              INSERT INTO \"${namespace}\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n              SELECT\n                '${fkTableNamespace}',\n                '${fkTableName}',\n                'COMPENSATION',\n                ${this.removeSpaceAndNullValuesFromJson(\n                  this.createPKJsonObject(joinedFkPKs)\n                )},\n                jsonb_build_object(${joinedFkPKs}),\n                NULL,\n                NULL\n              FROM ${fkTable}\n              WHERE \"${foreignKey.parentKey}\" = NEW.\"${foreignKey.childKey}\";\n            END IF;\n    \n            RETURN NEW;\n          END;\n        END;\n        $$ LANGUAGE plpgsql;\n        `,\n      dedent`\n          CREATE TRIGGER compensation_${opTypeLower}_${namespace}_${tablename}_${childKey}_into_oplog\n            AFTER ${opType} ON ${table}\n              FOR EACH ROW\n                EXECUTE FUNCTION compensation_${opTypeLower}_${namespace}_${tablename}_${childKey}_into_oplog_function();\n        `,\n    ]\n  }\n\n  setTagsForShadowRows(\n    oplog: QualifiedTablename,\n    shadow: QualifiedTablename\n  ): string {\n    return dedent`\n      INSERT INTO ${shadow} (namespace, tablename, \"primaryKey\", tags)\n        SELECT DISTINCT namespace, tablename, \"primaryKey\", $1\n          FROM ${oplog} AS op\n          WHERE\n            timestamp = $2\n            AND optype != 'DELETE'\n          ON CONFLICT (namespace, tablename, \"primaryKey\")\n        DO UPDATE SET tags = EXCLUDED.tags;\n    `\n  }\n\n  removeDeletedShadowRows(\n    oplog: QualifiedTablename,\n    shadow: QualifiedTablename\n  ): string {\n    // We do an inner join in a CTE instead of a `WHERE EXISTS (...)`\n    // since this is not reliant on re-executing a query\n    // for every row in the shadow table, but uses a PK join instead.\n    return dedent`\n      WITH \n        _relevant_shadows AS (\n          SELECT DISTINCT ON (s.rowid)\n            s.rowid AS rowid,\n            op.optype AS last_optype\n          FROM ${oplog} AS op\n          INNER JOIN ${shadow} AS s\n          ON s.namespace = op.namespace\n            AND s.tablename = op.tablename\n            AND s.\"primaryKey\"::jsonb = op.\"primaryKey\"::jsonb\n          WHERE op.timestamp = $1\n          ORDER BY s.rowid, op.rowid DESC\n        ),\n        _to_be_deleted AS (\n          SELECT rowid FROM _relevant_shadows WHERE last_optype = 'DELETE'\n        )\n      DELETE FROM ${shadow}\n      WHERE rowid IN (SELECT rowid FROM _to_be_deleted);\n    `\n  }\n\n  makePositionalParam(i: number): string {\n    return this.paramSign + i\n  }\n}\n\nexport default new PgBuilder()\n"],"mappings":"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","names":[]}