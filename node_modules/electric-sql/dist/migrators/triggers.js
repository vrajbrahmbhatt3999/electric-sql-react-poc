import { QualifiedTablename } from '../util/index.js';
function mkStatement(sql) {
  return { sql };
}
function generateOplogTriggers(table, builder) {
  const { qualifiedTableName, columns, primary, columnTypes } = table;
  const newPKs = joinColsForJSON(primary, columnTypes, builder, "new");
  const oldPKs = joinColsForJSON(primary, columnTypes, builder, "old");
  const newRows = joinColsForJSON(columns, columnTypes, builder, "new");
  const oldRows = joinColsForJSON(columns, columnTypes, builder, "old");
  const [dropFkTrigger, ...createFkTrigger] = builder.createOrReplaceNoFkUpdateTrigger(qualifiedTableName, primary);
  const [dropInsertTrigger, ...createInsertTrigger] = builder.createOrReplaceInsertTrigger(
    qualifiedTableName,
    newPKs,
    newRows,
    oldRows
  );
  return [
    // Toggles for turning the triggers on and off
    builder.setTriggerSetting(qualifiedTableName, 1),
    // Triggers for table ${tableName}
    // ensures primary key is immutable
    dropFkTrigger,
    ...createFkTrigger,
    // Triggers that add INSERT, UPDATE, DELETE operation to the _opslog table
    dropInsertTrigger,
    ...createInsertTrigger,
    ...builder.createOrReplaceUpdateTrigger(
      qualifiedTableName,
      newPKs,
      newRows,
      oldRows
    ),
    ...builder.createOrReplaceDeleteTrigger(
      qualifiedTableName,
      oldPKs,
      newRows,
      oldRows
    )
  ].map(mkStatement);
}
function generateCompensationTriggers(table, builder) {
  const { qualifiedTableName, foreignKeys, columnTypes } = table;
  const makeTriggers = (foreignKey) => {
    const { childKey } = foreignKey;
    const fkTableNamespace = builder.defaultNamespace;
    const fkTableName = foreignKey.table;
    const fkTablePK = foreignKey.parentKey;
    const qualifiedFkTable = new QualifiedTablename(
      fkTableNamespace,
      fkTableName
    );
    const joinedFkPKs = joinColsForJSON(
      [fkTablePK],
      {
        [fkTablePK]: columnTypes[foreignKey.childKey]
      },
      builder
    );
    const [dropInsertTrigger, ...createInsertTrigger] = builder.createOrReplaceInsertCompensationTrigger(
      qualifiedTableName,
      childKey,
      qualifiedFkTable,
      joinedFkPKs,
      foreignKey
    );
    return [
      // The compensation trigger inserts a row in `_electric_oplog` if the row pointed at by the FK exists
      // The way how this works is that the values for the row are passed to the nested SELECT
      // which will return those values for every record that matches the query
      // which can be at most once since we filter on the foreign key which is also the primary key and thus is unique.
      dropInsertTrigger,
      ...createInsertTrigger,
      ...builder.createOrReplaceUpdateCompensationTrigger(
        qualifiedTableName,
        foreignKey.childKey,
        qualifiedFkTable,
        joinedFkPKs,
        foreignKey
      )
    ].map(mkStatement);
  };
  const fkTriggers = foreignKeys.map((fk) => makeTriggers(fk));
  return fkTriggers.flat();
}
function generateTableTriggers(table, builder) {
  const oplogTriggers = generateOplogTriggers(table, builder);
  const fkTriggers = generateCompensationTriggers(table, builder);
  return oplogTriggers.concat(fkTriggers);
}
function generateTriggers(tables, builder) {
  const tableTriggers = [];
  tables.forEach((table) => {
    const triggers = generateTableTriggers(table, builder);
    tableTriggers.push(...triggers);
  });
  const stmts = [
    {
      sql: `DROP TABLE IF EXISTS "${builder.defaultNamespace}"._electric_trigger_settings;`
    },
    {
      sql: `CREATE TABLE "${builder.defaultNamespace}"._electric_trigger_settings(namespace TEXT, tablename TEXT, flag INTEGER, PRIMARY KEY(namespace, tablename));`
    },
    ...tableTriggers
  ];
  return stmts;
}
function joinColsForJSON(cols, colTypes, builder, target) {
  const transformIfNeeded = (col, targetedCol) => {
    const colType = colTypes[col];
    switch (colType) {
      case "FLOAT4":
      case "REAL":
      case "DOUBLE PRECISION":
      case "FLOAT8":
      case "INT8":
      case "BIGINT":
        return `cast(${targetedCol} as TEXT)`;
      case "BYTEA":
        return `CASE WHEN ${targetedCol} IS NOT NULL THEN ${builder.toHex(
          targetedCol
        )} ELSE NULL END`;
      default:
        return targetedCol;
    }
  };
  if (typeof target === "undefined") {
    return cols.sort().map((col) => `'${col}', ${transformIfNeeded(col, `"${col}"`)}`).join(", ");
  } else {
    return cols.sort().map((col) => `'${col}', ${transformIfNeeded(col, `${target}."${col}"`)}`).join(", ");
  }
}
export {
  generateOplogTriggers,
  generateTableTriggers,
  generateTriggers
};
//# sourceMappingURL=triggers.js.map