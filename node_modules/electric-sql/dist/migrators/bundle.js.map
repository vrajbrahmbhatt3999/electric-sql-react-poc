{"version":3,"sources":["../../src/migrators/bundle.ts"],"sourcesContent":["import {\n  makeStmtMigration,\n  Migration,\n  MigrationRecord,\n  Migrator,\n  StmtMigration,\n} from './index'\nimport { DatabaseAdapter } from '../electric/adapter'\nimport { buildInitialMigration as makeBaseMigration } from './schema'\nimport Log from 'loglevel'\nimport { QualifiedTablename, SatelliteError, SatelliteErrorCode } from '../util'\nimport { _electric_migrations } from '../satellite/config'\nimport { pgBuilder, QueryBuilder, sqliteBuilder } from './query-builder'\nimport { dedent } from 'ts-dedent'\nimport { runInTransaction } from '../util/transactions'\nimport { ForeignKeyChecks } from '../config'\n\nexport const SCHEMA_VSN_ERROR_MSG = `Local schema doesn't match server's. Clear local state through developer tools and retry connection manually. If error persists, re-generate the client. Check documentation (https://electric-sql.com/docs/reference/roadmap) to learn more.`\n\nconst VALID_VERSION_EXP = new RegExp('^[0-9_]+')\n\nexport abstract class BundleMigratorBase implements Migrator {\n  adapter: DatabaseAdapter\n  migrations: StmtMigration[]\n\n  readonly tableName = _electric_migrations\n  readonly migrationsTable: QualifiedTablename\n\n  constructor(\n    adapter: DatabaseAdapter,\n    migrations: Migration[] = [],\n    public queryBuilder: QueryBuilder,\n    private namespace: string = queryBuilder.defaultNamespace\n  ) {\n    this.adapter = adapter\n    const baseMigration = makeBaseMigration(queryBuilder)\n    this.migrations = [...baseMigration.migrations, ...migrations].map(\n      makeStmtMigration\n    )\n    this.migrationsTable = new QualifiedTablename(\n      this.namespace,\n      this.tableName\n    )\n  }\n\n  async up(): Promise<number> {\n    const existing = await this.queryApplied()\n    const unapplied = await this.validateApplied(this.migrations, existing)\n\n    let migration: StmtMigration\n    for (let i = 0; i < unapplied.length; i++) {\n      migration = unapplied[i]\n      Log.info(`applying migration: ${migration.version}`)\n      await this.apply(migration)\n    }\n\n    return unapplied.length\n  }\n\n  async migrationsTableExists(): Promise<boolean> {\n    // If this is the first time we're running migrations, then the\n    // migrations table won't exist.\n    const tableExists = this.queryBuilder.tableExists(this.migrationsTable)\n    const tables = await this.adapter.query(tableExists)\n    return tables.length > 0\n  }\n\n  async queryApplied(): Promise<MigrationRecord[]> {\n    if (!(await this.migrationsTableExists())) {\n      return []\n    }\n\n    const existingRecords = `\n      SELECT version FROM ${this.migrationsTable}\n        ORDER BY id ASC\n    `\n\n    const rows = await this.adapter.query({ sql: existingRecords })\n    return rows as unknown as MigrationRecord[]\n  }\n\n  // Returns the version of the most recently applied migration\n  async querySchemaVersion(): Promise<string | undefined> {\n    if (!(await this.migrationsTableExists())) {\n      return\n    }\n\n    // The hard-coded version '0' below corresponds to the version of the internal migration defined in `schema.ts`.\n    // We're ignoring it because this function is supposed to return the application schema version.\n    const schemaVersion = `\n      SELECT version FROM ${this.migrationsTable}\n        WHERE version != '0'\n        ORDER BY version DESC\n        LIMIT 1\n    `\n    const rows = await this.adapter.query({ sql: schemaVersion })\n    if (rows.length === 0) {\n      return\n    }\n\n    return (rows[0] as MigrationRecord).version\n  }\n\n  async validateApplied(\n    migrations: StmtMigration[],\n    existing: MigrationRecord[]\n  ) {\n    // `existing` migrations may contain migrations\n    // received at runtime that are not bundled in the app\n    // i.e. those are not present in `migrations`\n    // Thus, `existing` may be longer than `migrations`.\n    // So we should only compare a prefix of `existing`\n    // that has the same length as `migrations`\n\n    // take a slice of `existing` migrations\n    // that will be checked against `migrations`\n    const existingPrefix = existing.slice(0, migrations.length)\n\n    // We validate that the existing records are the first migrations.\n    existingPrefix.forEach(({ version }, i) => {\n      const migration = migrations[i]\n\n      if (migration.version !== version) {\n        throw new SatelliteError(\n          SatelliteErrorCode.UNKNOWN_SCHEMA_VSN,\n          SCHEMA_VSN_ERROR_MSG\n        )\n      }\n    })\n\n    // Then we can confidently slice and return the non-existing.\n    return migrations.slice(existingPrefix.length)\n  }\n\n  async apply(\n    { statements, version }: StmtMigration,\n    fkChecks: ForeignKeyChecks = ForeignKeyChecks.inherit\n  ): Promise<void> {\n    if (!VALID_VERSION_EXP.test(version)) {\n      throw new Error(\n        `Invalid migration version, must match ${VALID_VERSION_EXP}`\n      )\n    }\n\n    await runInTransaction(this.adapter, fkChecks, ...statements, {\n      sql: dedent`\n        INSERT INTO ${this.migrationsTable} (version, applied_at)\n        VALUES (${this.queryBuilder.makePositionalParam(\n          1\n        )}, ${this.queryBuilder.makePositionalParam(2)});\n      `,\n      args: [version, Date.now().toString()],\n    })\n  }\n\n  /**\n   * Applies the provided migration only if it has not yet been applied.\n   * @param migration The migration to apply.\n   * @returns A promise that resolves to a boolean\n   *          that indicates if the migration was applied.\n   */\n  async applyIfNotAlready(\n    migration: StmtMigration,\n    fkChecks: ForeignKeyChecks = ForeignKeyChecks.inherit\n  ): Promise<boolean> {\n    const rows = await this.adapter.query({\n      sql: dedent`\n        SELECT 1 FROM ${this.migrationsTable}\n          WHERE version = ${this.queryBuilder.makePositionalParam(1)}\n      `,\n      args: [migration.version],\n    })\n\n    const shouldApply = rows.length === 0\n\n    if (shouldApply) {\n      // This is a new migration because its version number\n      // is not in our migrations table.\n      await this.apply(migration, fkChecks)\n    }\n\n    return shouldApply\n  }\n}\n\nexport class SqliteBundleMigrator extends BundleMigratorBase {\n  constructor(adapter: DatabaseAdapter, migrations: Migration[] = []) {\n    super(adapter, migrations, sqliteBuilder)\n  }\n}\n\nexport class PgBundleMigrator extends BundleMigratorBase {\n  constructor(adapter: DatabaseAdapter, migrations: Migration[] = []) {\n    super(adapter, migrations, pgBuilder)\n  }\n}\n"],"mappings":"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","names":[]}