import {
  makeStmtMigration
} from './index.js';
import { buildInitialMigration as makeBaseMigration } from './schema.js';
import Log from "loglevel";
import { QualifiedTablename, SatelliteError, SatelliteErrorCode } from '../util/index.js';
import { _electric_migrations } from '../satellite/config.js';
import { pgBuilder, sqliteBuilder } from './query-builder/index.js';
import { dedent } from "ts-dedent";
import { runInTransaction } from '../util/transactions.js';
import { ForeignKeyChecks } from '../config/index.js';
const SCHEMA_VSN_ERROR_MSG = `Local schema doesn't match server's. Clear local state through developer tools and retry connection manually. If error persists, re-generate the client. Check documentation (https://electric-sql.com/docs/reference/roadmap) to learn more.`;
const VALID_VERSION_EXP = new RegExp("^[0-9_]+");
class BundleMigratorBase {
  constructor(adapter, migrations = [], queryBuilder, namespace = queryBuilder.defaultNamespace) {
    this.queryBuilder = queryBuilder;
    this.namespace = namespace;
    this.adapter = adapter;
    const baseMigration = makeBaseMigration(queryBuilder);
    this.migrations = [...baseMigration.migrations, ...migrations].map(
      makeStmtMigration
    );
    this.migrationsTable = new QualifiedTablename(
      this.namespace,
      this.tableName
    );
  }
  adapter;
  migrations;
  tableName = _electric_migrations;
  migrationsTable;
  async up() {
    const existing = await this.queryApplied();
    const unapplied = await this.validateApplied(this.migrations, existing);
    let migration;
    for (let i = 0; i < unapplied.length; i++) {
      migration = unapplied[i];
      Log.info(`applying migration: ${migration.version}`);
      await this.apply(migration);
    }
    return unapplied.length;
  }
  async migrationsTableExists() {
    const tableExists = this.queryBuilder.tableExists(this.migrationsTable);
    const tables = await this.adapter.query(tableExists);
    return tables.length > 0;
  }
  async queryApplied() {
    if (!await this.migrationsTableExists()) {
      return [];
    }
    const existingRecords = `
      SELECT version FROM ${this.migrationsTable}
        ORDER BY id ASC
    `;
    const rows = await this.adapter.query({ sql: existingRecords });
    return rows;
  }
  // Returns the version of the most recently applied migration
  async querySchemaVersion() {
    if (!await this.migrationsTableExists()) {
      return;
    }
    const schemaVersion = `
      SELECT version FROM ${this.migrationsTable}
        WHERE version != '0'
        ORDER BY version DESC
        LIMIT 1
    `;
    const rows = await this.adapter.query({ sql: schemaVersion });
    if (rows.length === 0) {
      return;
    }
    return rows[0].version;
  }
  async validateApplied(migrations, existing) {
    const existingPrefix = existing.slice(0, migrations.length);
    existingPrefix.forEach(({ version }, i) => {
      const migration = migrations[i];
      if (migration.version !== version) {
        throw new SatelliteError(
          SatelliteErrorCode.UNKNOWN_SCHEMA_VSN,
          SCHEMA_VSN_ERROR_MSG
        );
      }
    });
    return migrations.slice(existingPrefix.length);
  }
  async apply({ statements, version }, fkChecks = ForeignKeyChecks.inherit) {
    if (!VALID_VERSION_EXP.test(version)) {
      throw new Error(
        `Invalid migration version, must match ${VALID_VERSION_EXP}`
      );
    }
    await runInTransaction(this.adapter, fkChecks, ...statements, {
      sql: dedent`
        INSERT INTO ${this.migrationsTable} (version, applied_at)
        VALUES (${this.queryBuilder.makePositionalParam(
        1
      )}, ${this.queryBuilder.makePositionalParam(2)});
      `,
      args: [version, Date.now().toString()]
    });
  }
  /**
   * Applies the provided migration only if it has not yet been applied.
   * @param migration The migration to apply.
   * @returns A promise that resolves to a boolean
   *          that indicates if the migration was applied.
   */
  async applyIfNotAlready(migration, fkChecks = ForeignKeyChecks.inherit) {
    const rows = await this.adapter.query({
      sql: dedent`
        SELECT 1 FROM ${this.migrationsTable}
          WHERE version = ${this.queryBuilder.makePositionalParam(1)}
      `,
      args: [migration.version]
    });
    const shouldApply = rows.length === 0;
    if (shouldApply) {
      await this.apply(migration, fkChecks);
    }
    return shouldApply;
  }
}
class SqliteBundleMigrator extends BundleMigratorBase {
  constructor(adapter, migrations = []) {
    super(adapter, migrations, sqliteBuilder);
  }
}
class PgBundleMigrator extends BundleMigratorBase {
  constructor(adapter, migrations = []) {
    super(adapter, migrations, pgBuilder);
  }
}
export {
  BundleMigratorBase,
  PgBundleMigrator,
  SCHEMA_VSN_ERROR_MSG,
  SqliteBundleMigrator
};
//# sourceMappingURL=bundle.js.map