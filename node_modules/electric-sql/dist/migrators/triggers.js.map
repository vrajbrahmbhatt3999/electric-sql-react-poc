{"version":3,"sources":["../../src/migrators/triggers.ts"],"sourcesContent":["import { QualifiedTablename, Statement } from '../util'\nimport { QueryBuilder } from './query-builder'\n\nexport type ForeignKey = {\n  table: string\n  childKey: string\n  parentKey: string\n}\n\ntype ColumnName = string\ntype ColumnType = string\ntype ColumnTypes = Record<ColumnName, ColumnType>\n\nexport type Table = {\n  qualifiedTableName: QualifiedTablename\n  columns: ColumnName[]\n  primary: ColumnName[]\n  foreignKeys: ForeignKey[]\n  columnTypes: ColumnTypes\n}\n\ntype TableFullName = string\ntype Tables = Map<TableFullName, Table>\n\nfunction mkStatement(sql: string): Statement {\n  return { sql }\n}\n\n/**\n * Generates the triggers Satellite needs for the given table.\n * Assumes that the necessary meta tables already exist.\n * @param table - A new or existing table for which to create/update the triggers.\n * @returns An array of SQLite statements that add the necessary oplog triggers.\n *\n * @remarks\n * We return an array of SQL statements because the DB drivers\n * do not accept queries containing more than one SQL statement.\n */\nexport function generateOplogTriggers(\n  table: Omit<Table, 'foreignKeys'>,\n  builder: QueryBuilder\n): Statement[] {\n  const { qualifiedTableName, columns, primary, columnTypes } = table\n\n  const newPKs = joinColsForJSON(primary, columnTypes, builder, 'new')\n  const oldPKs = joinColsForJSON(primary, columnTypes, builder, 'old')\n  const newRows = joinColsForJSON(columns, columnTypes, builder, 'new')\n  const oldRows = joinColsForJSON(columns, columnTypes, builder, 'old')\n\n  const [dropFkTrigger, ...createFkTrigger] =\n    builder.createOrReplaceNoFkUpdateTrigger(qualifiedTableName, primary)\n  const [dropInsertTrigger, ...createInsertTrigger] =\n    builder.createOrReplaceInsertTrigger(\n      qualifiedTableName,\n      newPKs,\n      newRows,\n      oldRows\n    )\n\n  return [\n    // Toggles for turning the triggers on and off\n    builder.setTriggerSetting(qualifiedTableName, 1),\n    // Triggers for table ${tableName}\n    // ensures primary key is immutable\n    dropFkTrigger,\n    ...createFkTrigger,\n    // Triggers that add INSERT, UPDATE, DELETE operation to the _opslog table\n    dropInsertTrigger,\n    ...createInsertTrigger,\n    ...builder.createOrReplaceUpdateTrigger(\n      qualifiedTableName,\n      newPKs,\n      newRows,\n      oldRows\n    ),\n    ...builder.createOrReplaceDeleteTrigger(\n      qualifiedTableName,\n      oldPKs,\n      newRows,\n      oldRows\n    ),\n  ].map(mkStatement)\n}\n\n/**\n * Generates triggers for compensations for all foreign keys in the provided table.\n *\n * Compensation is recorded as a SatOpCompensation messaage. The entire reason\n * for it existing is to maybe revive the row if it has been deleted, so we need\n * correct tags.\n *\n * The compensation update contains _just_ the primary keys, no other columns are present.\n *\n * @param tableFullName Full name of the table.\n * @param table The corresponding table.\n * @param tables Map of all tables (needed to look up the tables that are pointed at by FKs).\n * @returns An array of SQLite statements that add the necessary compensation triggers.\n */\nfunction generateCompensationTriggers(\n  table: Table,\n  builder: QueryBuilder\n): Statement[] {\n  const { qualifiedTableName, foreignKeys, columnTypes } = table\n\n  const makeTriggers = (foreignKey: ForeignKey) => {\n    const { childKey } = foreignKey\n\n    const fkTableNamespace = builder.defaultNamespace // currently, Electric always uses the DB's default namespace\n    const fkTableName = foreignKey.table\n    const fkTablePK = foreignKey.parentKey // primary key of the table pointed at by the FK.\n    const qualifiedFkTable = new QualifiedTablename(\n      fkTableNamespace,\n      fkTableName\n    )\n\n    // This table's `childKey` points to the parent's table `parentKey`.\n    // `joinColsForJSON` looks up the type of the `parentKey` column in the provided `colTypes` object.\n    // However, `columnTypes` contains the types of the columns of this table\n    // so we need to pass an object containing the column type of the parent key.\n    // We can construct that object because the type of the parent key must be the same\n    // as the type of the child key that is pointing to it.\n    const joinedFkPKs = joinColsForJSON(\n      [fkTablePK],\n      {\n        [fkTablePK]: columnTypes[foreignKey.childKey],\n      },\n      builder\n    )\n\n    const [dropInsertTrigger, ...createInsertTrigger] =\n      builder.createOrReplaceInsertCompensationTrigger(\n        qualifiedTableName,\n        childKey,\n        qualifiedFkTable,\n        joinedFkPKs,\n        foreignKey\n      )\n\n    return [\n      // The compensation trigger inserts a row in `_electric_oplog` if the row pointed at by the FK exists\n      // The way how this works is that the values for the row are passed to the nested SELECT\n      // which will return those values for every record that matches the query\n      // which can be at most once since we filter on the foreign key which is also the primary key and thus is unique.\n      dropInsertTrigger,\n      ...createInsertTrigger,\n      ...builder.createOrReplaceUpdateCompensationTrigger(\n        qualifiedTableName,\n        foreignKey.childKey,\n        qualifiedFkTable,\n        joinedFkPKs,\n        foreignKey\n      ),\n    ].map(mkStatement)\n  }\n  const fkTriggers = foreignKeys.map((fk) => makeTriggers(fk))\n\n  return fkTriggers.flat()\n}\n\n/**\n * Generates the oplog triggers and compensation triggers for the provided table.\n * @param tableFullName - Full name of the table for which to create the triggers.\n * @param tables - Dictionary mapping full table names to the corresponding tables.\n * @returns An array of SQLite statements that add the necessary oplog and compensation triggers.\n */\nexport function generateTableTriggers(\n  table: Table,\n  builder: QueryBuilder\n): Statement[] {\n  const oplogTriggers = generateOplogTriggers(table, builder)\n  const fkTriggers = generateCompensationTriggers(table, builder)\n  return oplogTriggers.concat(fkTriggers)\n}\n\n/**\n * Generates triggers for all the provided tables.\n * @param tables - Dictionary mapping full table names to the corresponding tables.\n * @returns An array of SQLite statements that add the necessary oplog and compensation triggers for all tables.\n */\nexport function generateTriggers(\n  tables: Tables,\n  builder: QueryBuilder\n): Statement[] {\n  const tableTriggers: Statement[] = []\n  tables.forEach((table) => {\n    const triggers = generateTableTriggers(table, builder)\n    tableTriggers.push(...triggers)\n  })\n\n  const stmts = [\n    {\n      sql: `DROP TABLE IF EXISTS \"${builder.defaultNamespace}\"._electric_trigger_settings;`,\n    },\n    {\n      sql: `CREATE TABLE \"${builder.defaultNamespace}\"._electric_trigger_settings(namespace TEXT, tablename TEXT, flag INTEGER, PRIMARY KEY(namespace, tablename));`,\n    },\n    ...tableTriggers,\n  ]\n\n  return stmts\n}\n\n/**\n * Joins the column names and values into a string of pairs of the form `'col1', val1, 'col2', val2, ...`\n * that can be used to build a JSON object in a SQLite `json_object` function call.\n * Values of type REAL are cast to text to avoid a bug in SQLite's `json_object` function (see below).\n * Similarly, values of type INT8 (i.e. BigInts) are cast to text because JSON does not support BigInts.\n * All BLOB or BYTEA bytestrings are also encoded as hex strings to make them part of a JSON\n *\n * NOTE: There is a bug with SQLite's `json_object` function up to version 3.41.2\n *       that causes it to return an invalid JSON object if some value is +Infinity or -Infinity.\n * @example\n * sqlite> SELECT json_object('a',2e370,'b',-3e380);\n * {\"a\":Inf,\"b\":-Inf}\n *\n * The returned JSON is not valid because JSON does not support `Inf` nor `-Inf`.\n * @example\n * sqlite> SELECT json_valid((SELECT json_object('a',2e370,'b',-3e380)));\n * 0\n *\n * This is fixed in version 3.42.0 and on:\n * @example\n * sqlite> SELECT json_object('a',2e370,'b',-3e380);\n * {\"a\":9e999,\"b\":-9e999}\n *\n * The returned JSON now is valid, the numbers 9e999 and -9e999\n * are out of range of floating points and thus will be converted\n * to `Infinity` and `-Infinity` when parsed with `JSON.parse`.\n *\n * Nevertheless version SQLite version 3.42.0 is very recent (May 2023)\n * and users may be running older versions so we want to support them.\n * Therefore we introduce the following workaround:\n * @example\n * sqlite> SELECT json_object('a', cast(2e370 as TEXT),'b', cast(-3e380 as TEXT));\n * {\"a\":\"Inf\",\"b\":\"-Inf\"}\n *\n * By casting the values to TEXT, infinity values are turned into their string representation.\n * As such, the resulting JSON is valid.\n * This means that the values will be stored as strings in the oplog,\n * thus, we must be careful when parsing the oplog to convert those values back to their numeric type.\n *\n * For reference:\n * - https://discord.com/channels/933657521581858818/1163829658236760185\n * - https://www.sqlite.org/src/info/b52081d0acd07dc5bdb4951a3e8419866131965260c1e3a4c9b6e673bfe3dfea\n *\n * @param cols The column names\n * @param target The target to use for the column values (new or old value provided by the trigger).\n */\nfunction joinColsForJSON(\n  cols: string[],\n  colTypes: ColumnTypes,\n  builder: QueryBuilder,\n  target?: 'new' | 'old'\n) {\n  // Perform transformations on some columns to ensure consistent\n  // serializability into JSON\n  const transformIfNeeded = (col: string, targetedCol: string) => {\n    const colType = colTypes[col]\n\n    switch (colType) {\n      case 'FLOAT4':\n      case 'REAL':\n      case 'DOUBLE PRECISION':\n      case 'FLOAT8':\n      case 'INT8':\n      case 'BIGINT':\n        // cast REALs, INT8s, BIGINTs to TEXT to work around SQLite's `json_object` bug\n        return `cast(${targetedCol} as TEXT)`\n\n      case 'BYTEA':\n        // transform blobs/bytestrings into hexadecimal strings for JSON encoding\n        return `CASE WHEN ${targetedCol} IS NOT NULL THEN ${builder.toHex(\n          targetedCol\n        )} ELSE NULL END`\n\n      default:\n        return targetedCol\n    }\n  }\n\n  if (typeof target === 'undefined') {\n    return cols\n      .sort()\n      .map((col) => `'${col}', ${transformIfNeeded(col, `\"${col}\"`)}`)\n      .join(', ')\n  } else {\n    return cols\n      .sort()\n      .map((col) => `'${col}', ${transformIfNeeded(col, `${target}.\"${col}\"`)}`)\n      .join(', ')\n  }\n}\n"],"mappings":"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","names":[]}