{"version":3,"sources":["../../src/util/tab.ts"],"sourcesContent":["import { genUUID } from './random'\n\ninterface Storage {\n  getItem: (key: string) => any\n  setItem: (key: string, value: string) => void\n}\n\ninterface NavEntry {\n  [key: string]: any\n}\n\ninterface Options {\n  key?: string\n  navEntries?: NavEntry[]\n  storage?: Storage\n}\n\ninterface ReturnValue {\n  tabId: string\n  hasExisting: boolean\n  usingExisting: boolean\n  mayBeDuplicate?: boolean\n}\n\n// Default sessionStorage key to store the tab ID in.\nconst defaultKey = 'electric-sql.utils.tab:id'\n\n// Used for in-memory storage when `sessionStorage` is not supported.\nlet tabId: string | null = null\n\n/**\n * Returns a unique ID for each browser tab. This can be used to construct a\n * tab scoped DB name. This allows data to sync between tabs by using one\n * named SQLite database file per tab. This is sub-optimal compared with\n * sharing a database but avoids concurrent database access.\n *\n * Handles duplicate tabs with some potential for false positives.\n * False positives result in a new tabID which means a new database name\n * and thus additional data transfer and storage.\n *\n * Uses window.sessionStorage. Some browsers disable access to sessionStorage\n * even when saying its available (e.g.: as a result of disabling third party\n * cookies o_O). So we handle this by falling back to an in-memory tabId\n * singleton -- which means each page load syncs data into a new DB.\n *\n * Other platforms can pass in a storage implementation or default to the\n * in-memory tabId singleton.\n */\nexport const uniqueTabId = (opts: Options = {}): ReturnValue => {\n  const key = opts.key ?? defaultKey\n\n  // Use sessionStorage as the default storage if available.\n  let storage: Storage\n  if (opts.storage !== undefined) {\n    storage = opts.storage\n  } else {\n    try {\n      storage = window.sessionStorage\n    } catch {\n      // We catch errors in the Storage use (we have to to handle\n      // browser security where they pretend Storage is available\n      // but then throw errors when you use it) so this cast isn't\n      // as bad as it looks.\n      storage = {} as Storage\n    }\n  }\n\n  let navEntries: NavEntry[]\n  if (opts.navEntries !== undefined) {\n    navEntries = opts.navEntries\n  } else {\n    try {\n      navEntries = window.performance.getEntriesByType('navigation')\n    } catch {\n      navEntries = []\n    }\n  }\n\n  // Lookup the tabId\n  let existingTabId: string | null\n  let usedSessionStorage: boolean\n  try {\n    existingTabId = storage.getItem(key)\n    usedSessionStorage = true\n  } catch {\n    existingTabId = tabId\n    usedSessionStorage = false\n  }\n  const hasExisting = existingTabId !== null\n\n  // If we got the tab ID from memory then always use it.\n  if (hasExisting && !usedSessionStorage) {\n    return {\n      tabId: existingTabId as string,\n      hasExisting: true,\n      usingExisting: true,\n    }\n  }\n\n  // If it's not a duplicate tab then use it.\n  //\n  // Note that only the current document is included in the [performance timeline][1],\n  // so there is only one PerformanceNavigationTiming object in the navEntries array.\n  //\n  // [1]: https://developer.mozilla.org/en-US/docs/Web/API/PerformanceNavigationTiming\n  const navEntry =\n    navEntries && navEntries.length ? navEntries[0] : { type: null }\n  const mayBeDuplicate = navEntry.type === 'back_forward'\n\n  if (hasExisting && !mayBeDuplicate) {\n    return {\n      tabId: existingTabId as string,\n      hasExisting: true,\n      usingExisting: true,\n      mayBeDuplicate: false,\n    }\n  }\n\n  // Otherwise generate, store and return a new one.\n  const newTabId = genUUID()\n  try {\n    storage.setItem(key, newTabId)\n  } catch {\n    tabId = newTabId\n  }\n\n  return {\n    tabId: newTabId,\n    hasExisting: hasExisting,\n    usingExisting: false,\n    mayBeDuplicate: mayBeDuplicate,\n  }\n}\n"],"mappings":"AAAA,SAAS,eAAe;AAyBxB,MAAM,aAAa;AAGnB,IAAI,QAAuB;AAoBpB,MAAM,cAAc,CAAC,OAAgB,CAAC,MAAmB;AAC9D,QAAM,MAAM,KAAK,OAAO;AAGxB,MAAI;AACJ,MAAI,KAAK,YAAY,QAAW;AAC9B,cAAU,KAAK;AAAA,EACjB,OAAO;AACL,QAAI;AACF,gBAAU,OAAO;AAAA,IACnB,QAAQ;AAKN,gBAAU,CAAC;AAAA,IACb;AAAA,EACF;AAEA,MAAI;AACJ,MAAI,KAAK,eAAe,QAAW;AACjC,iBAAa,KAAK;AAAA,EACpB,OAAO;AACL,QAAI;AACF,mBAAa,OAAO,YAAY,iBAAiB,YAAY;AAAA,IAC/D,QAAQ;AACN,mBAAa,CAAC;AAAA,IAChB;AAAA,EACF;AAGA,MAAI;AACJ,MAAI;AACJ,MAAI;AACF,oBAAgB,QAAQ,QAAQ,GAAG;AACnC,yBAAqB;AAAA,EACvB,QAAQ;AACN,oBAAgB;AAChB,yBAAqB;AAAA,EACvB;AACA,QAAM,cAAc,kBAAkB;AAGtC,MAAI,eAAe,CAAC,oBAAoB;AACtC,WAAO;AAAA,MACL,OAAO;AAAA,MACP,aAAa;AAAA,MACb,eAAe;AAAA,IACjB;AAAA,EACF;AAQA,QAAM,WACJ,cAAc,WAAW,SAAS,WAAW,CAAC,IAAI,EAAE,MAAM,KAAK;AACjE,QAAM,iBAAiB,SAAS,SAAS;AAEzC,MAAI,eAAe,CAAC,gBAAgB;AAClC,WAAO;AAAA,MACL,OAAO;AAAA,MACP,aAAa;AAAA,MACb,eAAe;AAAA,MACf,gBAAgB;AAAA,IAClB;AAAA,EACF;AAGA,QAAM,WAAW,QAAQ;AACzB,MAAI;AACF,YAAQ,QAAQ,KAAK,QAAQ;AAAA,EAC/B,QAAQ;AACN,YAAQ;AAAA,EACV;AAEA,SAAO;AAAA,IACL,OAAO;AAAA,IACP;AAAA,IACA,eAAe;AAAA,IACf;AAAA,EACF;AACF;","names":[]}