{"version":3,"sources":["../../src/util/types.ts"],"sourcesContent":["import type Long from 'long'\nimport {\n  SatOpMigrate_Column,\n  SatOpMigrate_PgColumnType,\n  SatOpMigrate_Table,\n  SatOpMigrate_Type,\n  SatRelation_RelationType,\n} from '../_generated/protocol/satellite'\nimport { Tag } from '../satellite/oplog'\n\nexport type AnyFunction = (...args: any[]) => any\nexport type BindParams = SqlValue[] | Row\nexport type DbName = string\nexport type DbNamespace = string\nexport type EmptyFunction = () => void\nexport type FunctionMap = { [key: string]: AnyFunction }\nexport type Path = string\nexport type Query = string\nexport type Row = { [key: string]: SqlValue }\nexport type RowCallback = (row: Row) => void\nexport type RowId = number\nexport type SqlValue = string | number | null | Uint8Array | bigint\nexport type StatementId = string\nexport type Tablename = string\nexport type VoidOrPromise = void | Promise<void>\nexport type LSN = Uint8Array\nexport type Statement = { sql: string; args?: SqlValue[] }\n\nexport class SatelliteError extends Error {\n  public code: SatelliteErrorCode\n\n  constructor(code: SatelliteErrorCode, message?: string) {\n    super(message)\n    this.code = code\n  }\n}\n\nexport enum SatelliteErrorCode {\n  CONNECTION_CANCELLED_BY_DISCONNECT,\n  CONNECTION_FAILED_AFTER_RETRY,\n  INTERNAL,\n  TIMEOUT,\n  REPLICATION_NOT_STARTED,\n  REPLICATION_ALREADY_STARTED,\n  UNEXPECTED_STATE,\n  UNEXPECTED_MESSAGE_TYPE,\n  PROTOCOL_VIOLATION,\n  UNKNOWN_DATA_TYPE,\n  SOCKET_ERROR,\n  UNRECOGNIZED,\n  FATAL_ERROR,\n\n  // auth errors\n  AUTH_ERROR,\n  AUTH_FAILED,\n  AUTH_REQUIRED,\n  AUTH_EXPIRED,\n\n  // server errors\n  INVALID_REQUEST,\n  PROTO_VSN_MISMATCH,\n  REPLICATION_FAILED,\n\n  // start replication errors\n  BEHIND_WINDOW,\n  INVALID_POSITION,\n  SUBSCRIPTION_NOT_FOUND,\n  SUBSCRIPTION_ERROR,\n  MALFORMED_LSN,\n  UNKNOWN_SCHEMA_VSN,\n\n  // subscription errors\n  SHAPE_REQUEST_ERROR,\n  SUBSCRIPTION_ID_ALREADY_EXISTS,\n  SUBSCRIPTION_ALREADY_EXISTS,\n  UNEXPECTED_SUBSCRIPTION_STATE,\n\n  // shape request errors\n  TABLE_NOT_FOUND,\n  REFERENTIAL_INTEGRITY_VIOLATION,\n  EMPTY_SHAPE_DEFINITION,\n  DUPLICATE_TABLE_IN_SHAPE_DEFINITION,\n  INVALID_WHERE_CLAUSE_IN_SHAPE_DEFINITION,\n  INVALID_INCLUDE_TREE_IN_SHAPE_DEFINITION,\n\n  // shape data errors\n  SHAPE_DELIVERY_ERROR,\n  SHAPE_SIZE_LIMIT_EXCEEDED,\n\n  // replication transform errors\n  REPLICATION_TRANSFORM_ERROR,\n}\n\nexport type SocketCloseReason =\n  | SatelliteErrorCode.AUTH_EXPIRED\n  | SatelliteErrorCode.SOCKET_ERROR\n\nexport type AuthResponse = {\n  serverId?: string\n  error?: Error\n}\n\nexport type StartReplicationResponse = {\n  error?: SatelliteError\n}\n\nexport type StopReplicationResponse = {\n  error?: SatelliteError\n}\n\nexport type Transaction = {\n  commit_timestamp: Long\n  lsn: LSN\n  changes: Change[]\n  // This field is only set by transactions coming from Electric\n  origin?: string\n  migrationVersion?: string // the Postgres version number if this is a migration\n}\n\nexport type ServerTransaction = Transaction & {\n  id: Long\n  additionalDataRef?: Long\n}\n\nexport interface AdditionalData {\n  ref: Long\n  changes: DataInsert[]\n}\n\n// A transaction whose changes are only DML statements\n// i.e. the transaction does not contain migrations\nexport type DataTransaction = Omit<\n  Transaction,\n  'changes' | 'migrationVersion'\n> & {\n  changes: DataChange[]\n}\n\nexport enum DataChangeType {\n  INSERT = 'INSERT',\n  UPDATE = 'UPDATE',\n  DELETE = 'DELETE',\n  COMPENSATION = 'COMPENSATION',\n  GONE = 'GONE',\n}\n\nexport type Change = DataChange | SchemaChange\n\nexport type DataChange = {\n  relation: Relation\n  type: DataChangeType\n  record?: DbRecord\n  oldRecord?: DbRecord\n  tags: Tag[]\n}\n\nexport type DataGone = {\n  relation: Relation\n  type: DataChangeType.GONE\n  oldRecord: DbRecord\n  tags: []\n}\n\nexport type DataInsert = {\n  relation: Relation\n  type: DataChangeType.INSERT\n  record: DbRecord\n  tags: Tag[]\n}\n\nexport type SatOpMigrate_Col = Omit<SatOpMigrate_Column, '$type' | 'pgType'> & {\n  pgType: Omit<SatOpMigrate_PgColumnType, '$type'> | undefined\n}\n\nexport type MigrationTable = Omit<SatOpMigrate_Table, '$type' | 'columns'> & {\n  columns: SatOpMigrate_Col[]\n}\n\nexport type SchemaChange = {\n  table: MigrationTable // table affected by the schema change\n  migrationType: SatOpMigrate_Type\n  sql: string\n}\n\n// Some functions for narrowing `Change` and `Transaction` types\nexport function isDataChange(change: Change): change is DataChange {\n  return 'relation' in change\n}\n\nexport type DbRecord = {\n  [key: string]: boolean | string | number | Uint8Array | undefined | null\n}\n\nexport type Replication<TransactionType> = {\n  authenticated: boolean\n  isReplicating: ReplicationStatus\n  relations: Map<number, Relation>\n  last_lsn: LSN | undefined\n  transactions: TransactionType[]\n}\n\nexport interface InboundReplication extends Replication<ServerTransaction> {\n  lastTxId: Long | undefined\n  lastAckedTxId: Long | undefined\n  unackedTxs: number\n  maxUnackedTxs: number\n  ackTimer: ReturnType<typeof setTimeout>\n  ackPeriod: number\n  additionalData: AdditionalData[]\n  unseenAdditionalDataRefs: Set<string>\n  incomplete?: 'transaction' | 'additionalData'\n  goneBatch: DataGone[]\n  receivingUnsubsBatch: false | string[]\n  seenAdditionalDataSinceLastTx: {\n    subscriptions: string[]\n    dataRefs: Long[]\n    gone: string[]\n  }\n}\n\nexport type Relation = {\n  id: number\n  schema: string\n  table: string\n  tableType: SatRelation_RelationType\n  columns: RelationColumn[]\n}\n\nexport type RelationColumn = {\n  name: string\n  type: string\n  isNullable: boolean\n  primaryKey?: number\n}\n\nexport type RelationsCache = { [k: string]: Relation }\n\nexport enum ReplicationStatus {\n  STOPPED,\n  STARTING,\n  STOPPING,\n  ACTIVE,\n}\n\nexport type ReplicatedRowTransformer<RowType> = {\n  transformInbound: (row: Readonly<RowType>) => RowType\n  transformOutbound: (row: Readonly<RowType>) => RowType\n}\n\nexport type ErrorCallback = (error: SatelliteError) => void\nexport type RelationCallback = (relation: Relation) => void\nexport type AdditionalDataCallback = (\n  data: AdditionalData\n) => void | Promise<void>\nexport type TransactionCallback = (\n  transaction: ServerTransaction\n) => Promise<void>\nexport type IncomingTransactionCallback = (\n  transaction: DataTransaction,\n  AckCb: () => void\n) => void\nexport type OutboundStartedCallback = () => void\nexport type GoneBatchCallback = (\n  lsn: LSN,\n  subscriptionIds: string[],\n  changes: DataGone[]\n) => void | Promise<void>\n\nexport type ConnectivityStatus = 'connected' | 'disconnected'\nexport type ConnectivityState = {\n  status: ConnectivityStatus\n  reason?: SatelliteError // reason for `disconnected` status\n}\n\nexport type Uuid = `${string}-${string}-${string}-${string}-${string}`\n"],"mappings":"AA4BO,MAAM,uBAAuB,MAAM;AAAA,EACjC;AAAA,EAEP,YAAY,MAA0B,SAAkB;AACtD,UAAM,OAAO;AACb,SAAK,OAAO;AAAA,EACd;AACF;AAEO,IAAK,qBAAL,kBAAKA,wBAAL;AACL,EAAAA,wCAAA;AACA,EAAAA,wCAAA;AACA,EAAAA,wCAAA;AACA,EAAAA,wCAAA;AACA,EAAAA,wCAAA;AACA,EAAAA,wCAAA;AACA,EAAAA,wCAAA;AACA,EAAAA,wCAAA;AACA,EAAAA,wCAAA;AACA,EAAAA,wCAAA;AACA,EAAAA,wCAAA;AACA,EAAAA,wCAAA;AACA,EAAAA,wCAAA;AAGA,EAAAA,wCAAA;AACA,EAAAA,wCAAA;AACA,EAAAA,wCAAA;AACA,EAAAA,wCAAA;AAGA,EAAAA,wCAAA;AACA,EAAAA,wCAAA;AACA,EAAAA,wCAAA;AAGA,EAAAA,wCAAA;AACA,EAAAA,wCAAA;AACA,EAAAA,wCAAA;AACA,EAAAA,wCAAA;AACA,EAAAA,wCAAA;AACA,EAAAA,wCAAA;AAGA,EAAAA,wCAAA;AACA,EAAAA,wCAAA;AACA,EAAAA,wCAAA;AACA,EAAAA,wCAAA;AAGA,EAAAA,wCAAA;AACA,EAAAA,wCAAA;AACA,EAAAA,wCAAA;AACA,EAAAA,wCAAA;AACA,EAAAA,wCAAA;AACA,EAAAA,wCAAA;AAGA,EAAAA,wCAAA;AACA,EAAAA,wCAAA;AAGA,EAAAA,wCAAA;AArDU,SAAAA;AAAA,GAAA;AAqGL,IAAK,iBAAL,kBAAKC,oBAAL;AACL,EAAAA,gBAAA,YAAS;AACT,EAAAA,gBAAA,YAAS;AACT,EAAAA,gBAAA,YAAS;AACT,EAAAA,gBAAA,kBAAe;AACf,EAAAA,gBAAA,UAAO;AALG,SAAAA;AAAA,GAAA;AA+CL,SAAS,aAAa,QAAsC;AACjE,SAAO,cAAc;AACvB;AAkDO,IAAK,oBAAL,kBAAKC,uBAAL;AACL,EAAAA,sCAAA;AACA,EAAAA,sCAAA;AACA,EAAAA,sCAAA;AACA,EAAAA,sCAAA;AAJU,SAAAA;AAAA,GAAA;","names":["SatelliteErrorCode","DataChangeType","ReplicationStatus"]}