{"version":3,"sources":["../../src/util/asyncEventEmitter.ts"],"sourcesContent":["type EventMap = {\n  [key: string]: (...args: any[]) => void | Promise<void>\n}\n\ntype EmittedEvent<Event, Arg> = {\n  event: Event\n  args: Arg[]\n}\n\n/**\n * Implementation of a typed async event emitter.\n * This event emitter maintains a queue of events,\n * the events are processed in order and the next is not started\n * until all (async) event listeners for the previous event have finished.\n * Event listers for a single event are processed concurrently, events are processed sequentially.\n * Typings are inspired by the 'typed-emitter' package.\n */\nexport class AsyncEventEmitter<Events extends EventMap> {\n  private maxListeners = 10 // after how many listeners to print a memory leak warning\n  private listeners: {\n    [E in keyof Events]?: Array<Events[E]>\n  } = {}\n\n  private eventQueue: Array<\n    EmittedEvent<keyof Events, Parameters<Events[keyof Events]>>\n  > = []\n  private processing: Promise<PromiseSettledResult<void>[]> | false = false // indicates whether the event queue is currently being processed\n\n  private getListeners<E extends keyof Events>(event: E): Array<Events[E]> {\n    return this.listeners[event] ?? []\n  }\n\n  private assignListeners<E extends keyof Events>(\n    event: E,\n    listeners: Array<Events[E]>\n  ) {\n    this.listeners[event] = listeners\n    if (listeners.length > this.maxListeners && this.maxListeners !== 0) {\n      console.warn(\n        `Possible AsyncEventEmitter memory leak detected. ${listeners.length} listeners added.`\n      )\n    }\n  }\n\n  /**\n   * Adds the listener function to the end of the listeners array for the given event.\n   * The listeners will be called in order but if they are asynchronous they may run concurrently.\n   * No checks are made to see if the listener has already been added.\n   * Multiple calls passing the same combination of event and listener will result in the listener being added, and called, multiple times.\n   * @param event The event to add the listener to.\n   * @param listener The listener to add.\n   * @returns A reference to the AsyncEventEmitter, so that calls can be chained.\n   */\n  addListener<E extends keyof Events>(event: E, listener: Events[E]): this {\n    const listeners = this.getListeners(event)\n    listeners.push(listener)\n    this.assignListeners(event, listeners)\n    return this\n  }\n\n  on<E extends keyof Events>(event: E, listener: Events[E]): this {\n    return this.addListener(event, listener)\n  }\n\n  /**\n   * Adds the listener function to the beginning of the listeners array for the given event.\n   * The listeners will be called in order but if they are asynchronous they may run concurrently.\n   * No checks are made to see if the listener has already been added.\n   * Multiple calls passing the same combination of event and listener will result in the listener being added, and called, multiple times.\n   * @param event The event to prepend the listener to.\n   * @param listener The listener to prepend.\n   * @returns A reference to the AsyncEventEmitter, so that calls can be chained.\n   */\n  prependListener<E extends keyof Events>(event: E, listener: Events[E]): this {\n    const listeners = this.getListeners(event)\n    listeners.unshift(listener)\n    this.assignListeners(event, listeners)\n    return this\n  }\n\n  /**\n   * Creates a listener that wraps the provided listener.\n   * On the first call, the listener removes itself\n   * and then calls and awaits the provided listener.\n   */\n  private createOnceListener<E extends keyof Events>(\n    event: E,\n    listener: Events[E]\n  ): Events[E] {\n    const wrappedListener = async (...args: Parameters<Events[E]>) => {\n      this.removeListener(event, wrappedListener as Events[E])\n      await listener(...args)\n    }\n    return wrappedListener as Events[E]\n  }\n\n  /**\n   * Adds a listener that is only called on the first event.\n   */\n  once<E extends keyof Events>(event: E, listener: Events[E]): this {\n    const wrappedListener = this.createOnceListener(event, listener)\n    return this.addListener(event, wrappedListener)\n  }\n\n  /**\n   * Adds a one-time listener function for the given event to the beginning of the listeners array.\n   * The next time the event is triggered, this listener is removed, and then invoked.\n   * @param event The event to prepend the listener to.\n   * @param listener The listener to prepend.\n   * @returns A reference to the AsyncEventEmitter, so that calls can be chained.\n   */\n  prependOnceListener<E extends keyof Events>(\n    event: E,\n    listener: Events[E]\n  ): this {\n    const wrappedListener = this.createOnceListener(event, listener)\n    return this.prependListener(event, wrappedListener)\n  }\n\n  /**\n   * This synchronous method processes the queue ASYNCHRONOUSLY.\n   * IMPORTANT: When this process returns, the queue may still being processed by some asynchronous listeners.\n   * When all listeners (including async listeners) have finished processing the events from the queue,\n   * the `this.processing` flag is set to `false`.\n   *\n   * If the event emitter does not have at least one listener registered for the 'error' event,\n   * and an 'error' event is emitted, the error is thrown.\n   */\n  private processQueue() {\n    const emittedEvent = this.eventQueue.shift()\n    if (emittedEvent) {\n      // We call all listeners and process the next event when all listeners finished.\n      // The listeners are not awaited so async listeners may execute concurrently.\n      // However, we only process the next event once all listeners for this event have settled\n      // this ensures that async listeners for distinct events do not run concurrently.\n      // If there are no other events, the recursive call will enter the else branch below\n      // and mark the queue as no longer being processed.\n      const { event, args } = emittedEvent\n      const listeners = this.getListeners(event)\n\n      if (event === 'error' && listeners.length === 0) {\n        this.processing = false\n        throw args[0]\n      }\n\n      // deep copy because once listeners mutate the `this.listeners` array as they remove themselves\n      // which breaks the `map` which iterates over that same array while the contents may shift\n      const ls = [...listeners]\n      const listenerProms = ls.map(async (listener) => {\n        try {\n          await listener(...args)\n        } catch (err) {\n          // rethrow any errors from listeners to be caught by the global\n          // error handler in the next tick to allow for the queue to be\n          // processed without suppressing errors\n          queueMicrotask(() => {\n            throw err\n          })\n        }\n      })\n\n      // wait for all listeners to finish,\n      // some may fail (i.e.return a rejected promise)\n      // but that should not stop the queue from being processed\n      // hence the use of `allSettled` rather than `all`\n      this.processing = Promise.allSettled(listenerProms)\n\n      // only process the next event when all listeners have finished\n      this.processing.then((_) => this.processQueue())\n    } else {\n      // signal that the queue is no longer being processed\n      this.processing = false\n    }\n  }\n\n  /**\n   * Enqueues an event to be processed by its listeners.\n   * Calls each of the listeners registered for the event named `event` in order.\n   * If several asynchronous listeners are registered for this event, they may run concurrently.\n   * However, all (asynchronous) listeners are guaranteed to execute before the next event is processed.\n   * If the `error` event is emitted and the emitter does not have at least one listener registered for it,\n   * the error is thrown.\n   * @param event The event to emit.\n   * @param args The arguments to pass to the listeners.\n   */\n  enqueueEmit<E extends keyof Events>(\n    event: E,\n    ...args: Parameters<Events[E]>\n  ) {\n    this.eventQueue.push({ event, args })\n    if (!this.processing) {\n      this.processQueue()\n    }\n  }\n\n  /**\n   * Removes all listeners, or those of the specified event.\n   * @param event The event for which to remove all listeners.\n   * @returns A reference to the AsyncEventEmitter, so that calls can be chained.\n   */\n  removeAllListeners<E extends keyof Events>(event?: E): this {\n    if (typeof event === 'undefined') {\n      // delete all listeners\n      this.listeners = {}\n    } else {\n      delete this.listeners[event]\n    }\n    return this\n  }\n\n  /**\n   * Removes the given event listener.\n   * @param event The event for which to remove a listener.\n   * @param listener The listener to remove.\n   * @returns A reference to the event emitter such that calls can be chained.\n   */\n  removeListener<E extends keyof Events>(event: E, listener: Events[E]): this {\n    const listeners = this.getListeners(event)\n    const index = listeners.indexOf(listener)\n    if (index !== -1) {\n      listeners.splice(index, 1)\n    }\n    return this\n  }\n\n  /**\n   * Alias for `removeListener`.\n   */\n  off<E extends keyof Events>(event: E, listener: Events[E]): this {\n    return this.removeListener(event, listener)\n  }\n\n  /**\n   * @returns An array listing the events for which the emitter has registered listeners.\n   */\n  eventNames(): (keyof Events | string | symbol)[] {\n    return Object.keys(this.listeners)\n  }\n\n  /**\n   *\n   * @returns The number of listeners associated to the given event.\n   */\n  listenerCount<E extends keyof Events>(event: E): number {\n    return this.getListeners(event).length\n  }\n\n  getMaxListeners(): number {\n    return this.maxListeners\n  }\n\n  /**\n   * By default AsyncEventEmitters print a warning if more than 10 listeners are added for a particular event.\n   * This is a useful default that helps finding memory leaks.\n   * This method modifies the limit for this specific AsyncEventEmitter instance.\n   * The value can be set to Infinity (or 0) to indicate an unlimited number of listeners.\n   * @param maxListeners\n   * @returns A reference to the event emitter, so that calls can be chained.\n   */\n  setMaxListeners(maxListeners: number): this {\n    this.maxListeners = maxListeners\n    return this\n  }\n\n  /**\n   * Wait for event queue to finish processing.\n   */\n  async waitForProcessing(): Promise<void> {\n    await this.processing\n  }\n}\n"],"mappings":"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","names":[]}