import { SatRelation_RelationType } from '../_generated/protocol/satellite.js';
import { QualifiedTablename } from './tablename.js';
async function inferRelationsFromDb(adapter, opts, builder) {
  const tableNames = await _getLocalTableNames(adapter, opts, builder);
  const relations = {};
  let id = 0;
  for (const table of tableNames) {
    const tableName = table.name;
    const columnsForTable = await adapter.query(
      builder.getTableInfo(
        new QualifiedTablename(builder.defaultNamespace, tableName)
      )
    );
    if (columnsForTable.length === 0) {
      continue;
    }
    const relation = {
      id: id++,
      // schema needs to be 'public' because these relations are used
      // by the Satellite process and client to replicate changes to Electric
      // and merge incoming changes from Electric, and those use the 'public' namespace.
      schema: "public",
      table: tableName,
      tableType: SatRelation_RelationType.TABLE,
      columns: []
    };
    for (const c of columnsForTable) {
      relation.columns.push({
        name: c.name.toString(),
        type: c.type.toString(),
        isNullable: Boolean(!c.notnull),
        primaryKey: c.pk > 0 ? c.pk : void 0
      });
    }
    relations[tableName] = relation;
  }
  return relations;
}
async function _getLocalTableNames(adapter, opts, builder) {
  const notIn = [
    opts.metaTable.tablename.toString(),
    opts.migrationsTable.tablename.toString(),
    opts.oplogTable.tablename.toString(),
    opts.triggersTable.tablename.toString(),
    opts.shadowTable.tablename.toString()
  ];
  const rows = await adapter.query(builder.getLocalTableNames(notIn));
  return rows;
}
export {
  inferRelationsFromDb
};
//# sourceMappingURL=relations.js.map