class AsyncEventEmitter {
  maxListeners = 10;
  // after how many listeners to print a memory leak warning
  listeners = {};
  eventQueue = [];
  processing = false;
  // indicates whether the event queue is currently being processed
  getListeners(event) {
    return this.listeners[event] ?? [];
  }
  assignListeners(event, listeners) {
    this.listeners[event] = listeners;
    if (listeners.length > this.maxListeners && this.maxListeners !== 0) {
      console.warn(
        `Possible AsyncEventEmitter memory leak detected. ${listeners.length} listeners added.`
      );
    }
  }
  /**
   * Adds the listener function to the end of the listeners array for the given event.
   * The listeners will be called in order but if they are asynchronous they may run concurrently.
   * No checks are made to see if the listener has already been added.
   * Multiple calls passing the same combination of event and listener will result in the listener being added, and called, multiple times.
   * @param event The event to add the listener to.
   * @param listener The listener to add.
   * @returns A reference to the AsyncEventEmitter, so that calls can be chained.
   */
  addListener(event, listener) {
    const listeners = this.getListeners(event);
    listeners.push(listener);
    this.assignListeners(event, listeners);
    return this;
  }
  on(event, listener) {
    return this.addListener(event, listener);
  }
  /**
   * Adds the listener function to the beginning of the listeners array for the given event.
   * The listeners will be called in order but if they are asynchronous they may run concurrently.
   * No checks are made to see if the listener has already been added.
   * Multiple calls passing the same combination of event and listener will result in the listener being added, and called, multiple times.
   * @param event The event to prepend the listener to.
   * @param listener The listener to prepend.
   * @returns A reference to the AsyncEventEmitter, so that calls can be chained.
   */
  prependListener(event, listener) {
    const listeners = this.getListeners(event);
    listeners.unshift(listener);
    this.assignListeners(event, listeners);
    return this;
  }
  /**
   * Creates a listener that wraps the provided listener.
   * On the first call, the listener removes itself
   * and then calls and awaits the provided listener.
   */
  createOnceListener(event, listener) {
    const wrappedListener = async (...args) => {
      this.removeListener(event, wrappedListener);
      await listener(...args);
    };
    return wrappedListener;
  }
  /**
   * Adds a listener that is only called on the first event.
   */
  once(event, listener) {
    const wrappedListener = this.createOnceListener(event, listener);
    return this.addListener(event, wrappedListener);
  }
  /**
   * Adds a one-time listener function for the given event to the beginning of the listeners array.
   * The next time the event is triggered, this listener is removed, and then invoked.
   * @param event The event to prepend the listener to.
   * @param listener The listener to prepend.
   * @returns A reference to the AsyncEventEmitter, so that calls can be chained.
   */
  prependOnceListener(event, listener) {
    const wrappedListener = this.createOnceListener(event, listener);
    return this.prependListener(event, wrappedListener);
  }
  /**
   * This synchronous method processes the queue ASYNCHRONOUSLY.
   * IMPORTANT: When this process returns, the queue may still being processed by some asynchronous listeners.
   * When all listeners (including async listeners) have finished processing the events from the queue,
   * the `this.processing` flag is set to `false`.
   *
   * If the event emitter does not have at least one listener registered for the 'error' event,
   * and an 'error' event is emitted, the error is thrown.
   */
  processQueue() {
    const emittedEvent = this.eventQueue.shift();
    if (emittedEvent) {
      const { event, args } = emittedEvent;
      const listeners = this.getListeners(event);
      if (event === "error" && listeners.length === 0) {
        this.processing = false;
        throw args[0];
      }
      const ls = [...listeners];
      const listenerProms = ls.map(async (listener) => {
        try {
          await listener(...args);
        } catch (err) {
          queueMicrotask(() => {
            throw err;
          });
        }
      });
      this.processing = Promise.allSettled(listenerProms);
      this.processing.then((_) => this.processQueue());
    } else {
      this.processing = false;
    }
  }
  /**
   * Enqueues an event to be processed by its listeners.
   * Calls each of the listeners registered for the event named `event` in order.
   * If several asynchronous listeners are registered for this event, they may run concurrently.
   * However, all (asynchronous) listeners are guaranteed to execute before the next event is processed.
   * If the `error` event is emitted and the emitter does not have at least one listener registered for it,
   * the error is thrown.
   * @param event The event to emit.
   * @param args The arguments to pass to the listeners.
   */
  enqueueEmit(event, ...args) {
    this.eventQueue.push({ event, args });
    if (!this.processing) {
      this.processQueue();
    }
  }
  /**
   * Removes all listeners, or those of the specified event.
   * @param event The event for which to remove all listeners.
   * @returns A reference to the AsyncEventEmitter, so that calls can be chained.
   */
  removeAllListeners(event) {
    if (typeof event === "undefined") {
      this.listeners = {};
    } else {
      delete this.listeners[event];
    }
    return this;
  }
  /**
   * Removes the given event listener.
   * @param event The event for which to remove a listener.
   * @param listener The listener to remove.
   * @returns A reference to the event emitter such that calls can be chained.
   */
  removeListener(event, listener) {
    const listeners = this.getListeners(event);
    const index = listeners.indexOf(listener);
    if (index !== -1) {
      listeners.splice(index, 1);
    }
    return this;
  }
  /**
   * Alias for `removeListener`.
   */
  off(event, listener) {
    return this.removeListener(event, listener);
  }
  /**
   * @returns An array listing the events for which the emitter has registered listeners.
   */
  eventNames() {
    return Object.keys(this.listeners);
  }
  /**
   *
   * @returns The number of listeners associated to the given event.
   */
  listenerCount(event) {
    return this.getListeners(event).length;
  }
  getMaxListeners() {
    return this.maxListeners;
  }
  /**
   * By default AsyncEventEmitters print a warning if more than 10 listeners are added for a particular event.
   * This is a useful default that helps finding memory leaks.
   * This method modifies the limit for this specific AsyncEventEmitter instance.
   * The value can be set to Infinity (or 0) to indicate an unlimited number of listeners.
   * @param maxListeners
   * @returns A reference to the event emitter, so that calls can be chained.
   */
  setMaxListeners(maxListeners) {
    this.maxListeners = maxListeners;
    return this;
  }
  /**
   * Wait for event queue to finish processing.
   */
  async waitForProcessing() {
    await this.processing;
  }
}
export {
  AsyncEventEmitter
};
//# sourceMappingURL=asyncEventEmitter.js.map