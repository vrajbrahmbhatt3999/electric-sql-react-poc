{"version":3,"sources":["../../src/util/relations.ts"],"sourcesContent":["import { SatRelation_RelationType } from '../_generated/protocol/satellite'\nimport { DatabaseAdapter } from '../electric/adapter'\nimport { QueryBuilder } from '../migrators/query-builder'\nimport { SatelliteOpts } from '../satellite/config'\nimport { QualifiedTablename } from './tablename'\nimport { Relation, RelationsCache } from './types'\n\n// TODO: Improve this code once with Migrator and consider simplifying oplog.\nexport async function inferRelationsFromDb(\n  adapter: DatabaseAdapter,\n  opts: SatelliteOpts,\n  builder: QueryBuilder\n): Promise<{ [k: string]: Relation }> {\n  const tableNames = await _getLocalTableNames(adapter, opts, builder)\n  const relations: RelationsCache = {}\n\n  let id = 0\n  for (const table of tableNames) {\n    const tableName = table.name\n    const columnsForTable = (await adapter.query(\n      builder.getTableInfo(\n        new QualifiedTablename(builder.defaultNamespace, tableName)\n      )\n    )) as {\n      name: string\n      type: string\n      notnull: number\n      pk: number\n    }[]\n    if (columnsForTable.length === 0) {\n      continue\n    }\n    const relation: Relation = {\n      id: id++,\n      // schema needs to be 'public' because these relations are used\n      // by the Satellite process and client to replicate changes to Electric\n      // and merge incoming changes from Electric, and those use the 'public' namespace.\n      schema: 'public',\n      table: tableName,\n      tableType: SatRelation_RelationType.TABLE,\n      columns: [],\n    }\n    for (const c of columnsForTable) {\n      relation.columns.push({\n        name: c.name.toString(),\n        type: c.type.toString(),\n        isNullable: Boolean(!c.notnull),\n        primaryKey: c.pk > 0 ? c.pk : undefined,\n      })\n    }\n    relations[tableName] = relation\n  }\n\n  return relations\n}\n\nasync function _getLocalTableNames(\n  adapter: DatabaseAdapter,\n  opts: SatelliteOpts,\n  builder: QueryBuilder\n): Promise<{ name: string }[]> {\n  const notIn = [\n    opts.metaTable.tablename.toString(),\n    opts.migrationsTable.tablename.toString(),\n    opts.oplogTable.tablename.toString(),\n    opts.triggersTable.tablename.toString(),\n    opts.shadowTable.tablename.toString(),\n  ]\n\n  const rows = await adapter.query(builder.getLocalTableNames(notIn))\n  return rows as Array<{ name: string }>\n}\n"],"mappings":"AAAA,SAAS,gCAAgC;AAIzC,SAAS,0BAA0B;AAInC,eAAsB,qBACpB,SACA,MACA,SACoC;AACpC,QAAM,aAAa,MAAM,oBAAoB,SAAS,MAAM,OAAO;AACnE,QAAM,YAA4B,CAAC;AAEnC,MAAI,KAAK;AACT,aAAW,SAAS,YAAY;AAC9B,UAAM,YAAY,MAAM;AACxB,UAAM,kBAAmB,MAAM,QAAQ;AAAA,MACrC,QAAQ;AAAA,QACN,IAAI,mBAAmB,QAAQ,kBAAkB,SAAS;AAAA,MAC5D;AAAA,IACF;AAMA,QAAI,gBAAgB,WAAW,GAAG;AAChC;AAAA,IACF;AACA,UAAM,WAAqB;AAAA,MACzB,IAAI;AAAA;AAAA;AAAA;AAAA,MAIJ,QAAQ;AAAA,MACR,OAAO;AAAA,MACP,WAAW,yBAAyB;AAAA,MACpC,SAAS,CAAC;AAAA,IACZ;AACA,eAAW,KAAK,iBAAiB;AAC/B,eAAS,QAAQ,KAAK;AAAA,QACpB,MAAM,EAAE,KAAK,SAAS;AAAA,QACtB,MAAM,EAAE,KAAK,SAAS;AAAA,QACtB,YAAY,QAAQ,CAAC,EAAE,OAAO;AAAA,QAC9B,YAAY,EAAE,KAAK,IAAI,EAAE,KAAK;AAAA,MAChC,CAAC;AAAA,IACH;AACA,cAAU,SAAS,IAAI;AAAA,EACzB;AAEA,SAAO;AACT;AAEA,eAAe,oBACb,SACA,MACA,SAC6B;AAC7B,QAAM,QAAQ;AAAA,IACZ,KAAK,UAAU,UAAU,SAAS;AAAA,IAClC,KAAK,gBAAgB,UAAU,SAAS;AAAA,IACxC,KAAK,WAAW,UAAU,SAAS;AAAA,IACnC,KAAK,cAAc,UAAU,SAAS;AAAA,IACtC,KAAK,YAAY,UAAU,SAAS;AAAA,EACtC;AAEA,QAAM,OAAO,MAAM,QAAQ,MAAM,QAAQ,mBAAmB,KAAK,CAAC;AAClE,SAAO;AACT;","names":[]}