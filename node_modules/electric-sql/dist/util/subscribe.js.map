{"version":3,"sources":["../../src/util/subscribe.ts"],"sourcesContent":["import { ConnectivityState, QualifiedTablename, hasIntersection } from '.'\nimport { LiveResult, LiveResultUpdate } from '../client/model/model'\nimport {\n  ConnectivityStateChangeNotification,\n  Notifier,\n  UnsubscribeFunction,\n} from '../notifiers'\n\nexport type LiveResultSubscribeFunction<T> = (\n  handler: (resultUpdate: LiveResultUpdate<T>) => void\n) => UnsubscribeFunction\n\nexport type ConnectivityStateSubscribeFuncition = (\n  handler: (connectivityStateUpdate: ConnectivityState) => void\n) => UnsubscribeFunction\n\n/**\n * Generates a function that allows a client to subscribe to updates\n * to results generated by a given `liveQuery`. An update with the full\n * query result will occur anytime a table touched by the query is updated.\n *\n * @returns A function to unsubscribe from query result updates\n */\nexport function createQueryResultSubscribeFunction<T>(\n  notifier: Notifier,\n  liveQuery: () => Promise<LiveResult<T>>,\n  relevantTablenames?: QualifiedTablename[]\n): LiveResultSubscribeFunction<T> {\n  return (handler) => {\n    let cancelled = false\n    const update = async () => {\n      try {\n        const res = await liveQuery()\n        if (cancelled) return\n        relevantTablenames ??= res.tablenames\n        handler({ results: res.result, updatedAt: new Date() })\n      } catch (err) {\n        if (cancelled) return\n        handler({ error: err, updatedAt: new Date() })\n      }\n    }\n\n    // call once upon subscribing to deliver most recent result\n    update()\n\n    // subscribe to subsequent changes to relevant tables\n    const unsubscribe = notifier.subscribeToDataChanges((notification) => {\n      const changedTablenames = notifier.alias(notification)\n      if (\n        relevantTablenames &&\n        hasIntersection(relevantTablenames, changedTablenames)\n      )\n        update()\n    })\n\n    return () => {\n      cancelled = true\n      unsubscribe()\n    }\n  }\n}\n\nexport function createConnectivityStateSubscribeFunction(\n  notifier: Notifier\n): ConnectivityStateSubscribeFuncition {\n  return (handler) => {\n    let cancelled = false\n    const update = ({\n      connectivityState,\n    }: Pick<ConnectivityStateChangeNotification, 'connectivityState'>) => {\n      if (cancelled) return\n      handler(connectivityState)\n    }\n\n    const unsubscribe = notifier.subscribeToConnectivityStateChanges(update)\n\n    return () => {\n      cancelled = true\n      unsubscribe()\n    }\n  }\n}\n"],"mappings":"AAAA,SAAgD,uBAAuB;AAuBhE,SAAS,mCACd,UACA,WACA,oBACgC;AAChC,SAAO,CAAC,YAAY;AAClB,QAAI,YAAY;AAChB,UAAM,SAAS,YAAY;AACzB,UAAI;AACF,cAAM,MAAM,MAAM,UAAU;AAC5B,YAAI;AAAW;AACf,+BAAuB,IAAI;AAC3B,gBAAQ,EAAE,SAAS,IAAI,QAAQ,WAAW,oBAAI,KAAK,EAAE,CAAC;AAAA,MACxD,SAAS,KAAK;AACZ,YAAI;AAAW;AACf,gBAAQ,EAAE,OAAO,KAAK,WAAW,oBAAI,KAAK,EAAE,CAAC;AAAA,MAC/C;AAAA,IACF;AAGA,WAAO;AAGP,UAAM,cAAc,SAAS,uBAAuB,CAAC,iBAAiB;AACpE,YAAM,oBAAoB,SAAS,MAAM,YAAY;AACrD,UACE,sBACA,gBAAgB,oBAAoB,iBAAiB;AAErD,eAAO;AAAA,IACX,CAAC;AAED,WAAO,MAAM;AACX,kBAAY;AACZ,kBAAY;AAAA,IACd;AAAA,EACF;AACF;AAEO,SAAS,yCACd,UACqC;AACrC,SAAO,CAAC,YAAY;AAClB,QAAI,YAAY;AAChB,UAAM,SAAS,CAAC;AAAA,MACd;AAAA,IACF,MAAsE;AACpE,UAAI;AAAW;AACf,cAAQ,iBAAiB;AAAA,IAC3B;AAEA,UAAM,cAAc,SAAS,oCAAoC,MAAM;AAEvE,WAAO,MAAM;AACX,kBAAY;AACZ,kBAAY;AAAA,IACd;AAAA,EACF;AACF;","names":[]}