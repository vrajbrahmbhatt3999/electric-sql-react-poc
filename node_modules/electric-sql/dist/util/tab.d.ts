interface Storage {
    getItem: (key: string) => any;
    setItem: (key: string, value: string) => void;
}
interface NavEntry {
    [key: string]: any;
}
interface Options {
    key?: string;
    navEntries?: NavEntry[];
    storage?: Storage;
}
interface ReturnValue {
    tabId: string;
    hasExisting: boolean;
    usingExisting: boolean;
    mayBeDuplicate?: boolean;
}
/**
 * Returns a unique ID for each browser tab. This can be used to construct a
 * tab scoped DB name. This allows data to sync between tabs by using one
 * named SQLite database file per tab. This is sub-optimal compared with
 * sharing a database but avoids concurrent database access.
 *
 * Handles duplicate tabs with some potential for false positives.
 * False positives result in a new tabID which means a new database name
 * and thus additional data transfer and storage.
 *
 * Uses window.sessionStorage. Some browsers disable access to sessionStorage
 * even when saying its available (e.g.: as a result of disabling third party
 * cookies o_O). So we handle this by falling back to an in-memory tabId
 * singleton -- which means each page load syncs data into a new DB.
 *
 * Other platforms can pass in a storage implementation or default to the
 * in-memory tabId singleton.
 */
export declare const uniqueTabId: (opts?: Options) => ReturnValue;
export {};
