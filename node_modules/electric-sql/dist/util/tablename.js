class QualifiedTablename {
  namespace;
  tablename;
  constructor(namespace, tablename) {
    this.namespace = namespace;
    this.tablename = tablename;
  }
  isEqual({ namespace, tablename }) {
    return namespace === this.namespace && tablename === this.tablename;
  }
  toString() {
    return `"${escDoubleQ(this.namespace)}"."${escDoubleQ(this.tablename)}"`;
  }
  static parse(fullyQualifiedName) {
    try {
      const [_, namespace, tablename] = /^"((?:[^"]|"")+)"\."((?:[^"]|"")+)"$/.exec(fullyQualifiedName);
      return new QualifiedTablename(
        unescDoubleQ(namespace),
        unescDoubleQ(tablename)
      );
    } catch (_e) {
      throw new Error(
        "Could not parse string into a qualified table name: " + fullyQualifiedName
      );
    }
  }
}
const hasIntersection = (tablenames, candidates) => {
  const tLen = tablenames.length;
  const cLen = candidates.length;
  for (let i = 0; i < tLen; ++i) {
    const tablename = tablenames[i];
    for (let j = 0; j < cLen; ++j) {
      const candidate = candidates[j];
      if (tablename.isEqual(candidate)) {
        return true;
      }
    }
  }
  return false;
};
function escDoubleQ(str) {
  return str.replaceAll('"', '""');
}
function unescDoubleQ(str) {
  return str.replaceAll('""', '"');
}
export {
  QualifiedTablename,
  escDoubleQ,
  hasIntersection
};
//# sourceMappingURL=tablename.js.map