{"version":3,"sources":["../../src/util/arrays.ts"],"sourcesContent":["/**\n * Chunk an array based on the value returned by a mapping function.\n *\n * Returns an iterable, that yields pairs with first value being the\n * return of the mapper function, and the second value being the chunk\n *\n * @param arr array to be chunked\n * @param mapper mapping function designating the chunk \"key\"\n * @returns an iterable with pairs of chunk \"keys\" and chunks themselves.\n */\nexport function chunkBy<T, K>(\n  arr: T[],\n  mapper: (elem: T, idx: number, arr: T[]) => K\n): Iterable<[K, T[]]> {\n  return {\n    *[Symbol.iterator]() {\n      if (arr.length === 0) return\n\n      let currentChunkValue: K = mapper(arr[0], 0, arr)\n      let newChunkValue: K\n      let currentChunk: T[] = [arr[0]]\n\n      for (let idx = 1; idx < arr.length; ++idx) {\n        newChunkValue = mapper(arr[idx], idx, arr)\n        if (currentChunkValue === newChunkValue) {\n          // Still the same chunk, expand it\n          currentChunk.push(arr[idx])\n          currentChunkValue = newChunkValue\n        } else {\n          // Chunk boundary crossed, yield the current chunk and start the new one\n          yield [currentChunkValue, currentChunk]\n          currentChunkValue = newChunkValue\n          currentChunk = [arr[idx]]\n        }\n      }\n\n      // Yield the last chunk we've been building up in the loop\n      yield [currentChunkValue, currentChunk]\n    },\n  }\n}\n"],"mappings":"AAUO,SAAS,QACd,KACA,QACoB;AACpB,SAAO;AAAA,IACL,EAAE,OAAO,QAAQ,IAAI;AACnB,UAAI,IAAI,WAAW;AAAG;AAEtB,UAAI,oBAAuB,OAAO,IAAI,CAAC,GAAG,GAAG,GAAG;AAChD,UAAI;AACJ,UAAI,eAAoB,CAAC,IAAI,CAAC,CAAC;AAE/B,eAAS,MAAM,GAAG,MAAM,IAAI,QAAQ,EAAE,KAAK;AACzC,wBAAgB,OAAO,IAAI,GAAG,GAAG,KAAK,GAAG;AACzC,YAAI,sBAAsB,eAAe;AAEvC,uBAAa,KAAK,IAAI,GAAG,CAAC;AAC1B,8BAAoB;AAAA,QACtB,OAAO;AAEL,gBAAM,CAAC,mBAAmB,YAAY;AACtC,8BAAoB;AACpB,yBAAe,CAAC,IAAI,GAAG,CAAC;AAAA,QAC1B;AAAA,MACF;AAGA,YAAM,CAAC,mBAAmB,YAAY;AAAA,IACxC;AAAA,EACF;AACF;","names":[]}