import type Long from 'long';
import { SatOpMigrate_Column, SatOpMigrate_PgColumnType, SatOpMigrate_Table, SatOpMigrate_Type, SatRelation_RelationType } from '../_generated/protocol/satellite.js';
import { Tag } from '../satellite/oplog.js';
export type AnyFunction = (...args: any[]) => any;
export type BindParams = SqlValue[] | Row;
export type DbName = string;
export type DbNamespace = string;
export type EmptyFunction = () => void;
export type FunctionMap = {
    [key: string]: AnyFunction;
};
export type Path = string;
export type Query = string;
export type Row = {
    [key: string]: SqlValue;
};
export type RowCallback = (row: Row) => void;
export type RowId = number;
export type SqlValue = string | number | null | Uint8Array | bigint;
export type StatementId = string;
export type Tablename = string;
export type VoidOrPromise = void | Promise<void>;
export type LSN = Uint8Array;
export type Statement = {
    sql: string;
    args?: SqlValue[];
};
export declare class SatelliteError extends Error {
    code: SatelliteErrorCode;
    constructor(code: SatelliteErrorCode, message?: string);
}
export declare enum SatelliteErrorCode {
    CONNECTION_CANCELLED_BY_DISCONNECT = 0,
    CONNECTION_FAILED_AFTER_RETRY = 1,
    INTERNAL = 2,
    TIMEOUT = 3,
    REPLICATION_NOT_STARTED = 4,
    REPLICATION_ALREADY_STARTED = 5,
    UNEXPECTED_STATE = 6,
    UNEXPECTED_MESSAGE_TYPE = 7,
    PROTOCOL_VIOLATION = 8,
    UNKNOWN_DATA_TYPE = 9,
    SOCKET_ERROR = 10,
    UNRECOGNIZED = 11,
    FATAL_ERROR = 12,
    AUTH_ERROR = 13,
    AUTH_FAILED = 14,
    AUTH_REQUIRED = 15,
    AUTH_EXPIRED = 16,
    INVALID_REQUEST = 17,
    PROTO_VSN_MISMATCH = 18,
    REPLICATION_FAILED = 19,
    BEHIND_WINDOW = 20,
    INVALID_POSITION = 21,
    SUBSCRIPTION_NOT_FOUND = 22,
    SUBSCRIPTION_ERROR = 23,
    MALFORMED_LSN = 24,
    UNKNOWN_SCHEMA_VSN = 25,
    SHAPE_REQUEST_ERROR = 26,
    SUBSCRIPTION_ID_ALREADY_EXISTS = 27,
    SUBSCRIPTION_ALREADY_EXISTS = 28,
    UNEXPECTED_SUBSCRIPTION_STATE = 29,
    TABLE_NOT_FOUND = 30,
    REFERENTIAL_INTEGRITY_VIOLATION = 31,
    EMPTY_SHAPE_DEFINITION = 32,
    DUPLICATE_TABLE_IN_SHAPE_DEFINITION = 33,
    INVALID_WHERE_CLAUSE_IN_SHAPE_DEFINITION = 34,
    INVALID_INCLUDE_TREE_IN_SHAPE_DEFINITION = 35,
    SHAPE_DELIVERY_ERROR = 36,
    SHAPE_SIZE_LIMIT_EXCEEDED = 37,
    REPLICATION_TRANSFORM_ERROR = 38
}
export type SocketCloseReason = SatelliteErrorCode.AUTH_EXPIRED | SatelliteErrorCode.SOCKET_ERROR;
export type AuthResponse = {
    serverId?: string;
    error?: Error;
};
export type StartReplicationResponse = {
    error?: SatelliteError;
};
export type StopReplicationResponse = {
    error?: SatelliteError;
};
export type Transaction = {
    commit_timestamp: Long;
    lsn: LSN;
    changes: Change[];
    origin?: string;
    migrationVersion?: string;
};
export type ServerTransaction = Transaction & {
    id: Long;
    additionalDataRef?: Long;
};
export interface AdditionalData {
    ref: Long;
    changes: DataInsert[];
}
export type DataTransaction = Omit<Transaction, 'changes' | 'migrationVersion'> & {
    changes: DataChange[];
};
export declare enum DataChangeType {
    INSERT = "INSERT",
    UPDATE = "UPDATE",
    DELETE = "DELETE",
    COMPENSATION = "COMPENSATION",
    GONE = "GONE"
}
export type Change = DataChange | SchemaChange;
export type DataChange = {
    relation: Relation;
    type: DataChangeType;
    record?: DbRecord;
    oldRecord?: DbRecord;
    tags: Tag[];
};
export type DataGone = {
    relation: Relation;
    type: DataChangeType.GONE;
    oldRecord: DbRecord;
    tags: [];
};
export type DataInsert = {
    relation: Relation;
    type: DataChangeType.INSERT;
    record: DbRecord;
    tags: Tag[];
};
export type SatOpMigrate_Col = Omit<SatOpMigrate_Column, '$type' | 'pgType'> & {
    pgType: Omit<SatOpMigrate_PgColumnType, '$type'> | undefined;
};
export type MigrationTable = Omit<SatOpMigrate_Table, '$type' | 'columns'> & {
    columns: SatOpMigrate_Col[];
};
export type SchemaChange = {
    table: MigrationTable;
    migrationType: SatOpMigrate_Type;
    sql: string;
};
export declare function isDataChange(change: Change): change is DataChange;
export type DbRecord = {
    [key: string]: boolean | string | number | Uint8Array | undefined | null;
};
export type Replication<TransactionType> = {
    authenticated: boolean;
    isReplicating: ReplicationStatus;
    relations: Map<number, Relation>;
    last_lsn: LSN | undefined;
    transactions: TransactionType[];
};
export interface InboundReplication extends Replication<ServerTransaction> {
    lastTxId: Long | undefined;
    lastAckedTxId: Long | undefined;
    unackedTxs: number;
    maxUnackedTxs: number;
    ackTimer: ReturnType<typeof setTimeout>;
    ackPeriod: number;
    additionalData: AdditionalData[];
    unseenAdditionalDataRefs: Set<string>;
    incomplete?: 'transaction' | 'additionalData';
    goneBatch: DataGone[];
    receivingUnsubsBatch: false | string[];
    seenAdditionalDataSinceLastTx: {
        subscriptions: string[];
        dataRefs: Long[];
        gone: string[];
    };
}
export type Relation = {
    id: number;
    schema: string;
    table: string;
    tableType: SatRelation_RelationType;
    columns: RelationColumn[];
};
export type RelationColumn = {
    name: string;
    type: string;
    isNullable: boolean;
    primaryKey?: number;
};
export type RelationsCache = {
    [k: string]: Relation;
};
export declare enum ReplicationStatus {
    STOPPED = 0,
    STARTING = 1,
    STOPPING = 2,
    ACTIVE = 3
}
export type ReplicatedRowTransformer<RowType> = {
    transformInbound: (row: Readonly<RowType>) => RowType;
    transformOutbound: (row: Readonly<RowType>) => RowType;
};
export type ErrorCallback = (error: SatelliteError) => void;
export type RelationCallback = (relation: Relation) => void;
export type AdditionalDataCallback = (data: AdditionalData) => void | Promise<void>;
export type TransactionCallback = (transaction: ServerTransaction) => Promise<void>;
export type IncomingTransactionCallback = (transaction: DataTransaction, AckCb: () => void) => void;
export type OutboundStartedCallback = () => void;
export type GoneBatchCallback = (lsn: LSN, subscriptionIds: string[], changes: DataGone[]) => void | Promise<void>;
export type ConnectivityStatus = 'connected' | 'disconnected';
export type ConnectivityState = {
    status: ConnectivityStatus;
    reason?: SatelliteError;
};
export type Uuid = `${string}-${string}-${string}-${string}-${string}`;
