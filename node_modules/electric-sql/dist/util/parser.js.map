{"version":3,"sources":["../../src/util/parser.ts"],"sourcesContent":["import { QualifiedTablename } from './tablename'\nimport { DbNamespace } from './types'\n\nconst dangerousKeywords = [\n  'add',\n  'alter',\n  'commit',\n  'create',\n  'delete',\n  'drop',\n  'exec',\n  'insert',\n  'select into',\n  'set',\n  'truncate',\n  'update',\n]\n\nconst dangerousKeywordsExp = new RegExp(\n  dangerousKeywords.map((keyword) => `\\\\b${keyword}\\\\b`).join('|'),\n  'imu'\n)\n\n// XXX ideally this could be schema aware to know about dangerous\n// stored functions. But it's not the end of the world if we miss\n// some updates as the user can notify manually and the satellite\n// still picks up the changes via polling.\n//\n// XXX it's also possible to implement this per statement using\n// https://www.sqlite.org/c3ref/stmt_readonly.html\nexport const isPotentiallyDangerous = (stmt: string): boolean => {\n  return dangerousKeywordsExp.test(stmt)\n}\n\nexport const parseTableNames = (\n  sqlQuery: string,\n  defaultNamespace: DbNamespace = 'main'\n): QualifiedTablename[] => {\n  // NOTE(msfstef): using an SQLite parser to create an AST and\n  // walk down it to find tablenames is a cleaner solution, but\n  // there are no up-to-date parsers I could find that would not\n  // block modern queries (e.g. windowed queries).\n  // For the sake of parsing table names, this seems to do the\n  // trick, and with enough test coverage it should be fine\n  const tableNameExp = /(?:FROM|JOIN)\\s+([a-zA-Z_][a-zA-Z0-9_$.]*)/gi\n  const tableMatches = []\n  let match\n  while ((match = tableNameExp.exec(sqlQuery)) !== null) {\n    tableMatches.push(match[1])\n  }\n\n  const results: QualifiedTablename[] = []\n  Array.from(tableMatches)\n    .map((tn) => _ensureQualified(tn, defaultNamespace))\n    .sort()\n    .forEach((value: string) => {\n      const [namespace, tablename] = value.split('.')\n      results.push(new QualifiedTablename(namespace, tablename))\n    })\n\n  return results\n}\n\nconst _ensureQualified = (\n  candidate: string,\n  defaultNamespace: DbNamespace = 'main'\n): string => {\n  if (candidate.includes('.')) {\n    return candidate\n  }\n\n  return `${defaultNamespace}.${candidate}`\n}\n"],"mappings":"AAAA,SAAS,0BAA0B;AAGnC,MAAM,oBAAoB;AAAA,EACxB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAEA,MAAM,uBAAuB,IAAI;AAAA,EAC/B,kBAAkB,IAAI,CAAC,YAAY,MAAM,OAAO,KAAK,EAAE,KAAK,GAAG;AAAA,EAC/D;AACF;AASO,MAAM,yBAAyB,CAAC,SAA0B;AAC/D,SAAO,qBAAqB,KAAK,IAAI;AACvC;AAEO,MAAM,kBAAkB,CAC7B,UACA,mBAAgC,WACP;AAOzB,QAAM,eAAe;AACrB,QAAM,eAAe,CAAC;AACtB,MAAI;AACJ,UAAQ,QAAQ,aAAa,KAAK,QAAQ,OAAO,MAAM;AACrD,iBAAa,KAAK,MAAM,CAAC,CAAC;AAAA,EAC5B;AAEA,QAAM,UAAgC,CAAC;AACvC,QAAM,KAAK,YAAY,EACpB,IAAI,CAAC,OAAO,iBAAiB,IAAI,gBAAgB,CAAC,EAClD,KAAK,EACL,QAAQ,CAAC,UAAkB;AAC1B,UAAM,CAAC,WAAW,SAAS,IAAI,MAAM,MAAM,GAAG;AAC9C,YAAQ,KAAK,IAAI,mBAAmB,WAAW,SAAS,CAAC;AAAA,EAC3D,CAAC;AAEH,SAAO;AACT;AAEA,MAAM,mBAAmB,CACvB,WACA,mBAAgC,WACrB;AACX,MAAI,UAAU,SAAS,GAAG,GAAG;AAC3B,WAAO;AAAA,EACT;AAEA,SAAO,GAAG,gBAAgB,IAAI,SAAS;AACzC;","names":[]}