{"version":3,"sources":["../../src/util/bitmaskHelpers.ts"],"sourcesContent":["/**\n * Sets a bit in the mask. Modifies the mask in place.\n *\n * Mask is represented as a Uint8Array, which will be serialized element-by-element as a mask.\n * This means that `indexFromStart` enumerates all bits in the mask in the order they will be serialized:\n *\n * @example\n * setMaskBit(new Uint8Array([0b00000000, 0b00000000]), 0)\n * // => new Uint8Array([0b10000000, 0b00000000])\n *\n * @example\n * setMaskBit(new Uint8Array([0b00000000, 0b00000000]), 8)\n * // => new Uint8Array([0b00000000, 0b10000000])\n *\n * @param array Uint8Array mask\n * @param indexFromStart bit index in the mask\n */\n\nexport function setMaskBit(array: Uint8Array, indexFromStart: number): void {\n  const byteIndex = Math.floor(indexFromStart / 8)\n  const bitIndex = 7 - (indexFromStart % 8)\n\n  const mask = 1 << bitIndex\n  array[byteIndex] = array[byteIndex] | mask\n}\n/**\n * Reads a bit in the mask\n *\n * Mask is represented as a Uint8Array, which will be serialized element-by-element as a mask.\n * This means that `indexFromStart` enumerates all bits in the mask in the order they will be serialized:\n *\n * @example\n * getMaskBit(new Uint8Array([0b10000000, 0b00000000]), 0)\n * // => 1\n *\n * @example\n * getMaskBit(new Uint8Array([0b10000000, 0b00000000]), 8)\n * // => 0\n *\n * @param array Uint8Array mask\n * @param indexFromStart bit index in the mask\n */\n\nexport function getMaskBit(array: Uint8Array, indexFromStart: number): 1 | 0 {\n  const byteIndex = Math.floor(indexFromStart / 8)\n  const bitIndex = 7 - (indexFromStart % 8)\n\n  return ((array[byteIndex] >>> bitIndex) & 1) as 1 | 0\n}\n"],"mappings":"AAkBO,SAAS,WAAW,OAAmB,gBAA8B;AAC1E,QAAM,YAAY,KAAK,MAAM,iBAAiB,CAAC;AAC/C,QAAM,WAAW,IAAK,iBAAiB;AAEvC,QAAM,OAAO,KAAK;AAClB,QAAM,SAAS,IAAI,MAAM,SAAS,IAAI;AACxC;AAmBO,SAAS,WAAW,OAAmB,gBAA+B;AAC3E,QAAM,YAAY,KAAK,MAAM,iBAAiB,CAAC;AAC/C,QAAM,WAAW,IAAK,iBAAiB;AAEvC,SAAS,MAAM,SAAS,MAAM,WAAY;AAC5C;","names":[]}