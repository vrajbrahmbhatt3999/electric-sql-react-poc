type EventMap = {
    [key: string]: (...args: any[]) => void | Promise<void>;
};
/**
 * Implementation of a typed async event emitter.
 * This event emitter maintains a queue of events,
 * the events are processed in order and the next is not started
 * until all (async) event listeners for the previous event have finished.
 * Event listers for a single event are processed concurrently, events are processed sequentially.
 * Typings are inspired by the 'typed-emitter' package.
 */
export declare class AsyncEventEmitter<Events extends EventMap> {
    private maxListeners;
    private listeners;
    private eventQueue;
    private processing;
    private getListeners;
    private assignListeners;
    /**
     * Adds the listener function to the end of the listeners array for the given event.
     * The listeners will be called in order but if they are asynchronous they may run concurrently.
     * No checks are made to see if the listener has already been added.
     * Multiple calls passing the same combination of event and listener will result in the listener being added, and called, multiple times.
     * @param event The event to add the listener to.
     * @param listener The listener to add.
     * @returns A reference to the AsyncEventEmitter, so that calls can be chained.
     */
    addListener<E extends keyof Events>(event: E, listener: Events[E]): this;
    on<E extends keyof Events>(event: E, listener: Events[E]): this;
    /**
     * Adds the listener function to the beginning of the listeners array for the given event.
     * The listeners will be called in order but if they are asynchronous they may run concurrently.
     * No checks are made to see if the listener has already been added.
     * Multiple calls passing the same combination of event and listener will result in the listener being added, and called, multiple times.
     * @param event The event to prepend the listener to.
     * @param listener The listener to prepend.
     * @returns A reference to the AsyncEventEmitter, so that calls can be chained.
     */
    prependListener<E extends keyof Events>(event: E, listener: Events[E]): this;
    /**
     * Creates a listener that wraps the provided listener.
     * On the first call, the listener removes itself
     * and then calls and awaits the provided listener.
     */
    private createOnceListener;
    /**
     * Adds a listener that is only called on the first event.
     */
    once<E extends keyof Events>(event: E, listener: Events[E]): this;
    /**
     * Adds a one-time listener function for the given event to the beginning of the listeners array.
     * The next time the event is triggered, this listener is removed, and then invoked.
     * @param event The event to prepend the listener to.
     * @param listener The listener to prepend.
     * @returns A reference to the AsyncEventEmitter, so that calls can be chained.
     */
    prependOnceListener<E extends keyof Events>(event: E, listener: Events[E]): this;
    /**
     * This synchronous method processes the queue ASYNCHRONOUSLY.
     * IMPORTANT: When this process returns, the queue may still being processed by some asynchronous listeners.
     * When all listeners (including async listeners) have finished processing the events from the queue,
     * the `this.processing` flag is set to `false`.
     *
     * If the event emitter does not have at least one listener registered for the 'error' event,
     * and an 'error' event is emitted, the error is thrown.
     */
    private processQueue;
    /**
     * Enqueues an event to be processed by its listeners.
     * Calls each of the listeners registered for the event named `event` in order.
     * If several asynchronous listeners are registered for this event, they may run concurrently.
     * However, all (asynchronous) listeners are guaranteed to execute before the next event is processed.
     * If the `error` event is emitted and the emitter does not have at least one listener registered for it,
     * the error is thrown.
     * @param event The event to emit.
     * @param args The arguments to pass to the listeners.
     */
    enqueueEmit<E extends keyof Events>(event: E, ...args: Parameters<Events[E]>): void;
    /**
     * Removes all listeners, or those of the specified event.
     * @param event The event for which to remove all listeners.
     * @returns A reference to the AsyncEventEmitter, so that calls can be chained.
     */
    removeAllListeners<E extends keyof Events>(event?: E): this;
    /**
     * Removes the given event listener.
     * @param event The event for which to remove a listener.
     * @param listener The listener to remove.
     * @returns A reference to the event emitter such that calls can be chained.
     */
    removeListener<E extends keyof Events>(event: E, listener: Events[E]): this;
    /**
     * Alias for `removeListener`.
     */
    off<E extends keyof Events>(event: E, listener: Events[E]): this;
    /**
     * @returns An array listing the events for which the emitter has registered listeners.
     */
    eventNames(): (keyof Events | string | symbol)[];
    /**
     *
     * @returns The number of listeners associated to the given event.
     */
    listenerCount<E extends keyof Events>(event: E): number;
    getMaxListeners(): number;
    /**
     * By default AsyncEventEmitters print a warning if more than 10 listeners are added for a particular event.
     * This is a useful default that helps finding memory leaks.
     * This method modifies the limit for this specific AsyncEventEmitter instance.
     * The value can be set to Infinity (or 0) to indicate an unlimited number of listeners.
     * @param maxListeners
     * @returns A reference to the event emitter, so that calls can be chained.
     */
    setMaxListeners(maxListeners: number): this;
    /**
     * Wait for event queue to finish processing.
     */
    waitForProcessing(): Promise<void>;
}
export {};
