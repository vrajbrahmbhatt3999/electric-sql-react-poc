import Log from "loglevel";
const randomValue = () => {
  return Math.random().toString(16).substring(2);
};
let unsafeRandomWarned = false;
const genUUID = () => {
  if (globalThis.crypto?.randomUUID) {
    return globalThis.crypto.randomUUID();
  }
  const bytes = new Uint8Array(16);
  if (globalThis.crypto?.getRandomValues) {
    globalThis.crypto.getRandomValues(bytes);
  } else {
    if (!unsafeRandomWarned) {
      Log.debug(
        "Crypto API is not available. Falling back to Math.random for UUID generation with weak uniqueness guarantees. Provide polyfill or alternative for crypto.getRandomValues."
      );
      unsafeRandomWarned = true;
    }
    for (let i = 0; i < bytes.length; i++) {
      bytes[i] = Math.floor(Math.random() * 256);
    }
  }
  bytes[6] = bytes[6] & 15 | 64;
  bytes[8] = bytes[8] & 63 | 128;
  const hexValues = [];
  bytes.forEach((byte) => {
    hexValues.push(byte.toString(16).padStart(2, "0"));
  });
  return hexValues.slice(0, 4).join("") + "-" + hexValues.slice(4, 6).join("") + "-" + hexValues.slice(6, 8).join("") + "-" + hexValues.slice(8, 10).join("") + "-" + hexValues.slice(10).join("");
};
export {
  genUUID,
  randomValue
};
//# sourceMappingURL=random.js.map