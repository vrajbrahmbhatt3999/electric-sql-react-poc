{"version":3,"sources":["../../src/electric/adapter.ts"],"sourcesContent":["import { QualifiedTablename } from '../util/tablename'\nimport { Row, Statement } from '../util/types'\nimport { parseTableNames } from '../util'\n\nexport type UncoordinatedDatabaseAdapter = Pick<\n  DatabaseAdapter,\n  'run' | 'query' | 'runInTransaction' | 'transaction'\n>\n\n// A `DatabaseAdapter` adapts a database client to provide the\n// normalised interface defined here.\nexport interface DatabaseAdapter {\n  readonly defaultNamespace: 'main' | 'public'\n\n  // Runs the provided sql statement\n  run(statement: Statement): Promise<RunResult>\n\n  // Runs the provided sql as a transaction\n  runInTransaction(...statements: Statement[]): Promise<RunResult>\n\n  /**\n   * This method is useful to execute several queries in isolation from any other queries/transactions executed through this adapter.\n   * Useful to execute queries that cannot be executed inside a transaction (e.g. SQLite does not allow the `foreign_keys` PRAGMA to be modified in a transaction).\n   * In that case we can use this `group` method:\n   *  ```\n   *  await adapter.runExclusively(async (adapter) => {\n   *    await adapter.run({ sql: 'PRAGMA foreign_keys = OFF;' })\n   *    ...\n   *    await adapter.run({ sql: 'PRAGMA foreign_keys = ON;' })\n   *  })\n   *  ```\n   * This snippet above ensures that no other query/transaction will be interleaved when the foreign keys are disabled.\n   * @param f Function that is guaranteed to be executed in isolation from other queries/transactions executed by this adapter.\n   */\n  runExclusively<T>(\n    f: (adapter: UncoordinatedDatabaseAdapter) => Promise<T> | T\n  ): Promise<T>\n\n  // Query the database.\n  query(statement: Statement): Promise<Row[]>\n\n  /**\n   * Runs the provided __non-async__ function inside a transaction.\n   *\n   * The function may not use async/await otherwise the transaction may commit before\n   * the queries are actually executed. This is a limitation of some adapters, that the\n   * function passed to the transaction runs \"synchronously\" through callbacks without\n   * releasing the event loop.\n   */\n  transaction<T>(\n    f: (tx: Transaction, setResult: (res: T) => void) => void\n  ): Promise<T>\n\n  // Get the tables potentially used by the query (so that we\n  // can re-query if the data in them changes).\n  tableNames(statement: Statement): QualifiedTablename[]\n}\n\nexport class TableNameImpl {\n  tableNames({ sql }: Statement): QualifiedTablename[] {\n    return parseTableNames(sql)\n  }\n}\n\nexport interface Transaction {\n  run(\n    statement: Statement,\n    successCallback?: (tx: Transaction, result: RunResult) => void,\n    errorCallback?: (error: any) => void\n  ): void\n\n  query(\n    statement: Statement,\n    successCallback: (tx: Transaction, res: Row[]) => void,\n    errorCallback?: (error: any) => void\n  ): void\n}\n\nexport interface RunResult {\n  rowsAffected: number\n}\n"],"mappings":"AAEA,SAAS,uBAAuB;AAwDzB,MAAM,cAAc;AAAA,EACzB,WAAW,EAAE,IAAI,GAAoC;AACnD,WAAO,gBAAgB,GAAG;AAAA,EAC5B;AACF;","names":[]}