import pg from "pg";
import { SerialDatabaseAdapter as GenericDatabaseAdapter } from '../generic/index.js';
import { PgDateType } from '../../client/conversions/types.js';
import { deserialiseDate } from '../../client/conversions/datatypes/date.js';
const originalGetTypeParser = pg.types.getTypeParser;
class DatabaseAdapter extends GenericDatabaseAdapter {
  db;
  defaultNamespace = "public";
  constructor(db) {
    super();
    this.db = db;
  }
  async _run(statement) {
    const { rowsModified } = await this.exec(statement);
    return {
      rowsAffected: rowsModified
    };
  }
  async _query(statement) {
    const { rows } = await this.exec(statement);
    return rows;
  }
  async exec(statement) {
    try {
      const { rows, rowCount } = await this.db.query({
        text: statement.sql,
        values: statement.args,
        types: {
          getTypeParser: (oid) => {
            if (oid === pg.types.builtins.TIMESTAMP || oid === pg.types.builtins.TIMESTAMPTZ || oid === pg.types.builtins.DATE) {
              const pgTypes = /* @__PURE__ */ new Map([
                [pg.types.builtins.TIMESTAMP, PgDateType.PG_TIMESTAMP],
                [pg.types.builtins.TIMESTAMPTZ, PgDateType.PG_TIMESTAMPTZ],
                [pg.types.builtins.DATE, PgDateType.PG_DATE]
              ]);
              return (val) => deserialiseDate(val, pgTypes.get(oid));
            }
            return originalGetTypeParser(oid);
          }
        }
      });
      return {
        rows,
        rowsModified: rowCount ?? 0
      };
    } catch (e) {
      console.log("EXEC ERROR: " + e.message);
      console.log(
        "STATEMENT was: " + statement.sql + " - args: " + JSON.stringify(statement.args, null, 2)
      );
      throw e;
    }
  }
}
export {
  DatabaseAdapter
};
//# sourceMappingURL=adapter.js.map