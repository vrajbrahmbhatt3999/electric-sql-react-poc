{"version":3,"sources":["../../../src/drivers/generic/adapter.ts"],"sourcesContent":["import {\n  DatabaseAdapter as DatabaseAdapterInterface,\n  RunResult,\n  TableNameImpl,\n  Transaction as Tx,\n  UncoordinatedDatabaseAdapter,\n} from '../../electric/adapter'\nimport { Row, Statement } from '../../util'\nimport { Mutex } from 'async-mutex'\n\n/**\n * A generic database adapter.\n * Uses a mutex to ensure that transactions are not interleaved.\n * Concrete adapters extending this class must implement the\n * `_run`, `_query`, and `runInTransaction` methods.\n */\nabstract class DatabaseAdapter\n  extends TableNameImpl\n  implements DatabaseAdapterInterface\n{\n  protected txMutex: Mutex\n  abstract readonly defaultNamespace: 'main' | 'public'\n\n  constructor() {\n    super()\n    this.txMutex = new Mutex()\n  }\n\n  /**\n   * Runs a single SQL statement against the DB.\n   * @param stmt The SQL statement to execute\n   * @returns The number of rows modified by this statement.\n   */\n  abstract _run(stmt: Statement): Promise<RunResult>\n\n  /**\n   * Runs a single SQL query against the DB.\n   * @param stmt The SQL statement to execute\n   * @returns The rows read by the query.\n   */\n  abstract _query(stmt: Statement): Promise<Row[]>\n\n  /**\n   * @param statements A list of SQL statements to execute against the DB.\n   */\n  abstract _runInTransaction(...statements: Statement[]): Promise<RunResult>\n\n  async _transaction<T>(\n    f: (_tx: Tx, setResult: (res: T) => void) => void\n  ): Promise<T> {\n    await this._run({ sql: 'BEGIN' })\n\n    return new Promise<T>((resolve, reject) => {\n      const tx = new Transaction(this, reject)\n\n      f(tx, (res) => {\n        // Commit the transaction when the user sets the result.\n        // This assumes that the user does not execute any more queries after setting the result.\n        this._run({ sql: 'COMMIT' })\n          .then(() => {\n            resolve(res)\n          })\n          // Failed to commit\n          .catch(reject)\n      })\n    }).catch((err) => {\n      // something went wrong\n      // let's roll back and rethrow\n      return this._run({ sql: 'ROLLBACK' }).then(() => {\n        throw err\n      })\n    })\n  }\n\n  async transaction<T>(\n    f: (_tx: Tx, setResult: (res: T) => void) => void\n  ): Promise<T> {\n    return this.txMutex.runExclusive(() => {\n      return this._transaction(f)\n    })\n  }\n\n  run(stmt: Statement): Promise<RunResult> {\n    // Also uses the mutex to avoid running this query while a transaction is executing.\n    // Because that would make the query part of the transaction which was not the intention.\n    return this.txMutex.runExclusive(() => {\n      return this._run(stmt)\n    })\n  }\n\n  query(stmt: Statement): Promise<Row[]> {\n    // Also uses the mutex to avoid running this query while a transaction is executing.\n    // Because that would make the query part of the transaction which was not the intention.\n    return this.txMutex.runExclusive(() => {\n      return this._query(stmt)\n    })\n  }\n\n  runInTransaction(...statements: Statement[]): Promise<RunResult> {\n    return this.txMutex.runExclusive(() => {\n      return this._runInTransaction(...statements)\n    })\n  }\n\n  async _runExclusively<T>(\n    f: (adapter: UncoordinatedDatabaseAdapter) => Promise<T> | T\n  ): Promise<T> {\n    // We create an adapter that does not go through the mutex\n    // when used by the function`f`, since we already take the mutex here\n    const adapter = {\n      run: this._run.bind(this),\n      query: this._query.bind(this),\n      transaction: this._transaction.bind(this),\n      runInTransaction: this._runInTransaction.bind(this),\n    }\n    return await f(adapter)\n  }\n\n  runExclusively<T>(\n    f: (adapter: UncoordinatedDatabaseAdapter) => Promise<T> | T\n  ): Promise<T> {\n    return this.txMutex.runExclusive(() => {\n      return this._runExclusively(f)\n    })\n  }\n\n  get isLocked(): boolean {\n    return this.txMutex.isLocked()\n  }\n}\n\n/**\n * A generic database adapter that uses batch execution of SQL queries.\n * Extend this database adapter if your driver supports batch execution of SQL queries.\n */\nexport abstract class BatchDatabaseAdapter\n  extends DatabaseAdapter\n  implements DatabaseAdapterInterface\n{\n  abstract readonly defaultNamespace: 'main' | 'public'\n\n  /**\n   * @param statements SQL statements to execute against the DB in a single batch.\n   */\n  abstract execBatch(statements: Statement[]): Promise<RunResult>\n\n  async _runInTransaction(...statements: Statement[]): Promise<RunResult> {\n    return this.execBatch(statements)\n  }\n}\n\n/**\n * A generic database adapter that uses serial execution of SQL queries.\n * Extend this database adapter if your driver does not support batch execution of SQL queries.\n */\nexport abstract class SerialDatabaseAdapter\n  extends DatabaseAdapter\n  implements DatabaseAdapterInterface\n{\n  abstract readonly defaultNamespace: 'main' | 'public'\n  async _runInTransaction(...statements: Statement[]): Promise<RunResult> {\n    let transactionBegan = false\n    let rowsAffected = 0\n    try {\n      await this._run({ sql: 'BEGIN' })\n      transactionBegan = true\n      for (const stmt of statements) {\n        const { rowsAffected: rowsModified } = await this._run(stmt)\n        rowsAffected += rowsModified\n      }\n      await this._run({ sql: 'COMMIT' })\n      return {\n        rowsAffected: rowsAffected,\n      }\n    } catch (error) {\n      if (transactionBegan) {\n        await this._run({ sql: 'ROLLBACK' })\n      }\n      throw error // rejects the promise with the reason for the rollback\n    }\n  }\n}\n\nclass Transaction implements Tx {\n  constructor(\n    private adapter: DatabaseAdapter,\n    private signalFailure: (reason?: any) => void\n  ) {}\n\n  private invokeCallback<T>(\n    prom: Promise<T>,\n    successCallback?: (tx: Transaction, result: T) => void,\n    errorCallback?: (error: any) => void\n  ) {\n    prom\n      .then((res) => {\n        if (typeof successCallback !== 'undefined') successCallback(this, res)\n      })\n      .catch((err) => {\n        if (typeof errorCallback !== 'undefined') errorCallback(err)\n        this.signalFailure(err)\n      })\n  }\n\n  run(\n    statement: Statement,\n    successCallback?: (tx: Transaction, result: RunResult) => void,\n    errorCallback?: (error: any) => void\n  ): void {\n    // uses _run because we're in a transaction that already acquired the lock\n    const prom = this.adapter._run(statement)\n    this.invokeCallback(prom, successCallback, errorCallback)\n  }\n\n  query(\n    statement: Statement,\n    successCallback: (tx: Transaction, res: Row[]) => void,\n    errorCallback?: (error: any) => void\n  ): void {\n    // uses _query because we're in a transaction that already acquired the lock\n    const prom = this.adapter._query(statement)\n    this.invokeCallback(prom, successCallback, errorCallback)\n  }\n}\n"],"mappings":"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","names":[]}