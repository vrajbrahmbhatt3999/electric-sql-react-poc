{"version":3,"sources":["../../../src/drivers/better-sqlite3/adapter.ts"],"sourcesContent":["import { Mutex } from 'async-mutex'\nimport {\n  DatabaseAdapter as DatabaseAdapterInterface,\n  RunResult,\n  TableNameImpl,\n  Transaction as Tx,\n  UncoordinatedDatabaseAdapter,\n} from '../../electric/adapter'\n\nimport {\n  Statement as DbStatement,\n  Row,\n  Statement,\n  BindParams,\n} from '../../util/types'\n\nimport { Database, StatementBindParams } from './database'\n\nexport class DatabaseAdapter\n  extends TableNameImpl\n  implements DatabaseAdapterInterface\n{\n  db: Database\n  readonly defaultNamespace = 'main'\n\n  /*\n   * Even though this driver is synchronous we need to coordinate the calls through a mutex\n   * because of the `group` method which takes a function: `f: (adapter: UncoordinatedDatabaseAdapter) => Promise<void> | void`\n   * that function may call `await` which would open the possibility for another query/transaction\n   * to be interleaved with the execution of that function\n   */\n  protected txMutex: Mutex\n\n  constructor(db: Database) {\n    super()\n    this.db = db\n    this.txMutex = new Mutex()\n  }\n\n  async _runInTransaction(...statements: DbStatement[]): Promise<RunResult> {\n    const txn = this.db.transaction((stmts: DbStatement[]) => {\n      let rowsAffected = 0\n      for (const stmt of stmts) {\n        const prep = this.db.prepare(stmt.sql)\n        const res = prep.run(...wrapBindParams(stmt.args))\n        rowsAffected += res.changes // increment by the total number of rows that were inserted, updated, or deleted by this operation\n      }\n      return {\n        rowsAffected: rowsAffected,\n      }\n    })\n    return txn(statements)\n  }\n\n  async _transaction<T>(\n    f: (_tx: Tx, setResult: (res: T) => void) => void\n  ): Promise<T> {\n    let result: T\n    const txn = this.db.transaction(f)\n    txn(new WrappedTx(this.db), (res) => (result = res))\n    return result!\n  }\n\n  // Promise interface, but impl not actually async\n  async _run({ sql, args }: DbStatement): Promise<RunResult> {\n    const prep = this.db.prepare(sql)\n    const res = prep.run(...wrapBindParams(args))\n    return {\n      rowsAffected: res.changes,\n    }\n  }\n\n  // This `query` function does not enforce that the query is read-only\n  async _query({ sql, args }: DbStatement): Promise<Row[]> {\n    const stmt = this.db.prepare(sql)\n    return stmt.all(...wrapBindParams(args)) as Row[]\n  }\n\n  async _runExclusively<T>(\n    f: (adapter: UncoordinatedDatabaseAdapter) => Promise<T> | T\n  ): Promise<T> {\n    // We create an adapter that does not go through the mutex\n    // when used by the function`f`, since we already take the mutex here\n    const adapter = {\n      run: this._run.bind(this),\n      query: this._query.bind(this),\n      transaction: this._transaction.bind(this),\n      runInTransaction: this._runInTransaction.bind(this),\n    }\n    return f(adapter)\n  }\n\n  async runInTransaction(...statements: DbStatement[]): Promise<RunResult> {\n    return this.txMutex.runExclusive(() => {\n      return this._runInTransaction(...statements)\n    })\n  }\n\n  async transaction<T>(\n    f: (_tx: Tx, setResult: (res: T) => void) => void\n  ): Promise<T> {\n    return this.txMutex.runExclusive(() => {\n      return this._transaction(f)\n    })\n  }\n\n  async run(stmt: Statement): Promise<RunResult> {\n    return this.txMutex.runExclusive(() => {\n      return this._run(stmt)\n    })\n  }\n\n  async query(stmt: Statement): Promise<Row[]> {\n    return this.txMutex.runExclusive(() => {\n      return this._query(stmt)\n    })\n  }\n\n  async runExclusively<T>(\n    f: (adapter: UncoordinatedDatabaseAdapter) => Promise<T> | T\n  ): Promise<T> {\n    return this.txMutex.runExclusive(() => {\n      return this._runExclusively(f)\n    })\n  }\n}\n\nfunction wrapBindParams(x: BindParams | undefined): StatementBindParams {\n  if (x && Array.isArray(x)) {\n    return x\n  } else if (x) {\n    return [x]\n  } else {\n    return []\n  }\n}\n\nclass WrappedTx implements Tx {\n  constructor(private db: Database) {}\n\n  run(\n    { sql, args }: Statement,\n    successCallback?: (tx: WrappedTx, res: RunResult) => void,\n    errorCallback?: (error: any) => void\n  ): void {\n    try {\n      const prep = this.db.prepare(sql)\n      const res = prep.run(...wrapBindParams(args))\n      if (typeof successCallback !== 'undefined')\n        successCallback(this, { rowsAffected: res.changes })\n    } catch (err) {\n      if (typeof errorCallback !== 'undefined') errorCallback(err)\n      throw err // makes the transaction fail (needed to have consistent behavior with react-native and expo drivers which also fail if one of the statements fail)\n    }\n  }\n\n  query(\n    { sql, args }: Statement,\n    successCallback: (tx: WrappedTx, res: Row[]) => void,\n    errorCallback?: (error: any) => void\n  ): void {\n    try {\n      const stmt = this.db.prepare(sql)\n      const rows = stmt.all(...wrapBindParams(args)) as Row[]\n      successCallback(this, rows)\n    } catch (err) {\n      if (typeof errorCallback !== 'undefined') errorCallback(err)\n      throw err // makes the transaction fail (needed to have consistent behavior with react-native and expo drivers which also fail if one of the statements fail)\n    }\n  }\n}\n"],"mappings":"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","names":[]}