{"version":3,"sources":["../../../src/drivers/wa-sqlite/database.ts"],"sourcesContent":["// Import the asynchronous WASM build because we will be using IndexedDB\n// which is an async Virtual File System (VFS).\nimport SQLiteAsyncESMFactory from 'wa-sqlite/dist/wa-sqlite-async.mjs'\n\nimport * as SQLite from 'wa-sqlite'\n\n// This is the recommended IndexedDB VFS\n// It is preferable over OPFS because OPFS works only in a worker\n// and is not yet supported on all browsers\n// see: https://github.com/rhashimoto/wa-sqlite/tree/master/src/examples\nimport { IDBBatchAtomicVFS } from 'wa-sqlite/src/examples/IDBBatchAtomicVFS.js'\n\nimport { SqlValue, Statement } from '../../util'\nimport { Row } from '../../util/types'\n\nimport { Mutex } from 'async-mutex'\nimport { resultToRows } from '../util/results'\n\nexport type Database = Pick<\n  ElectricDatabase,\n  'name' | 'exec' | 'getRowsModified'\n>\n\nexport class ElectricDatabase {\n  #mutex: Mutex\n\n  // Do not use this constructor directly.\n  // Create a Database instance using the static `init` method instead.\n  private constructor(\n    public name: string,\n    private sqlite3: SQLiteAPI,\n    private db: number\n  ) {\n    this.#mutex = new Mutex()\n  }\n\n  async exec(statement: Statement): Promise<Row[]> {\n    // Uses a mutex to ensure that the execution of SQL statements is not interleaved\n    // otherwise wa-sqlite may encounter problems such as indices going out of bounds\n    // all calls to wa-sqlite need to be coordinated through this mutex\n    const release = await this.#mutex.acquire()\n    try {\n      // Need to wrap all sqlite statements in a try..finally block\n      // that releases the lock at the very end, even if an error occurs\n      return await this.execSql(statement)\n    } finally {\n      release()\n    }\n  }\n\n  // Calls to this method must always be coordinated through the mutex\n  private async execSql(statement: Statement): Promise<Row[]> {\n    // `statements` is a convenience function that manages statement compilation\n    // such that we don't have to prepare and finalize statements ourselves\n    // cf. https://rhashimoto.github.io/wa-sqlite/docs/interfaces/SQLiteAPI.html#statements\n    for await (const stmt of this.sqlite3.statements(this.db, statement.sql)) {\n      if (typeof statement.args !== 'undefined') {\n        this.sqlite3.bind_collection(\n          stmt,\n          statement.args as\n            | { [index: string]: SQLiteCompatibleType }\n            | SQLiteCompatibleType[]\n        )\n      }\n      const rows: SqlValue[][] = []\n      let cols: string[] = []\n      while ((await this.sqlite3.step(stmt)) === SQLite.SQLITE_ROW) {\n        cols = cols.length === 0 ? this.sqlite3.column_names(stmt) : cols\n        const row = this.sqlite3.row(stmt) as SqlValue[]\n        rows.push(row)\n      }\n      const res = {\n        columns: cols,\n        values: rows,\n      }\n      return resultToRows(res) // exit loop after one statement\n    }\n    return [] // will get here only if there is no statement\n  }\n\n  getRowsModified() {\n    return this.sqlite3.changes(this.db)\n  }\n\n  // Creates and opens a DB backed by an IndexedDB filesystem\n  static async init(\n    dbName: string,\n    locateSqliteDist?: string | ((path: string) => string)\n  ) {\n    // Initialize SQLite\n    const locateFile =\n      typeof locateSqliteDist === 'string'\n        ? (path: string) => {\n            return locateSqliteDist + path\n          }\n        : locateSqliteDist\n\n    const SQLiteAsyncModule = await SQLiteAsyncESMFactory({ locateFile })\n\n    // Build API objects for the module\n    const sqlite3 = SQLite.Factory(SQLiteAsyncModule)\n\n    // Register a Virtual File System with the SQLite runtime\n    sqlite3.vfs_register(new IDBBatchAtomicVFS(dbName))\n\n    // Open the DB connection\n    // see: https://rhashimoto.github.io/wa-sqlite/docs/interfaces/SQLiteAPI.html#open_v2\n    const db = await sqlite3.open_v2(\n      dbName,\n      SQLite.SQLITE_OPEN_CREATE | SQLite.SQLITE_OPEN_READWRITE,\n      dbName\n    )\n\n    return new ElectricDatabase(dbName, sqlite3, db)\n  }\n}\n"],"mappings":"AAEA,OAAO,2BAA2B;AAElC,YAAY,YAAY;AAMxB,SAAS,yBAAyB;AAKlC,SAAS,aAAa;AACtB,SAAS,oBAAoB;AAOtB,MAAM,iBAAiB;AAAA;AAAA;AAAA,EAKpB,YACC,MACC,SACA,IACR;AAHO;AACC;AACA;AAER,SAAK,SAAS,IAAI,MAAM;AAAA,EAC1B;AAAA,EAVA;AAAA,EAYA,MAAM,KAAK,WAAsC;AAI/C,UAAM,UAAU,MAAM,KAAK,OAAO,QAAQ;AAC1C,QAAI;AAGF,aAAO,MAAM,KAAK,QAAQ,SAAS;AAAA,IACrC,UAAE;AACA,cAAQ;AAAA,IACV;AAAA,EACF;AAAA;AAAA,EAGA,MAAc,QAAQ,WAAsC;AAI1D,qBAAiB,QAAQ,KAAK,QAAQ,WAAW,KAAK,IAAI,UAAU,GAAG,GAAG;AACxE,UAAI,OAAO,UAAU,SAAS,aAAa;AACzC,aAAK,QAAQ;AAAA,UACX;AAAA,UACA,UAAU;AAAA,QAGZ;AAAA,MACF;AACA,YAAM,OAAqB,CAAC;AAC5B,UAAI,OAAiB,CAAC;AACtB,aAAQ,MAAM,KAAK,QAAQ,KAAK,IAAI,MAAO,OAAO,YAAY;AAC5D,eAAO,KAAK,WAAW,IAAI,KAAK,QAAQ,aAAa,IAAI,IAAI;AAC7D,cAAM,MAAM,KAAK,QAAQ,IAAI,IAAI;AACjC,aAAK,KAAK,GAAG;AAAA,MACf;AACA,YAAM,MAAM;AAAA,QACV,SAAS;AAAA,QACT,QAAQ;AAAA,MACV;AACA,aAAO,aAAa,GAAG;AAAA,IACzB;AACA,WAAO,CAAC;AAAA,EACV;AAAA,EAEA,kBAAkB;AAChB,WAAO,KAAK,QAAQ,QAAQ,KAAK,EAAE;AAAA,EACrC;AAAA;AAAA,EAGA,aAAa,KACX,QACA,kBACA;AAEA,UAAM,aACJ,OAAO,qBAAqB,WACxB,CAAC,SAAiB;AAChB,aAAO,mBAAmB;AAAA,IAC5B,IACA;AAEN,UAAM,oBAAoB,MAAM,sBAAsB,EAAE,WAAW,CAAC;AAGpE,UAAM,UAAU,OAAO,QAAQ,iBAAiB;AAGhD,YAAQ,aAAa,IAAI,kBAAkB,MAAM,CAAC;AAIlD,UAAM,KAAK,MAAM,QAAQ;AAAA,MACvB;AAAA,MACA,OAAO,qBAAqB,OAAO;AAAA,MACnC;AAAA,IACF;AAEA,WAAO,IAAI,iBAAiB,QAAQ,SAAS,EAAE;AAAA,EACjD;AACF;","names":[]}