{"version":3,"sources":["../../../src/auth/secure/index.ts"],"sourcesContent":["import { jwtDecode, JwtPayload } from '../decode'\nimport { textEncoder } from '../../util/encoders'\nimport { TokenClaims } from '../index'\nimport { InvalidArgumentError } from '../../client/validation/errors/invalidArgumentError'\n\nexport async function secureAuthToken(opts: {\n  claims: TokenClaims\n  iss: string\n  key: string\n  alg?: string\n  exp?: string\n}): Promise<string> {\n  const { SignJWT } = await import('jose')\n  const algorithm = opts.alg ?? 'HS256'\n  const expiration = opts.exp ?? '2h'\n  const iat = Math.floor(Date.now() / 1000)\n\n  const encodedKey = textEncoder.encode(opts.key)\n\n  return new SignJWT({ ...opts.claims, type: 'access' })\n    .setIssuedAt(iat)\n    .setProtectedHeader({ alg: algorithm })\n    .setExpirationTime(expiration)\n    .setIssuer(opts.iss)\n    .sign(encodedKey)\n}\n\nexport function mockSecureAuthToken(\n  exp?: string,\n  iss?: string,\n  key?: string\n): Promise<string> {\n  const mockIss = iss ?? 'dev.electric-sql.com'\n  const mockKey = key ?? 'integration-tests-signing-key-example'\n\n  return secureAuthToken({\n    claims: { sub: 'test-user' },\n    iss: mockIss,\n    key: mockKey,\n    exp,\n  })\n}\n\nexport function decodeToken(\n  token: string\n): JwtPayload & ({ sub: string } | { user_id: string }) {\n  const decoded = jwtDecode(token)\n  if (\n    typeof decoded.sub === 'undefined' &&\n    typeof decoded.user_id === 'undefined'\n  ) {\n    throw new InvalidArgumentError(\n      'Token does not contain a sub or user_id claim'\n    )\n  }\n\n  return decoded as JwtPayload & ({ sub: string } | { user_id: string })\n}\n\n/**\n * Retrieves the user ID encoded in the JWT token\n * @param token the encoded JWT token\n * @returns {Uuid} the user ID found in the `sub` or `user_id` claim\n */\nexport function decodeUserIdFromToken(token: string): string {\n  const decoded = decodeToken(token)\n\n  // `sub` is the standard claim, but `user_id` is also used in the Electric service\n  // We first check for sub, and if it's not present, we use user_id\n  return (decoded.sub ?? decoded.user_id) as string\n}\n"],"mappings":"AAAA,SAAS,iBAA6B;AACtC,SAAS,mBAAmB;AAE5B,SAAS,4BAA4B;AAErC,eAAsB,gBAAgB,MAMlB;AAClB,QAAM,EAAE,QAAQ,IAAI,MAAM,OAAO,MAAM;AACvC,QAAM,YAAY,KAAK,OAAO;AAC9B,QAAM,aAAa,KAAK,OAAO;AAC/B,QAAM,MAAM,KAAK,MAAM,KAAK,IAAI,IAAI,GAAI;AAExC,QAAM,aAAa,YAAY,OAAO,KAAK,GAAG;AAE9C,SAAO,IAAI,QAAQ,EAAE,GAAG,KAAK,QAAQ,MAAM,SAAS,CAAC,EAClD,YAAY,GAAG,EACf,mBAAmB,EAAE,KAAK,UAAU,CAAC,EACrC,kBAAkB,UAAU,EAC5B,UAAU,KAAK,GAAG,EAClB,KAAK,UAAU;AACpB;AAEO,SAAS,oBACd,KACA,KACA,KACiB;AACjB,QAAM,UAAU,OAAO;AACvB,QAAM,UAAU,OAAO;AAEvB,SAAO,gBAAgB;AAAA,IACrB,QAAQ,EAAE,KAAK,YAAY;AAAA,IAC3B,KAAK;AAAA,IACL,KAAK;AAAA,IACL;AAAA,EACF,CAAC;AACH;AAEO,SAAS,YACd,OACsD;AACtD,QAAM,UAAU,UAAU,KAAK;AAC/B,MACE,OAAO,QAAQ,QAAQ,eACvB,OAAO,QAAQ,YAAY,aAC3B;AACA,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAOO,SAAS,sBAAsB,OAAuB;AAC3D,QAAM,UAAU,YAAY,KAAK;AAIjC,SAAQ,QAAQ,OAAO,QAAQ;AACjC;","names":[]}