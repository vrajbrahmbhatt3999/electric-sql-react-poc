import { jwtDecode } from '../decode.js';
import { textEncoder } from '../../util/encoders/index.js';
import { InvalidArgumentError } from '../../client/validation/errors/invalidArgumentError.js';
async function secureAuthToken(opts) {
  const { SignJWT } = await import("jose");
  const algorithm = opts.alg ?? "HS256";
  const expiration = opts.exp ?? "2h";
  const iat = Math.floor(Date.now() / 1e3);
  const encodedKey = textEncoder.encode(opts.key);
  return new SignJWT({ ...opts.claims, type: "access" }).setIssuedAt(iat).setProtectedHeader({ alg: algorithm }).setExpirationTime(expiration).setIssuer(opts.iss).sign(encodedKey);
}
function mockSecureAuthToken(exp, iss, key) {
  const mockIss = iss ?? "dev.electric-sql.com";
  const mockKey = key ?? "integration-tests-signing-key-example";
  return secureAuthToken({
    claims: { sub: "test-user" },
    iss: mockIss,
    key: mockKey,
    exp
  });
}
function decodeToken(token) {
  const decoded = jwtDecode(token);
  if (typeof decoded.sub === "undefined" && typeof decoded.user_id === "undefined") {
    throw new InvalidArgumentError(
      "Token does not contain a sub or user_id claim"
    );
  }
  return decoded;
}
function decodeUserIdFromToken(token) {
  const decoded = decodeToken(token);
  return decoded.sub ?? decoded.user_id;
}
export {
  decodeToken,
  decodeUserIdFromToken,
  mockSecureAuthToken,
  secureAuthToken
};
//# sourceMappingURL=index.js.map