{"version":3,"sources":["../../../../src/frameworks/vuejs/reactive/useLiveQuery.ts"],"sourcesContent":["import {\n  watch,\n  WatchSource,\n  Ref,\n  computed,\n  readonly,\n  DeepReadonly,\n  shallowReactive,\n  onUnmounted,\n  toRefs,\n  ToRefs,\n  isRef,\n  shallowRef,\n  unref,\n} from 'vue'\nimport {\n  LiveResultContext,\n  LiveResultUpdate,\n} from '../../../client/model/model'\nimport { hash } from 'ohash'\nimport { UnsubscribeFunction } from '../../../notifiers'\n\n/**\n * Main reactive query method for Vue applications. It can be\n * used in tandem with {@link makeElectricDependencyInjector}\n * which injects an {@link ElectricClient} into the component\n * tree in order to be able to form live queries.\n *\n * The provided query will not update reactively, so if you want\n * the query itself to respond to changes make sure to use the\n * form that takes a Ref or live query getter as an argument\n *\n * @param runQuery - a static live query.\n * @param runQueryDependencies - Optional list of dependencies that\n *    will cause the query to rerun\n *\n * @example Using a simple live query. The table will depend on your application\n * ```ts\n * const { results } = useLiveQuery(db.items.liveMany({}))\n * ```\n */\nfunction useLiveQuery<Res>(\n  runQuery: LiveResultContext<Res>,\n  runQueryDependencies?: WatchSource[]\n): ToRefs<DeepReadonly<LiveResultUpdate<Res>>>\n\n/**\n * Main reactive query method for Vue applications. It can be\n * used in tandem with {@link makeElectricDependencyInjector}\n * which injects an {@link ElectricClient} into the component\n * tree in order to be able to form live queries.\n *\n * You can provide a reference to or getter for a live query, and\n * the query results will update with the query reactively.\n *\n * Providing a list of dependencies will cause the query to rerun\n * reactively only based on those dependencies, and not on the\n * query itself.\n *\n * @param runQueryRef - a reference to or getter for a live query\n * @param runQueryDependencies - Optional list of dependencies that\n *    will cause the query to rerun - if provided, the the reactivity\n *    of the query reference itself will not cause it to rerun\n *\n * @example Using a simple live query with a dependency. The table will depend on your application\n * ```ts\n * const limit = ref(5)\n * const { results } = useLiveQuery(() => db.items.liveMany({ take: limit }))\n * ```\n */\nfunction useLiveQuery<Res>(\n  runQueryRef: Ref<LiveResultContext<Res>> | (() => LiveResultContext<Res>),\n  runQueryDependencies?: WatchSource[]\n): ToRefs<DeepReadonly<LiveResultUpdate<Res>>>\n\nfunction useLiveQuery<Res>(\n  runQuery:\n    | LiveResultContext<Res>\n    | Ref<LiveResultContext<Res>>\n    | (() => LiveResultContext<Res>),\n  runQueryDependencies?: WatchSource[]\n): ToRefs<DeepReadonly<LiveResultUpdate<Res>>> {\n  if ('sourceQuery' in runQuery) {\n    return useLiveQueryWithRef(shallowRef(runQuery), runQueryDependencies)\n  }\n\n  if (isRef(runQuery)) {\n    return useLiveQueryWithRef(runQuery, runQueryDependencies)\n  }\n\n  return useLiveQueryWithRef(\n    computed(runQuery as () => LiveResultContext<Res>),\n    runQueryDependencies\n  )\n}\n\nfunction useLiveQueryWithRef<Res>(\n  runQueryRef: Ref<LiveResultContext<Res>>,\n  runQueryDependencies?: WatchSource[]\n): ToRefs<DeepReadonly<LiveResultUpdate<Res>>> {\n  // if dependencies are specified, only rerun using those\n  if (runQueryDependencies) {\n    return useLiveQueryWithQueryUpdates(runQueryRef, runQueryDependencies)\n  }\n\n  // ensure that we re-subscribe to the query if the hash changes, regardless\n  // of how the reference is structured\n  const queryHash = computed(() => hash(unref(runQueryRef).sourceQuery))\n  return useLiveQueryWithQueryUpdates(runQueryRef, [runQueryRef, queryHash])\n}\n\nfunction useLiveQueryWithQueryUpdates<Res>(\n  runQuery: Ref<LiveResultContext<Res>>,\n  runQueryDependencies: WatchSource[]\n): ToRefs<DeepReadonly<LiveResultUpdate<Res>>> {\n  const liveUpdate = shallowReactive<LiveResultUpdate<Res>>({\n    results: undefined,\n    error: undefined,\n    updatedAt: undefined,\n  })\n\n  // keep track of subscriptions and unsubscribe from unused ones\n  const unsubscribeRef = shallowRef<UnsubscribeFunction>()\n\n  watch(\n    runQueryDependencies,\n    () => {\n      unsubscribeRef.value?.()\n      unsubscribeRef.value = unref(runQuery).subscribe((newResults) => {\n        liveUpdate.results = newResults.results\n        liveUpdate.error = newResults.error\n        liveUpdate.updatedAt = newResults.updatedAt\n      })\n    },\n    { immediate: true }\n  )\n\n  onUnmounted(() => unsubscribeRef.value?.())\n\n  return toRefs(readonly(liveUpdate))\n}\n\nexport default useLiveQuery\n"],"mappings":"AAAA;AAAA,EACE;AAAA,EAGA;AAAA,EACA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAKP,SAAS,YAAY;AAwDrB,SAAS,aACP,UAIA,sBAC6C;AAC7C,MAAI,iBAAiB,UAAU;AAC7B,WAAO,oBAAoB,WAAW,QAAQ,GAAG,oBAAoB;AAAA,EACvE;AAEA,MAAI,MAAM,QAAQ,GAAG;AACnB,WAAO,oBAAoB,UAAU,oBAAoB;AAAA,EAC3D;AAEA,SAAO;AAAA,IACL,SAAS,QAAwC;AAAA,IACjD;AAAA,EACF;AACF;AAEA,SAAS,oBACP,aACA,sBAC6C;AAE7C,MAAI,sBAAsB;AACxB,WAAO,6BAA6B,aAAa,oBAAoB;AAAA,EACvE;AAIA,QAAM,YAAY,SAAS,MAAM,KAAK,MAAM,WAAW,EAAE,WAAW,CAAC;AACrE,SAAO,6BAA6B,aAAa,CAAC,aAAa,SAAS,CAAC;AAC3E;AAEA,SAAS,6BACP,UACA,sBAC6C;AAC7C,QAAM,aAAa,gBAAuC;AAAA,IACxD,SAAS;AAAA,IACT,OAAO;AAAA,IACP,WAAW;AAAA,EACb,CAAC;AAGD,QAAM,iBAAiB,WAAgC;AAEvD;AAAA,IACE;AAAA,IACA,MAAM;AACJ,qBAAe,QAAQ;AACvB,qBAAe,QAAQ,MAAM,QAAQ,EAAE,UAAU,CAAC,eAAe;AAC/D,mBAAW,UAAU,WAAW;AAChC,mBAAW,QAAQ,WAAW;AAC9B,mBAAW,YAAY,WAAW;AAAA,MACpC,CAAC;AAAA,IACH;AAAA,IACA,EAAE,WAAW,KAAK;AAAA,EACpB;AAEA,cAAY,MAAM,eAAe,QAAQ,CAAC;AAE1C,SAAO,OAAO,SAAS,UAAU,CAAC;AACpC;AAEA,IAAO,uBAAQ;","names":[]}