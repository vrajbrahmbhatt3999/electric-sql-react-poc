import { ShallowRef } from 'vue';
import { ElectricClient } from '../../client/model/client.js';
import { DbSchema } from '../../client/model/index.js';
interface ElectricDependencyInjection<S extends ElectricClient<DbSchema<any>>> {
    provideElectric: (electric: ShallowRef<S | undefined> | (S | undefined)) => void;
    injectElectric: () => S | undefined;
}
/**
 * Call this function to get an Electric provider and injector for your Vue application.
 * We can't provide a predefined provider and injector because that would lose type information
 * as the types depend on the type of the database `S` that's provided as a type argument.
 *
 * @example
 * This example loses information about the concrete DB tables:
 * ```
 * provide<ElectricClient>(ElectricKey, electric)
 *
 * // generic DB type, no type-safe client
 * const { db } = inject(ElectricKey)
 * ```
 *
 * @returns An object with two functions: `provideElectric` and `injectElectric`.
 *
 */
export declare function makeElectricDependencyInjector<S extends ElectricClient<DbSchema<any>>>(): ElectricDependencyInjection<S>;
/**
 * This "static" injector is used internally by our reactive methods
 * to get access to the {@link ElectricClient}.
 * It loses information about the actual types of the DB tables,
 * but we don't need that information in our methods.
 * However, users preferably don't lose this type information,
 * therefore, they can use {@link makeElectricDependencyInjector}.
 */
declare const injectElectricUntyped: () => ElectricClient<DbSchema<any>> | undefined;
export { injectElectricUntyped };
