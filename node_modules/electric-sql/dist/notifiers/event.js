import { EventEmitter } from "events";
import Log from "loglevel";
const EVENT_NAMES = {
  authChange: "auth:changed",
  actualDataChange: "data:actually:changed",
  potentialDataChange: "data:potentially:changed",
  connectivityStateChange: "network:connectivity:changed",
  shapeSubscriptionStatusChange: "shape:status:changed"
};
const globalEmitter = new EventEmitter().setMaxListeners(Infinity);
class EventNotifier {
  dbName;
  attachedDbIndex;
  events;
  constructor(dbName, eventEmitter) {
    this.dbName = dbName;
    this.attachedDbIndex = {
      byAlias: {},
      byName: {}
    };
    this.events = eventEmitter !== void 0 ? eventEmitter : globalEmitter;
  }
  attach(dbName, dbAlias) {
    const idx = this.attachedDbIndex;
    idx.byAlias[dbAlias] = dbName;
    idx.byName[dbName] = dbAlias;
  }
  detach(dbAlias) {
    const idx = this.attachedDbIndex;
    if (dbAlias in idx.byAlias) {
      const dbName = idx.byAlias[dbAlias];
      delete idx.byAlias[dbAlias];
      delete idx.byName[dbName];
    }
  }
  alias({ dbName, changes }) {
    const idx = this.attachedDbIndex;
    const primaryDbName = this.dbName;
    return changes.map(({ qualifiedTablename }) => {
      if (dbName === primaryDbName) {
        return qualifiedTablename;
      }
      const dbAlias = idx.byName[dbName];
      if (dbAlias !== void 0) {
        qualifiedTablename.namespace = dbAlias;
        return qualifiedTablename;
      }
    }).filter((value) => value !== void 0);
  }
  authStateChanged(authState) {
    this._emitAuthStateChange(authState);
  }
  subscribeToAuthStateChanges(callback) {
    this._subscribe(EVENT_NAMES.authChange, callback);
    return () => {
      this._unsubscribe(EVENT_NAMES.authChange, callback);
    };
  }
  potentiallyChanged() {
    const dbNames = this._getDbNames();
    const emitPotentialChange = this._emitPotentialChange.bind(this);
    dbNames.forEach(emitPotentialChange);
  }
  actuallyChanged(dbName, changes, origin) {
    if (!this._hasDbName(dbName) || !changes.length) {
      return;
    }
    const tables = [
      ...new Set(
        changes.map((e) => {
          return e.qualifiedTablename.tablename;
        })
      )
    ];
    Log.info(
      `notifying client of database changes. Changed tables: [${tables}]. Origin: ${origin}`
    );
    this._emitActualChange(dbName, changes, origin);
  }
  subscribeToPotentialDataChanges(callback) {
    const thisHasDbName = this._hasDbName.bind(this);
    const wrappedCallback = (notification) => {
      if (thisHasDbName(notification.dbName)) {
        callback(notification);
      }
    };
    this._subscribe(EVENT_NAMES.potentialDataChange, wrappedCallback);
    return () => {
      this._unsubscribe(EVENT_NAMES.potentialDataChange, wrappedCallback);
    };
  }
  subscribeToDataChanges(callback) {
    const thisHasDbName = this._hasDbName.bind(this);
    const wrappedCallback = (notification) => {
      if (thisHasDbName(notification.dbName)) {
        callback(notification);
      }
    };
    this._subscribe(EVENT_NAMES.actualDataChange, wrappedCallback);
    return () => {
      this._unsubscribe(EVENT_NAMES.actualDataChange, wrappedCallback);
    };
  }
  connectivityStateChanged(dbName, status) {
    if (!this._hasDbName(dbName)) {
      return;
    }
    this._emitConnectivityStatus(dbName, status);
  }
  subscribeToConnectivityStateChanges(callback) {
    const thisHasDbName = this._hasDbName.bind(this);
    const wrappedCallback = (notification) => {
      if (thisHasDbName(notification.dbName)) {
        callback(notification);
      }
    };
    this._subscribe(EVENT_NAMES.connectivityStateChange, wrappedCallback);
    return () => {
      this._unsubscribe(EVENT_NAMES.connectivityStateChange, wrappedCallback);
    };
  }
  shapeSubscriptionSyncStatusChanged(dbName, key, status) {
    if (!this._hasDbName(dbName)) {
      return;
    }
    this._emitShapeSubscriptionSyncStatusChange(dbName, key, status);
  }
  subscribeToShapeSubscriptionSyncStatusChanges(callback) {
    const thisHasDbName = this._hasDbName.bind(this);
    const wrappedCallback = (notification) => {
      if (thisHasDbName(notification.dbName)) {
        callback(notification);
      }
    };
    this._subscribe(EVENT_NAMES.shapeSubscriptionStatusChange, wrappedCallback);
    return () => {
      this._unsubscribe(
        EVENT_NAMES.shapeSubscriptionStatusChange,
        wrappedCallback
      );
    };
  }
  _getDbNames() {
    const idx = this.attachedDbIndex;
    return [this.dbName, ...Object.keys(idx.byName)];
  }
  _hasDbName(dbName) {
    const idx = this.attachedDbIndex;
    return dbName === this.dbName || dbName in idx.byName;
  }
  // Extracting out these methods allows them to be overridden
  // without duplicating any dbName filter / check logic, etc.
  _emitAuthStateChange(authState) {
    const notification = {
      authState
    };
    this._emit(EVENT_NAMES.authChange, notification);
    return notification;
  }
  _emitPotentialChange(dbName) {
    const notification = {
      dbName
    };
    this._emit(EVENT_NAMES.potentialDataChange, notification);
    return notification;
  }
  _emitActualChange(dbName, changes, origin) {
    const notification = {
      dbName,
      changes,
      origin
    };
    this._emit(EVENT_NAMES.actualDataChange, notification);
    return notification;
  }
  _emitConnectivityStatus(dbName, connectivityState) {
    const notification = {
      dbName,
      connectivityState
    };
    this._emit(EVENT_NAMES.connectivityStateChange, notification);
    return notification;
  }
  _emitShapeSubscriptionSyncStatusChange(dbName, key, status) {
    const notification = { dbName, key, status };
    this._emit(EVENT_NAMES.shapeSubscriptionStatusChange, notification);
    return notification;
  }
  _emit(eventName, notification) {
    this.events.emit(eventName, notification);
  }
  _subscribe(eventName, callback) {
    this.events.addListener(eventName, callback);
  }
  _unsubscribe(eventName, callback) {
    this.events.removeListener(eventName, callback);
  }
}
export {
  EVENT_NAMES,
  EventNotifier
};
//# sourceMappingURL=event.js.map