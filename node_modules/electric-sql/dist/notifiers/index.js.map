{"version":3,"sources":["../../src/notifiers/index.ts"],"sourcesContent":["import { AuthState } from '../auth/index'\nimport { SyncStatus } from '../client/model/shapes'\nimport { QualifiedTablename } from '../util/tablename'\nimport {\n  ConnectivityState,\n  DbName,\n  RowId,\n  DataChangeType,\n  DbRecord,\n} from '../util/types'\n\nexport { EventNotifier } from './event'\nexport { MockNotifier } from './mock'\n\nexport interface AuthStateNotification {\n  authState: AuthState\n}\n\nexport type RecordChange = {\n  primaryKey: DbRecord\n  type: `${DataChangeType}` | 'INITIAL'\n}\nexport interface Change {\n  qualifiedTablename: QualifiedTablename\n  rowids?: RowId[] // rowid of each oplog entry for the changes - availiable only for local changes\n  recordChanges?: RecordChange[]\n}\nexport type ChangeOrigin = 'local' | 'remote' | 'initial'\nexport interface ChangeNotification {\n  dbName: DbName\n  changes: Change[]\n  origin: ChangeOrigin\n}\nexport interface PotentialChangeNotification {\n  dbName: DbName\n}\n\nexport interface ConnectivityStateChangeNotification {\n  dbName: DbName\n  connectivityState: ConnectivityState\n}\n\nexport interface ShapeSubscriptionSyncStatusChangeNotification {\n  dbName: DbName\n  key: string\n  status: SyncStatus\n}\n\nexport type Notification =\n  | AuthStateNotification\n  | ChangeNotification\n  | PotentialChangeNotification\n  | ConnectivityStateChangeNotification\n  | ShapeSubscriptionSyncStatusChangeNotification\n\nexport type AuthStateCallback = (notification: AuthStateNotification) => void\nexport type ChangeCallback = (notification: ChangeNotification) => void\nexport type PotentialChangeCallback = (\n  notification: PotentialChangeNotification\n) => void\nexport type ConnectivityStateChangeCallback = (\n  notification: ConnectivityStateChangeNotification\n) => void\n\nexport type ShapeSubscriptionSyncStatusChangeCallback = (\n  notification: ShapeSubscriptionSyncStatusChangeNotification\n) => void\n\nexport type NotificationCallback =\n  | AuthStateCallback\n  | ChangeCallback\n  | PotentialChangeCallback\n  | ConnectivityStateChangeCallback\n  | ShapeSubscriptionSyncStatusChangeCallback\n\nexport type UnsubscribeFunction = () => void\n\nexport interface Notifier {\n  // The name of the primary database that components communicating via this\n  // notifier have open and are using.\n  dbName: DbName\n\n  // Some drivers can attach other open databases and reference them by alias\n  // (i.e.: first you `attach('foo.db')` then you can write SQL queries like\n  // `select * from foo.bars`. We keep track of attached databases and their\n  // aliases, so we can map the table namespaces in SQL queries to their real\n  // database names and thus emit and handle notifications to and from them.\n  attach(dbName: DbName, dbAlias: string): void\n  detach(dbAlias: string): void\n\n  // Technically, we keep track of the attached dbs in two mappings -- one is\n  // `alias: name`, the other `name: alias`.\n  attachedDbIndex: {\n    byAlias: {\n      [key: string]: DbName\n    }\n    byName: {\n      [key: DbName]: string\n    }\n  }\n\n  // And we provide a helper method to alias changes in the form\n  // `{attachedDbName, tablenames}` to `aliasedTablenames`.\n  alias(notification: ChangeNotification): QualifiedTablename[]\n\n  // Calling `authStateChanged` notifies the Satellite process that the\n  // user's authentication credentials have changed.\n  authStateChanged(authState: AuthState): void\n  subscribeToAuthStateChanges(callback: AuthStateCallback): UnsubscribeFunction\n\n  // The data change notification workflow starts by the electric database\n  // clients (or the user manually) calling `potentiallyChanged` whenever\n  // a write or transaction has been issued that may have changed the\n  // contents of either the primary or any of the attached databases.\n  potentiallyChanged(): void\n\n  // Satellite processes subscribe to these \"data has potentially changed\"\n  // notifications. When they get one, they check the `_oplog` table in the\n  // database for *actual* changes persisted by the triggers.\n  subscribeToPotentialDataChanges(\n    callback: PotentialChangeCallback\n  ): UnsubscribeFunction\n\n  // When Satellite detects actual data changes in the oplog for a given\n  // database, it replicates it and calls  `actuallyChanged` with the list\n  // of changes.\n  actuallyChanged(dbName: DbName, changes: Change[], origin: ChangeOrigin): void\n\n  // Reactive hooks then subscribe to \"data has actually changed\" notifications,\n  // using the info to trigger re-queries, if the changes affect databases and\n  // tables that their queries depend on. This then trigger re-rendering if\n  // the query results are actually affected by the data changes.\n  subscribeToDataChanges(callback: ChangeCallback): UnsubscribeFunction\n\n  // Notification for network connectivity state changes.\n  // A connectivity change is automatically triggered in consequence of internal client events.\n  // 'connected': connection to Electric established\n  // 'disconnected': Electric is unreachable, or network is unavailable.\n  //                 A reason for the disconnection can be provided.\n  connectivityStateChanged(dbName: string, state: ConnectivityState): void\n\n  subscribeToConnectivityStateChanges(\n    callback: ConnectivityStateChangeCallback\n  ): UnsubscribeFunction\n\n  // Notification for shape subscription sync status changes.\n  // Every notification will include a key that uniquely identifies the\n  // shape for which the sync status changed, as well as the new sync status.\n  shapeSubscriptionSyncStatusChanged(\n    dbName: DbName,\n    key: string,\n    status: SyncStatus\n  ): void\n\n  subscribeToShapeSubscriptionSyncStatusChanges(\n    callback: ShapeSubscriptionSyncStatusChangeCallback\n  ): UnsubscribeFunction\n}\n"],"mappings":"AAWA,SAAS,qBAAqB;AAC9B,SAAS,oBAAoB;","names":[]}