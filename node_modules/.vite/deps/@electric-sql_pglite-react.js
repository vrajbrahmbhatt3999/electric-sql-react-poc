import {
  require_jsx_runtime
} from "./chunk-GRWX7YRK.js";
import {
  __toESM,
  require_react
} from "./chunk-I4MZPW7S.js";

// node_modules/@electric-sql/pglite-react/dist/index.js
var import_react = __toESM(require_react());
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react2 = __toESM(require_react());
import { query as R } from "@electric-sql/pglite/template";
function Q() {
  let e = (0, import_react.createContext)(void 0);
  return { usePGlite: (t) => {
    let n = (0, import_react.useContext)(e);
    if (t !== void 0) return t;
    if (!n) throw new Error("No PGlite instance found, use PGliteProvider to provide one");
    return n;
  }, PGliteProvider: ({ children: t, db: n }) => (0, import_jsx_runtime.jsx)(e.Provider, { value: n, children: t }) };
}
var { PGliteProvider: W, usePGlite: y } = Q();
function k(e, t) {
  if (!e && !t) return true;
  if ((e == null ? void 0 : e.length) !== (t == null ? void 0 : t.length)) return false;
  for (let n = 0; n < e.length; n++) if (!Object.is(e[n], t[n])) return false;
  return true;
}
function P(e, t, n) {
  let o = y(), c = (0, import_react2.useRef)(t), f = (0, import_react2.useRef)(void 0), i, T = false;
  typeof e != "string" && !(e instanceof Promise) && (i = e, T = f.current !== i, f.current = i);
  let [u, v] = (0, import_react2.useState)(i == null ? void 0 : i.initialResults), d = c.current;
  return k(c.current, t) || (c.current = t, d = t), (0, import_react2.useEffect)(() => {
    let l = false, s = (r) => {
      l || v(r);
    };
    if (typeof e == "string") {
      let r = n !== void 0 ? o.live.incrementalQuery(e, d, n, s) : o.live.query(e, d, s);
      return () => {
        l = true, r.then(({ unsubscribe: L }) => L());
      };
    } else {
      if (e instanceof Promise) return e.then((r) => {
        l || (f.current = r, v(r.initialResults), r.subscribe(s));
      }), () => {
        var _a;
        l = true, (_a = f.current) == null ? void 0 : _a.unsubscribe(s);
      };
      if (i) return v(i.initialResults), i.subscribe(s), () => {
        l = true, i.unsubscribe(s);
      };
      throw new Error("Should never happen");
    }
  }, [o, n, e, d, i]), T && i ? i.initialResults : u && { rows: u.rows, fields: u.fields, totalCount: u.totalCount, offset: u.offset, limit: u.limit };
}
function h(e, t) {
  return P(e, t);
}
h.sql = function(e, ...t) {
  let { query: n, params: o } = R(e, ...t);
  return P(n, o);
};
function N(e, t, n) {
  return P(e, t, n);
}
export {
  W as PGliteProvider,
  Q as makePGliteProvider,
  N as useLiveIncrementalQuery,
  h as useLiveQuery,
  y as usePGlite
};
//# sourceMappingURL=@electric-sql_pglite-react.js.map
