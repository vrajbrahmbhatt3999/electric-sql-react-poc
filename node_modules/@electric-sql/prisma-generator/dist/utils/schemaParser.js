"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseFields = exports.parseModels = void 0;
function parseModels(prismaSchema) {
    const commentRegex = /\/\/.*$/gm;
    const schema = prismaSchema.replaceAll(commentRegex, '');
    const modelRegex = /^\s*model\s+(?<name>\w+)\s*{(?<body>[^}]*)}/gm;
    const matches = [...schema.matchAll(modelRegex)];
    const modelBodies = matches.map((match) => match.groups);
    return modelBodies.map(({ name, body }) => {
        return {
            name,
            fields: parseFields(body),
        };
    });
}
exports.parseModels = parseModels;
function parseFields(body) {
    const fieldRegex = /^\s*(?<field>\w+)\s+(?<type>[\w]+(\?|(\[]))?)\s*(?<attributes>((@[\w.]+\s*)|(@[\w.]+\(.*\)+\s*))+)?\s*$/gm;
    const fieldMatches = [...body.matchAll(fieldRegex)];
    const fs = fieldMatches.map((match) => match.groups);
    return fs.map((f) => {
        var _a;
        return ({
            ...f,
            attributes: parseAttributes((_a = f.attributes) !== null && _a !== void 0 ? _a : ''),
        });
    });
}
exports.parseFields = parseFields;
function parseAttributes(attributes) {
    const attributeRegex = /(?<type>@[\w\.]+)(?<args>\([^@\n\r]+\))?/g;
    const matches = [...attributes.matchAll(attributeRegex)];
    return matches.map((m) => {
        var _a, _b;
        const { type, args } = m.groups;
        const noParens = args === null || args === void 0 ? void 0 : args.substring(1, args.length - 1);
        const parsedArgs = (_b = (_a = noParens === null || noParens === void 0 ? void 0 : noParens.split(',')) === null || _a === void 0 ? void 0 : _a.map((arg) => arg.trim())) !== null && _b !== void 0 ? _b : [];
        return {
            type: type,
            args: parsedArgs,
        };
    });
}
//# sourceMappingURL=schemaParser.js.map