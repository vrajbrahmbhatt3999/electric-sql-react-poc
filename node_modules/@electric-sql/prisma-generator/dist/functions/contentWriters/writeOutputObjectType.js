"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeOutputObjectType = void 0;
const writeSelect_1 = require("./writeSelect");
const __1 = require("..");
function modelHasRelation(model, dmmf) {
    var _a;
    if (typeof model === 'string') {
        const maybeModel = dmmf.datamodel.models.find((m) => m.name === model);
        return (_a = maybeModel === null || maybeModel === void 0 ? void 0 : maybeModel.hasRelationFields) !== null && _a !== void 0 ? _a : false;
    }
    return false;
}
const writeOutputObjectType = ({ fileWriter, dmmf, getSingleFileContent = false }, field) => {
    const { writer, writeImportSet, writeHeading } = fileWriter;
    const { useMultipleFiles } = dmmf.generatorConfig;
    if (useMultipleFiles && !getSingleFileContent) {
        writeImportSet(field.argTypeImports);
        const modelWithSelect = dmmf.schema.getModelWithIncludeAndSelect(field);
        if (modelWithSelect && field.generatorConfig.addSelectType) {
            writeImportSet(modelWithSelect.selectImports);
            if (field.writeSelectAndIncludeArgs) {
                writeHeading('Select schema needs to be in file to prevent circular imports');
                (0, writeSelect_1.writeSelect)({ fileWriter, dmmf, getSingleFileContent: true }, modelWithSelect);
            }
        }
    }
    writer
        .blankLine()
        .write(`export const ${field.argName}Schema: `)
        .write(field.customArgType)
        .write(` = `)
        .write(`z.object(`)
        .inlineBlock(() => {
        writer
            .conditionalWriteLine(field.writeSelectArg, `select: ${field.modelType}SelectSchema.optional(),`)
            .conditionalWriteLine(field.writeIncludeArg, `include: ${field.modelType}IncludeSchema.optional(),`);
        field.args.forEach((arg) => {
            writer.write(`${arg.name}: `);
            const { isOptional, isNullable } = arg;
            if (arg.hasMultipleTypes) {
                writer.write(`z.union([ `);
                arg.inputTypes.forEach((inputType, idx) => {
                    const writeComma = idx !== arg.inputTypes.length - 1;
                    (0, __1.writeScalarType)(writer, {
                        inputType,
                        writeLazy: false,
                        writeComma,
                    });
                    (0, __1.writeNonScalarType)(writer, {
                        inputType,
                        writeLazy: false,
                        writeComma,
                    });
                    (0, __1.writeSpecialType)(writer, {
                        inputType,
                        writeLazy: false,
                        writeComma,
                    });
                });
                writer
                    .write(` ])`)
                    .conditionalWrite(arg.isOptional, `.optional()`)
                    .conditionalWrite(arg.isNullable, `.nullable()`)
                    .write(`,`);
            }
            else {
                (0, __1.writeScalarType)(writer, {
                    inputType: arg.inputTypes[0],
                    writeLazy: false,
                    isNullable,
                    isOptional,
                });
                (0, __1.writeNonScalarType)(writer, {
                    inputType: arg.inputTypes[0],
                    writeLazy: false,
                    isNullable,
                    isOptional,
                });
                (0, __1.writeSpecialType)(writer, {
                    inputType: arg.inputTypes[0],
                    writeLazy: false,
                    isNullable,
                    isOptional,
                });
            }
            writer.newLine();
        });
    })
        .write(`).strict() `)
        .conditionalWrite(modelHasRelation(field.modelType, dmmf), `as ${field.customArgType}`);
    if (useMultipleFiles && !getSingleFileContent) {
        writer.blankLine().writeLine(`export default ${field.argName}Schema;`);
    }
};
exports.writeOutputObjectType = writeOutputObjectType;
//# sourceMappingURL=writeOutputObjectType.js.map