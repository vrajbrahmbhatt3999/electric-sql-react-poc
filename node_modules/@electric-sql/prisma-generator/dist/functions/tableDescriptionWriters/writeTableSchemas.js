"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeTableDescriptionType = exports.writeSchemas = exports.writeRelations = exports.writeFieldsMap = exports.writeTableSchemas = void 0;
function writeTableSchemas(dmmf, fileWriter) {
    const writer = fileWriter.writer;
    writer.blankLine();
    dmmf.datamodel.models.forEach((model) => {
        const modelName = model.name;
        writer
            .write(`interface ${modelName}GetPayload extends HKT `)
            .inlineBlock(() => {
            writer
                .writeLine(`readonly _A?: boolean | null | undefined | Prisma.${modelName}Args`)
                .writeLine(`readonly type: Omit<Prisma.${modelName}GetPayload<this['_A']>, "Please either choose \`select\` or \`include\`">`);
        })
            .blankLine();
    });
    writer
        .write(`export const tableSchemas = `)
        .inlineBlock(() => {
        dmmf.datamodel.models.forEach((model) => {
            var _a;
            const tableName = (_a = model.dbName) !== null && _a !== void 0 ? _a : model.name;
            writer.write(`${tableName}: `).inlineBlock(() => {
                writer.write('fields: ');
                writeFieldsMap(model, fileWriter);
                writer.newLine().write(`relations: `);
                const modelNameMappings = new Map(dmmf.datamodel.models.map((m) => { var _a; return [m.name, (_a = m.dbName) !== null && _a !== void 0 ? _a : m.name]; }));
                writeRelations(model, fileWriter, modelNameMappings);
                writeSchemas(model, fileWriter);
            });
            writer.write(' as ');
            writeTableDescriptionType(model, fileWriter);
        });
    })
        .blankLine();
    writer
        .writeLine('export const schema = new DbSchema(tableSchemas, migrations, pgMigrations)')
        .writeLine('export type Electric = ElectricClient<typeof schema>')
        .conditionalWriteLine(dmmf.schema.hasJsonTypes, 'export const JsonNull = { __is_electric_json_null__: true }');
}
exports.writeTableSchemas = writeTableSchemas;
function writeFieldsMap(model, fileWriter) {
    const fieldsWithoutRelations = model.fields.filter((f) => model.relationFields.indexOf(f) === -1);
    const fieldArray = JSON.stringify(fieldsWithoutRelations.map((field) => [
        field.name,
        pgType(field, model.name),
    ]), null, 2);
    fileWriter.writer.write(`new Map(${fieldArray}),`);
}
exports.writeFieldsMap = writeFieldsMap;
function pgType(field, modelName) {
    const prismaType = field.type;
    const attributes = field.attributes;
    const getTypeAttribute = () => attributes.find((a) => a.type.startsWith('@db'));
    switch (prismaType) {
        case 'String':
            return stringToPg(getTypeAttribute());
        case 'Int':
            return intToPg(getTypeAttribute());
        case 'Boolean':
            return 'BOOL';
        case 'DateTime':
            return dateTimeToPg(getTypeAttribute(), field.name, modelName);
        case 'BigInt':
            return 'INT8';
        case 'Bytes':
            return 'BYTEA';
        case 'Decimal':
            return 'DECIMAL';
        case 'Float':
            return floatToPg(getTypeAttribute());
        case 'Json':
            return jsonToPg(attributes);
        default:
            if (field.kind === 'enum')
                return 'TEXT';
            return 'UNRECOGNIZED PRISMA TYPE';
    }
}
function floatToPg(pgTypeAttribute) {
    if (!pgTypeAttribute || pgTypeAttribute.type === '@db.DoublePrecision') {
        return 'FLOAT8';
    }
    else {
        return 'FLOAT4';
    }
}
function jsonToPg(attributes) {
    const pgTypeAttribute = attributes.find((a) => a.type.startsWith('@db'));
    if (pgTypeAttribute && pgTypeAttribute.type === '@db.Json') {
        return 'JSON';
    }
    else {
        return 'JSONB';
    }
}
function dateTimeToPg(a, field, model) {
    const type = a === null || a === void 0 ? void 0 : a.type;
    const mapping = new Map([
        ['@db.Timestamptz', 'TIMESTAMPTZ'],
        ['@db.Time', 'TIME'],
        ['@db.Timetz', 'TIMETZ'],
        ['@db.Date', 'DATE'],
        ['@db.Timestamp', 'TIMESTAMP'],
    ]);
    if (!type) {
        return 'TIMESTAMP';
    }
    else {
        const pgType = mapping.get(type);
        if (!pgType) {
            throw new Error(`Unrecognized type attribute '${type}' for field '${field}' in model '${model}'.`);
        }
        return pgType;
    }
}
function stringToPg(pgTypeAttribute) {
    if (!pgTypeAttribute || pgTypeAttribute.type === '@db.Text') {
        return 'TEXT';
    }
    else if (pgTypeAttribute.type === '@db.Uuid') {
        return 'UUID';
    }
    else {
        return 'VARCHAR';
    }
}
function intToPg(pgTypeAttribute) {
    if ((pgTypeAttribute === null || pgTypeAttribute === void 0 ? void 0 : pgTypeAttribute.type) === '@db.SmallInt') {
        return 'INT2';
    }
    else {
        return 'INT4';
    }
}
function writeRelations(model, fileWriter, modelNames2DbNames) {
    const writer = fileWriter.writer;
    writer.write('[').newLine();
    model.relationFields.forEach((field) => {
        const fieldName = field.name;
        const relationName = field.relationName;
        if (field.relationFromFields.length > 1)
            throw new Error(`Electric does not yet support relations with composite keys. Relation '${relationName}' in model ${model.name} has several from fields: ${JSON.stringify(field.relationFromFields)}`);
        if (field.relationToFields.length > 1)
            throw new Error(`Electric does not yet support relations with composite keys. Relation '${relationName}' in model ${model.name} has several to fields: ${JSON.stringify(field.relationToFields)}`);
        const from = field.relationFromFields.length === 0 ? '' : field.relationFromFields[0];
        const to = field.relationToFields.length === 0 ? '' : field.relationToFields[0];
        const otherTable = modelNames2DbNames.get(field.type);
        const arity = field.isList ? 'many' : 'one';
        writer.writeLine(`  new Relation("${fieldName}", "${from}", "${to}", "${otherTable}", "${relationName}", "${arity}"),`);
    });
    writer.writeLine('],');
}
exports.writeRelations = writeRelations;
function writeSchemas(model, fileWriter) {
    const writer = fileWriter.writer;
    const modelName = model.name;
    writer
        .writeLine(`modelSchema: (${modelName}CreateInputSchema as any)`)
        .writeLine('  .partial()')
        .writeLine(`  .or((${modelName}UncheckedCreateInputSchema as any).partial()),`)
        .writeLine(`createSchema: ${modelName}CreateArgsSchema,`)
        .writeLine(`createManySchema: ${modelName}CreateManyArgsSchema,`)
        .writeLine(`findUniqueSchema: ${modelName}FindUniqueArgsSchema,`)
        .writeLine(`findSchema: ${modelName}FindFirstArgsSchema,`)
        .writeLine(`updateSchema: ${modelName}UpdateArgsSchema,`)
        .writeLine(`updateManySchema: ${modelName}UpdateManyArgsSchema,`)
        .writeLine(`upsertSchema: ${modelName}UpsertArgsSchema,`)
        .writeLine(`deleteSchema: ${modelName}DeleteArgsSchema,`)
        .writeLine(`deleteManySchema: ${modelName}DeleteManyArgsSchema`);
}
exports.writeSchemas = writeSchemas;
function writeTableDescriptionType(model, fileWriter) {
    const capitalizeFirstLetter = (string) => {
        return string.charAt(0).toUpperCase() + string.slice(1);
    };
    const modelName = model.name;
    const capitalizedModelName = capitalizeFirstLetter(modelName);
    let includeType = `Omit<Prisma.${modelName}Include, '_count'>,`;
    if (model.relationFields.length === 0) {
        includeType = 'never,';
    }
    fileWriter.writer
        .write('TableSchema<')
        .newLine()
        .writeLine(`  z.infer<typeof ${modelName}UncheckedCreateInputSchema>,`)
        .writeLine(`  Prisma.${modelName}CreateArgs['data'],`)
        .writeLine(`  Prisma.${modelName}UpdateArgs['data'],`)
        .writeLine(`  Prisma.${modelName}FindFirstArgs['select'],`)
        .writeLine(`  Prisma.${modelName}FindFirstArgs['where'],`)
        .writeLine(`  Prisma.${modelName}FindUniqueArgs['where'],`)
        .writeLine(`  ${includeType}`)
        .writeLine(`  Prisma.${modelName}FindFirstArgs['orderBy'],`)
        .writeLine(`  Prisma.${capitalizedModelName}ScalarFieldEnum,`)
        .writeLine(`  ${modelName}GetPayload`)
        .writeLine('>,');
}
exports.writeTableDescriptionType = writeTableDescriptionType;
//# sourceMappingURL=writeTableSchemas.js.map