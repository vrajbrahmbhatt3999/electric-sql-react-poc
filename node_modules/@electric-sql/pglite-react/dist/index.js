import{createContext as p,useContext as m}from"react";import{jsx as G}from"react/jsx-runtime";function Q(){let e=p(void 0);return{usePGlite:t=>{let n=m(e);if(t!==void 0)return t;if(!n)throw new Error("No PGlite instance found, use PGliteProvider to provide one");return n},PGliteProvider:({children:t,db:n})=>G(e.Provider,{value:n,children:t})}}var{PGliteProvider:W,usePGlite:y}=Q();import{query as R}from"@electric-sql/pglite/template";import{useEffect as g,useRef as a,useState as w}from"react";function k(e,t){if(!e&&!t)return!0;if(e?.length!==t?.length)return!1;for(let n=0;n<e.length;n++)if(!Object.is(e[n],t[n]))return!1;return!0}function P(e,t,n){let o=y(),c=a(t),f=a(void 0),i,T=!1;typeof e!="string"&&!(e instanceof Promise)&&(i=e,T=f.current!==i,f.current=i);let[u,v]=w(i?.initialResults),d=c.current;return k(c.current,t)||(c.current=t,d=t),g(()=>{let l=!1,s=r=>{l||v(r)};if(typeof e=="string"){let r=n!==void 0?o.live.incrementalQuery(e,d,n,s):o.live.query(e,d,s);return()=>{l=!0,r.then(({unsubscribe:L})=>L())}}else{if(e instanceof Promise)return e.then(r=>{l||(f.current=r,v(r.initialResults),r.subscribe(s))}),()=>{l=!0,f.current?.unsubscribe(s)};if(i)return v(i.initialResults),i.subscribe(s),()=>{l=!0,i.unsubscribe(s)};throw new Error("Should never happen")}},[o,n,e,d,i]),T&&i?i.initialResults:u&&{rows:u.rows,fields:u.fields,totalCount:u.totalCount,offset:u.offset,limit:u.limit}}function h(e,t){return P(e,t)}h.sql=function(e,...t){let{query:n,params:o}=R(e,...t);return P(n,o)};function N(e,t,n){return P(e,t,n)}export{W as PGliteProvider,Q as makePGliteProvider,N as useLiveIncrementalQuery,h as useLiveQuery,y as usePGlite};
//# sourceMappingURL=index.js.map