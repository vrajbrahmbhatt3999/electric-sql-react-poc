{"version":3,"sources":["../src/error.ts","../src/parser.ts","../src/helpers.ts","../src/constants.ts","../src/fetch.ts","../src/client.ts","../src/shape.ts"],"sourcesContent":["export class FetchError extends Error {\n  status: number\n  text?: string\n  json?: object\n  headers: Record<string, string>\n\n  constructor(\n    status: number,\n    text: string | undefined,\n    json: object | undefined,\n    headers: Record<string, string>,\n    public url: string,\n    message?: string\n  ) {\n    super(\n      message ||\n        `HTTP Error ${status} at ${url}: ${text ?? JSON.stringify(json)}`\n    )\n    this.name = `FetchError`\n    this.status = status\n    this.text = text\n    this.json = json\n    this.headers = headers\n  }\n\n  static async fromResponse(\n    response: Response,\n    url: string\n  ): Promise<FetchError> {\n    const status = response.status\n    const headers = Object.fromEntries([...response.headers.entries()])\n    let text: string | undefined = undefined\n    let json: object | undefined = undefined\n\n    const contentType = response.headers.get(`content-type`)\n    if (contentType && contentType.includes(`application/json`)) {\n      json = (await response.json()) as object\n    } else {\n      text = await response.text()\n    }\n\n    return new FetchError(status, text, json, headers, url)\n  }\n}\n\nexport class FetchBackoffAbortError extends Error {\n  constructor() {\n    super(`Fetch with backoff aborted`)\n    this.name = `FetchBackoffAbortError`\n  }\n}\n\nexport class InvalidShapeOptionsError extends Error {\n  constructor(message: string) {\n    super(message)\n    this.name = `InvalidShapeOptionsError`\n  }\n}\n\nexport class MissingShapeUrlError extends Error {\n  constructor() {\n    super(`Invalid shape options: missing required url parameter`)\n    this.name = `MissingShapeUrlError`\n  }\n}\n\nexport class InvalidSignalError extends Error {\n  constructor() {\n    super(`Invalid signal option. It must be an instance of AbortSignal.`)\n    this.name = `InvalidSignalError`\n  }\n}\n\nexport class MissingShapeHandleError extends Error {\n  constructor() {\n    super(\n      `shapeHandle is required if this isn't an initial fetch (i.e. offset > -1)`\n    )\n    this.name = `MissingShapeHandleError`\n  }\n}\n\nexport class ReservedParamError extends Error {\n  constructor(reservedParams: string[]) {\n    super(\n      `Cannot use reserved Electric parameter names in custom params: ${reservedParams.join(`, `)}`\n    )\n    this.name = `ReservedParamError`\n  }\n}\n\nexport class ParserNullValueError extends Error {\n  constructor(columnName: string) {\n    super(`Column \"${columnName ?? `unknown`}\" does not allow NULL values`)\n    this.name = `ParserNullValueError`\n  }\n}\n\nexport class ShapeStreamAlreadyRunningError extends Error {\n  constructor() {\n    super(`ShapeStream is already running`)\n    this.name = `ShapeStreamAlreadyRunningError`\n  }\n}\n\nexport class MissingHeadersError extends Error {\n  constructor(url: string, missingHeaders: Array<string>) {\n    let msg = `The response for the shape request to ${url} didn't include the following required headers:\\n`\n    missingHeaders.forEach((h) => {\n      msg += `- ${h}\\n`\n    })\n    msg += `\\nThis is often due to a proxy not setting CORS correctly so that all Electric headers can be read by the client.`\n    msg += `\\nFor more information visit the troubleshooting guide: /docs/guides/troubleshooting/missing-headers`\n    super(msg)\n  }\n}\n","import { ColumnInfo, GetExtensions, Message, Row, Schema, Value } from './types'\nimport { ParserNullValueError } from './error'\n\ntype NullToken = null | `NULL`\ntype Token = Exclude<string, NullToken>\ntype NullableToken = Token | NullToken\nexport type ParseFunction<Extensions = never> = (\n  value: Token,\n  additionalInfo?: Omit<ColumnInfo, `type` | `dims`>\n) => Value<Extensions>\ntype NullableParseFunction<Extensions = never> = (\n  value: NullableToken,\n  additionalInfo?: Omit<ColumnInfo, `type` | `dims`>\n) => Value<Extensions>\n/**\n * @typeParam Extensions - Additional types that can be parsed by this parser beyond the standard SQL types.\n *                         Defaults to no additional types.\n */\nexport type Parser<Extensions = never> = {\n  [key: string]: ParseFunction<Extensions>\n}\n\nconst parseNumber = (value: string) => Number(value)\nconst parseBool = (value: string) => value === `true` || value === `t`\nconst parseBigInt = (value: string) => BigInt(value)\nconst parseJson = (value: string) => JSON.parse(value)\nconst identityParser: ParseFunction = (v: string) => v\n\nexport const defaultParser: Parser = {\n  int2: parseNumber,\n  int4: parseNumber,\n  int8: parseBigInt,\n  bool: parseBool,\n  float4: parseNumber,\n  float8: parseNumber,\n  json: parseJson,\n  jsonb: parseJson,\n}\n\n// Taken from: https://github.com/electric-sql/pglite/blob/main/packages/pglite/src/types.ts#L233-L279\nexport function pgArrayParser<Extensions>(\n  value: Token,\n  parser?: ParseFunction<Extensions>\n): Value<Extensions> {\n  let i = 0\n  let char = null\n  let str = ``\n  let quoted = false\n  let last = 0\n  let p: string | undefined = undefined\n\n  function loop(x: string): Array<Value<Extensions>> {\n    const xs = []\n    for (; i < x.length; i++) {\n      char = x[i]\n      if (quoted) {\n        if (char === `\\\\`) {\n          str += x[++i]\n        } else if (char === `\"`) {\n          xs.push(parser ? parser(str) : str)\n          str = ``\n          quoted = x[i + 1] === `\"`\n          last = i + 2\n        } else {\n          str += char\n        }\n      } else if (char === `\"`) {\n        quoted = true\n      } else if (char === `{`) {\n        last = ++i\n        xs.push(loop(x))\n      } else if (char === `}`) {\n        quoted = false\n        last < i &&\n          xs.push(parser ? parser(x.slice(last, i)) : x.slice(last, i))\n        last = i + 1\n        break\n      } else if (char === `,` && p !== `}` && p !== `\"`) {\n        xs.push(parser ? parser(x.slice(last, i)) : x.slice(last, i))\n        last = i + 1\n      }\n      p = char\n    }\n    last < i &&\n      xs.push(parser ? parser(x.slice(last, i + 1)) : x.slice(last, i + 1))\n    return xs\n  }\n\n  return loop(value)[0]\n}\n\nexport class MessageParser<T extends Row<unknown>> {\n  private parser: Parser<GetExtensions<T>>\n  constructor(parser?: Parser<GetExtensions<T>>) {\n    // Merge the provided parser with the default parser\n    // to use the provided parser whenever defined\n    // and otherwise fall back to the default parser\n    this.parser = { ...defaultParser, ...parser }\n  }\n\n  parse(messages: string, schema: Schema): Message<T>[] {\n    return JSON.parse(messages, (key, value) => {\n      // typeof value === `object` && value !== null\n      // is needed because there could be a column named `value`\n      // and the value associated to that column will be a string or null.\n      // But `typeof null === 'object'` so we need to make an explicit check.\n      // We also parse the `old_value`, which appears on updates when `replica=full`.\n      if (\n        (key === `value` || key === `old_value`) &&\n        typeof value === `object` &&\n        value !== null\n      ) {\n        // Parse the row values\n        const row = value as Record<string, Value<GetExtensions<T>>>\n        Object.keys(row).forEach((key) => {\n          row[key] = this.parseRow(key, row[key] as NullableToken, schema)\n        })\n      }\n      return value\n    }) as Message<T>[]\n  }\n\n  // Parses the message values using the provided parser based on the schema information\n  private parseRow(\n    key: string,\n    value: NullableToken,\n    schema: Schema\n  ): Value<GetExtensions<T>> {\n    const columnInfo = schema[key]\n    if (!columnInfo) {\n      // We don't have information about the value\n      // so we just return it\n      return value\n    }\n\n    // Copy the object but don't include `dimensions` and `type`\n    const { type: typ, dims: dimensions, ...additionalInfo } = columnInfo\n\n    // Pick the right parser for the type\n    // and support parsing null values if needed\n    // if no parser is provided for the given type, just return the value as is\n    const typeParser = this.parser[typ] ?? identityParser\n    const parser = makeNullableParser(typeParser, columnInfo, key)\n\n    if (dimensions && dimensions > 0) {\n      // It's an array\n      const nullablePgArrayParser = makeNullableParser(\n        (value, _) => pgArrayParser(value, parser),\n        columnInfo,\n        key\n      )\n      return nullablePgArrayParser(value)\n    }\n\n    return parser(value, additionalInfo)\n  }\n}\n\nfunction makeNullableParser<Extensions>(\n  parser: ParseFunction<Extensions>,\n  columnInfo: ColumnInfo,\n  columnName?: string\n): NullableParseFunction<Extensions> {\n  const isNullable = !(columnInfo.not_null ?? false)\n  // The sync service contains `null` value for a column whose value is NULL\n  // but if the column value is an array that contains a NULL value\n  // then it will be included in the array string as `NULL`, e.g.: `\"{1,NULL,3}\"`\n  return (value: NullableToken) => {\n    if (isPgNull(value)) {\n      if (!isNullable) {\n        throw new ParserNullValueError(columnName ?? `unknown`)\n      }\n      return null\n    }\n    return parser(value, columnInfo)\n  }\n}\n\nfunction isPgNull(value: NullableToken): value is NullToken {\n  return value === null || value === `NULL`\n}\n","import { ChangeMessage, ControlMessage, Message, Row } from './types'\n\n/**\n * Type guard for checking {@link Message} is {@link ChangeMessage}.\n *\n * See [TS docs](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards)\n * for information on how to use type guards.\n *\n * @param message - the message to check\n * @returns true if the message is a {@link ChangeMessage}\n *\n * @example\n * ```ts\n * if (isChangeMessage(message)) {\n *   const msgChng: ChangeMessage = message // Ok\n *   const msgCtrl: ControlMessage = message // Err, type mismatch\n * }\n * ```\n */\nexport function isChangeMessage<T extends Row<unknown> = Row>(\n  message: Message<T>\n): message is ChangeMessage<T> {\n  return `key` in message\n}\n\n/**\n * Type guard for checking {@link Message} is {@link ControlMessage}.\n *\n * See [TS docs](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards)\n * for information on how to use type guards.\n *\n * @param message - the message to check\n * @returns true if the message is a {@link ControlMessage}\n *\n *  * @example\n * ```ts\n * if (isControlMessage(message)) {\n *   const msgChng: ChangeMessage = message // Err, type mismatch\n *   const msgCtrl: ControlMessage = message // Ok\n * }\n * ```\n */\nexport function isControlMessage<T extends Row<unknown> = Row>(\n  message: Message<T>\n): message is ControlMessage {\n  return !isChangeMessage(message)\n}\n\nexport function isUpToDateMessage<T extends Row<unknown> = Row>(\n  message: Message<T>\n): message is ControlMessage & { up_to_date: true } {\n  return isControlMessage(message) && message.headers.control === `up-to-date`\n}\n","export const LIVE_CACHE_BUSTER_HEADER = `electric-cursor`\nexport const SHAPE_HANDLE_HEADER = `electric-handle`\nexport const CHUNK_LAST_OFFSET_HEADER = `electric-offset`\nexport const SHAPE_SCHEMA_HEADER = `electric-schema`\nexport const CHUNK_UP_TO_DATE_HEADER = `electric-up-to-date`\nexport const COLUMNS_QUERY_PARAM = `columns`\nexport const LIVE_CACHE_BUSTER_QUERY_PARAM = `cursor`\nexport const SHAPE_HANDLE_QUERY_PARAM = `handle`\nexport const LIVE_QUERY_PARAM = `live`\nexport const OFFSET_QUERY_PARAM = `offset`\nexport const TABLE_QUERY_PARAM = `table`\nexport const WHERE_QUERY_PARAM = `where`\nexport const REPLICA_PARAM = `replica`\nexport const WHERE_PARAMS_PARAM = `params`\nexport const FORCE_DISCONNECT_AND_REFRESH = `force-disconnect-and-refresh`\n","import {\n  CHUNK_LAST_OFFSET_HEADER,\n  CHUNK_UP_TO_DATE_HEADER,\n  LIVE_QUERY_PARAM,\n  OFFSET_QUERY_PARAM,\n  SHAPE_HANDLE_HEADER,\n  SHAPE_HANDLE_QUERY_PARAM,\n} from './constants'\nimport {\n  FetchError,\n  FetchBackoffAbortError,\n  MissingHeadersError,\n} from './error'\n\n// Some specific 4xx and 5xx HTTP status codes that we definitely\n// want to retry\nconst HTTP_RETRY_STATUS_CODES = [429]\n\nexport interface BackoffOptions {\n  /**\n   * Initial delay before retrying in milliseconds\n   */\n  initialDelay: number\n  /**\n   * Maximum retry delay in milliseconds\n   */\n  maxDelay: number\n  multiplier: number\n  onFailedAttempt?: () => void\n  debug?: boolean\n}\n\nexport const BackoffDefaults = {\n  initialDelay: 100,\n  maxDelay: 10_000,\n  multiplier: 1.3,\n}\n\nexport function createFetchWithBackoff(\n  fetchClient: typeof fetch,\n  backoffOptions: BackoffOptions = BackoffDefaults\n): typeof fetch {\n  const {\n    initialDelay,\n    maxDelay,\n    multiplier,\n    debug = false,\n    onFailedAttempt,\n  } = backoffOptions\n  return async (...args: Parameters<typeof fetch>): Promise<Response> => {\n    const url = args[0]\n    const options = args[1]\n\n    let delay = initialDelay\n    let attempt = 0\n\n    /* eslint-disable no-constant-condition -- we re-fetch the shape log\n     * continuously until we get a non-ok response. For recoverable errors,\n     * we retry the fetch with exponential backoff. Users can pass in an\n     * AbortController to abort the fetching an any point.\n     * */\n    while (true) {\n      /* eslint-enable no-constant-condition */\n      try {\n        const result = await fetchClient(...args)\n        if (result.ok) return result\n        else throw await FetchError.fromResponse(result, url.toString())\n      } catch (e) {\n        onFailedAttempt?.()\n        if (options?.signal?.aborted) {\n          throw new FetchBackoffAbortError()\n        } else if (\n          e instanceof FetchError &&\n          !HTTP_RETRY_STATUS_CODES.includes(e.status) &&\n          e.status >= 400 &&\n          e.status < 500\n        ) {\n          // Any client errors cannot be backed off on, leave it to the caller to handle.\n          throw e\n        } else {\n          // Exponentially backoff on errors.\n          // Wait for the current delay duration\n          await new Promise((resolve) => setTimeout(resolve, delay))\n\n          // Increase the delay for the next attempt\n          delay = Math.min(delay * multiplier, maxDelay)\n\n          if (debug) {\n            attempt++\n            console.log(`Retry attempt #${attempt} after ${delay}ms`)\n          }\n        }\n      }\n    }\n  }\n}\n\ninterface ChunkPrefetchOptions {\n  maxChunksToPrefetch: number\n}\n\nconst ChunkPrefetchDefaults = {\n  maxChunksToPrefetch: 2,\n}\n\n/**\n * Creates a fetch client that prefetches subsequent log chunks for\n * consumption by the shape stream without waiting for the chunk bodies\n * themselves to be loaded.\n *\n * @param fetchClient the client to wrap\n * @param prefetchOptions options to configure prefetching\n * @returns wrapped client with prefetch capabilities\n */\nexport function createFetchWithChunkBuffer(\n  fetchClient: typeof fetch,\n  prefetchOptions: ChunkPrefetchOptions = ChunkPrefetchDefaults\n): typeof fetch {\n  const { maxChunksToPrefetch } = prefetchOptions\n\n  let prefetchQueue: PrefetchQueue\n\n  const prefetchClient = async (...args: Parameters<typeof fetchClient>) => {\n    const url = args[0].toString()\n\n    // try to consume from the prefetch queue first, and if request is\n    // not present abort the prefetch queue as it must no longer be valid\n    const prefetchedRequest = prefetchQueue?.consume(...args)\n    if (prefetchedRequest) {\n      return prefetchedRequest\n    }\n\n    prefetchQueue?.abort()\n\n    // perform request and fire off prefetch queue if request is eligible\n    const response = await fetchClient(...args)\n    const nextUrl = getNextChunkUrl(url, response)\n    if (nextUrl) {\n      prefetchQueue = new PrefetchQueue({\n        fetchClient,\n        maxPrefetchedRequests: maxChunksToPrefetch,\n        url: nextUrl,\n        requestInit: args[1],\n      })\n    }\n\n    return response\n  }\n\n  return prefetchClient\n}\n\nexport const requiredElectricResponseHeaders = [\n  `electric-offset`,\n  `electric-handle`,\n]\n\nexport const requiredLiveResponseHeaders = [`electric-cursor`]\n\nexport const requiredNonLiveResponseHeaders = [`electric-schema`]\n\nexport function createFetchWithResponseHeadersCheck(\n  fetchClient: typeof fetch\n): typeof fetch {\n  return async (...args: Parameters<typeof fetchClient>) => {\n    const response = await fetchClient(...args)\n\n    if (response.ok) {\n      // Check that the necessary Electric headers are present on the response\n      const headers = response.headers\n      const missingHeaders: Array<string> = []\n\n      const addMissingHeaders = (requiredHeaders: Array<string>) =>\n        missingHeaders.push(...requiredHeaders.filter((h) => !headers.has(h)))\n      addMissingHeaders(requiredElectricResponseHeaders)\n\n      const input = args[0]\n      const urlString = input.toString()\n      const url = new URL(urlString)\n      if (url.searchParams.get(LIVE_QUERY_PARAM) === `true`) {\n        addMissingHeaders(requiredLiveResponseHeaders)\n      }\n\n      if (\n        !url.searchParams.has(LIVE_QUERY_PARAM) ||\n        url.searchParams.get(LIVE_QUERY_PARAM) === `false`\n      ) {\n        addMissingHeaders(requiredNonLiveResponseHeaders)\n      }\n\n      if (missingHeaders.length > 0) {\n        throw new MissingHeadersError(urlString, missingHeaders)\n      }\n    }\n\n    return response\n  }\n}\n\nclass PrefetchQueue {\n  readonly #fetchClient: typeof fetch\n  readonly #maxPrefetchedRequests: number\n  readonly #prefetchQueue = new Map<\n    string,\n    [Promise<Response>, AbortController]\n  >()\n  #queueHeadUrl: string | void\n  #queueTailUrl: string | void\n\n  constructor(options: {\n    url: Parameters<typeof fetch>[0]\n    requestInit: Parameters<typeof fetch>[1]\n    maxPrefetchedRequests: number\n    fetchClient?: typeof fetch\n  }) {\n    this.#fetchClient =\n      options.fetchClient ??\n      ((...args: Parameters<typeof fetch>) => fetch(...args))\n    this.#maxPrefetchedRequests = options.maxPrefetchedRequests\n    this.#queueHeadUrl = options.url.toString()\n    this.#queueTailUrl = this.#queueHeadUrl\n    this.#prefetch(options.url, options.requestInit)\n  }\n\n  abort(): void {\n    this.#prefetchQueue.forEach(([_, aborter]) => aborter.abort())\n  }\n\n  consume(...args: Parameters<typeof fetch>): Promise<Response> | void {\n    const url = args[0].toString()\n\n    const request = this.#prefetchQueue.get(url)?.[0]\n    // only consume if request is in queue and is the queue \"head\"\n    // if request is in the queue but not the head, the queue is being\n    // consumed out of order and should be restarted\n    if (!request || url !== this.#queueHeadUrl) return\n    this.#prefetchQueue.delete(url)\n\n    // fire off new prefetch since request has been consumed\n    request\n      .then((response) => {\n        const nextUrl = getNextChunkUrl(url, response)\n        this.#queueHeadUrl = nextUrl\n        if (\n          this.#queueTailUrl &&\n          !this.#prefetchQueue.has(this.#queueTailUrl)\n        ) {\n          this.#prefetch(this.#queueTailUrl, args[1])\n        }\n      })\n      .catch(() => {})\n\n    return request\n  }\n\n  #prefetch(...args: Parameters<typeof fetch>): void {\n    const url = args[0].toString()\n\n    // only prefetch when queue is not full\n    if (this.#prefetchQueue.size >= this.#maxPrefetchedRequests) return\n\n    // initialize aborter per request, to avoid aborting consumed requests that\n    // are still streaming their bodies to the consumer\n    const aborter = new AbortController()\n\n    try {\n      const { signal, cleanup } = chainAborter(aborter, args[1]?.signal)\n      const request = this.#fetchClient(url, { ...(args[1] ?? {}), signal })\n      this.#prefetchQueue.set(url, [request, aborter])\n      request\n        .then((response) => {\n          // only keep prefetching if response chain is uninterrupted\n          if (!response.ok || aborter.signal.aborted) return\n\n          const nextUrl = getNextChunkUrl(url, response)\n\n          // only prefetch when there is a next URL\n          if (!nextUrl || nextUrl === url) {\n            this.#queueTailUrl = undefined\n            return\n          }\n\n          this.#queueTailUrl = nextUrl\n          return this.#prefetch(nextUrl, args[1])\n        })\n        .catch(() => {})\n        .finally(cleanup)\n    } catch (_) {\n      // ignore prefetch errors\n    }\n  }\n}\n\n/**\n * Generate the next chunk's URL if the url and response are valid\n */\nfunction getNextChunkUrl(url: string, res: Response): string | void {\n  const shapeHandle = res.headers.get(SHAPE_HANDLE_HEADER)\n  const lastOffset = res.headers.get(CHUNK_LAST_OFFSET_HEADER)\n  const isUpToDate = res.headers.has(CHUNK_UP_TO_DATE_HEADER)\n\n  // only prefetch if shape handle and offset for next chunk are available, and\n  // response is not already up-to-date\n  if (!shapeHandle || !lastOffset || isUpToDate) return\n\n  const nextUrl = new URL(url)\n\n  // don't prefetch live requests, rushing them will only\n  // potentially miss more recent data\n  if (nextUrl.searchParams.has(LIVE_QUERY_PARAM)) return\n\n  nextUrl.searchParams.set(SHAPE_HANDLE_QUERY_PARAM, shapeHandle)\n  nextUrl.searchParams.set(OFFSET_QUERY_PARAM, lastOffset)\n  nextUrl.searchParams.sort()\n  return nextUrl.toString()\n}\n\n/**\n * Chains an abort controller on an optional source signal's\n * aborted state - if the source signal is aborted, the provided abort\n * controller will also abort\n */\nfunction chainAborter(\n  aborter: AbortController,\n  sourceSignal?: AbortSignal | null\n): {\n  signal: AbortSignal\n  cleanup: () => void\n} {\n  let cleanup = noop\n  if (!sourceSignal) {\n    // no-op, nothing to chain to\n  } else if (sourceSignal.aborted) {\n    // source signal is already aborted, abort immediately\n    aborter.abort()\n  } else {\n    // chain to source signal abort event, and add callback to unlink\n    // the aborter to avoid memory leaks\n    const abortParent = () => aborter.abort()\n    sourceSignal.addEventListener(`abort`, abortParent, {\n      once: true,\n      signal: aborter.signal,\n    })\n    cleanup = () => sourceSignal.removeEventListener(`abort`, abortParent)\n  }\n\n  return {\n    signal: aborter.signal,\n    cleanup,\n  }\n}\n\nfunction noop() {}\n","import {\n  Message,\n  Offset,\n  Schema,\n  Row,\n  MaybePromise,\n  GetExtensions,\n} from './types'\nimport { MessageParser, Parser } from './parser'\nimport { isUpToDateMessage } from './helpers'\nimport {\n  FetchError,\n  FetchBackoffAbortError,\n  MissingShapeUrlError,\n  InvalidSignalError,\n  MissingShapeHandleError,\n  ReservedParamError,\n} from './error'\nimport {\n  BackoffDefaults,\n  BackoffOptions,\n  createFetchWithBackoff,\n  createFetchWithChunkBuffer,\n  createFetchWithResponseHeadersCheck,\n} from './fetch'\nimport {\n  CHUNK_LAST_OFFSET_HEADER,\n  LIVE_CACHE_BUSTER_HEADER,\n  LIVE_CACHE_BUSTER_QUERY_PARAM,\n  COLUMNS_QUERY_PARAM,\n  LIVE_QUERY_PARAM,\n  OFFSET_QUERY_PARAM,\n  SHAPE_HANDLE_HEADER,\n  SHAPE_HANDLE_QUERY_PARAM,\n  SHAPE_SCHEMA_HEADER,\n  WHERE_QUERY_PARAM,\n  WHERE_PARAMS_PARAM,\n  TABLE_QUERY_PARAM,\n  REPLICA_PARAM,\n  FORCE_DISCONNECT_AND_REFRESH,\n} from './constants'\n\nconst RESERVED_PARAMS: Set<ReservedParamKeys> = new Set([\n  LIVE_CACHE_BUSTER_QUERY_PARAM,\n  SHAPE_HANDLE_QUERY_PARAM,\n  LIVE_QUERY_PARAM,\n  OFFSET_QUERY_PARAM,\n])\n\ntype Replica = `full` | `default`\n\n/**\n * PostgreSQL-specific shape parameters that can be provided externally\n */\nexport interface PostgresParams {\n  /** The root table for the shape. Not required if you set the table in your proxy. */\n  table?: string\n\n  /**\n   * The columns to include in the shape.\n   * Must include primary keys, and can only include valid columns.\n   */\n  columns?: string[]\n\n  /** The where clauses for the shape */\n  where?: string\n\n  /**\n   * Positional where clause paramater values. These will be passed to the server\n   * and will substitute `$i` parameters in the where clause.\n   *\n   * It can be an array (note that positional arguments start at 1, the array will be mapped\n   * accordingly), or an object with keys matching the used positional parameters in the where clause.\n   *\n   * If where clause is `id = $1 or id = $2`, params must have keys `\"1\"` and `\"2\"`, or be an array with length 2.\n   */\n  params?: Record<`${number}`, string> | string[]\n\n  /**\n   * If `replica` is `default` (the default) then Electric will only send the\n   * changed columns in an update.\n   *\n   * If it's `full` Electric will send the entire row with both changed and\n   * unchanged values. `old_value` will also be present on update messages,\n   * containing the previous value for changed columns.\n   *\n   * Setting `replica` to `full` will result in higher bandwidth\n   * usage and so is not generally recommended.\n   */\n  replica?: Replica\n}\ntype SerializableParamValue = string | string[] | Record<string, string>\ntype ParamValue =\n  | SerializableParamValue\n  | (() => SerializableParamValue | Promise<SerializableParamValue>)\n\n/**\n * External params type - what users provide.\n * Excludes reserved parameters to prevent dynamic variations that could cause stream shape changes.\n */\nexport type ExternalParamsRecord = {\n  [K in string as K extends ReservedParamKeys ? never : K]:\n    | ParamValue\n    | undefined\n} & Partial<PostgresParams>\n\ntype ReservedParamKeys =\n  | typeof LIVE_CACHE_BUSTER_QUERY_PARAM\n  | typeof SHAPE_HANDLE_QUERY_PARAM\n  | typeof LIVE_QUERY_PARAM\n  | typeof OFFSET_QUERY_PARAM\n\n/**\n * External headers type - what users provide.\n * Allows string or function values for any header.\n */\nexport type ExternalHeadersRecord = {\n  [key: string]: string | (() => string | Promise<string>)\n}\n\n/**\n * Internal params type - used within the library.\n * All values are converted to strings.\n */\ntype InternalParamsRecord = {\n  [K in string as K extends ReservedParamKeys ? never : K]:\n    | string\n    | Record<string, string>\n}\n\n/**\n * Helper function to resolve a function or value to its final value\n */\nexport async function resolveValue<T>(\n  value: T | (() => T | Promise<T>)\n): Promise<T> {\n  if (typeof value === `function`) {\n    return (value as () => T | Promise<T>)()\n  }\n  return value\n}\n\n/**\n * Helper function to convert external params to internal format\n */\nasync function toInternalParams(\n  params: ExternalParamsRecord\n): Promise<InternalParamsRecord> {\n  const entries = Object.entries(params)\n  const resolvedEntries = await Promise.all(\n    entries.map(async ([key, value]) => {\n      if (value === undefined) return [key, undefined]\n      const resolvedValue = await resolveValue(value)\n      return [\n        key,\n        Array.isArray(resolvedValue) ? resolvedValue.join(`,`) : resolvedValue,\n      ]\n    })\n  )\n\n  return Object.fromEntries(\n    resolvedEntries.filter(([_, value]) => value !== undefined)\n  )\n}\n\n/**\n * Helper function to resolve headers\n */\nasync function resolveHeaders(\n  headers?: ExternalHeadersRecord\n): Promise<Record<string, string>> {\n  if (!headers) return {}\n\n  const entries = Object.entries(headers)\n  const resolvedEntries = await Promise.all(\n    entries.map(async ([key, value]) => [key, await resolveValue(value)])\n  )\n\n  return Object.fromEntries(resolvedEntries)\n}\n\ntype RetryOpts = {\n  params?: ExternalParamsRecord\n  headers?: ExternalHeadersRecord\n}\n\ntype ShapeStreamErrorHandler = (\n  error: Error\n) => void | RetryOpts | Promise<void | RetryOpts>\n\n/**\n * Options for constructing a ShapeStream.\n */\nexport interface ShapeStreamOptions<T = never> {\n  /**\n   * The full URL to where the Shape is served. This can either be the Electric server\n   * directly or a proxy. E.g. for a local Electric instance, you might set `http://localhost:3000/v1/shape`\n   */\n  url: string\n\n  /**\n   * The \"offset\" on the shape log. This is typically not set as the ShapeStream\n   * will handle this automatically. A common scenario where you might pass an offset\n   * is if you're maintaining a local cache of the log. If you've gone offline\n   * and are re-starting a ShapeStream to catch-up to the latest state of the Shape,\n   * you'd pass in the last offset and shapeHandle you'd seen from the Electric server\n   * so it knows at what point in the shape to catch you up from.\n   */\n  offset?: Offset\n\n  /**\n   * Similar to `offset`, this isn't typically used unless you're maintaining\n   * a cache of the shape log.\n   */\n  handle?: string\n\n  /**\n   * HTTP headers to attach to requests made by the client.\n   * Values can be strings or functions (sync or async) that return strings.\n   * Function values are resolved in parallel when needed, making this useful\n   * for authentication tokens or other dynamic headers.\n   */\n  headers?: ExternalHeadersRecord\n\n  /**\n   * Additional request parameters to attach to the URL.\n   * Values can be strings, string arrays, or functions (sync or async) that return these types.\n   * Function values are resolved in parallel when needed, making this useful\n   * for user-specific parameters or dynamic filters.\n   *\n   * These will be merged with Electric's standard parameters.\n   * Note: You cannot use Electric's reserved parameter names\n   * (offset, handle, live, cursor).\n   *\n   * PostgreSQL-specific options like table, where, columns, and replica\n   * should be specified here.\n   */\n  params?: ExternalParamsRecord\n\n  /**\n   * Automatically fetch updates to the Shape. If you just want to sync the current\n   * shape and stop, pass false.\n   */\n  subscribe?: boolean\n\n  signal?: AbortSignal\n  fetchClient?: typeof fetch\n  backoffOptions?: BackoffOptions\n  parser?: Parser<T>\n\n  /**\n   * A function for handling shapestream errors.\n   * This is optional, when it is not provided any shapestream errors will be thrown.\n   * If the function returns an object containing parameters and/or headers\n   * the shapestream will apply those changes and try syncing again.\n   * If the function returns void the shapestream is stopped.\n   */\n  onError?: ShapeStreamErrorHandler\n}\n\nexport interface ShapeStreamInterface<T extends Row<unknown> = Row> {\n  subscribe(\n    callback: (messages: Message<T>[]) => MaybePromise<void>,\n    onError?: (error: FetchError | Error) => void\n  ): () => void\n  unsubscribeAll(): void\n\n  isLoading(): boolean\n  lastSyncedAt(): number | undefined\n  lastSynced(): number\n  isConnected(): boolean\n  hasStarted(): boolean\n\n  isUpToDate: boolean\n  lastOffset: Offset\n  shapeHandle?: string\n  error?: unknown\n\n  forceDisconnectAndRefresh(): Promise<void>\n}\n\n/**\n * Reads updates to a shape from Electric using HTTP requests and long polling. Notifies subscribers\n * when new messages come in. Doesn't maintain any history of the\n * log but does keep track of the offset position and is the best way\n * to consume the HTTP `GET /v1/shape` api.\n *\n * @constructor\n * @param {ShapeStreamOptions} options - configure the shape stream\n * @example\n * Register a callback function to subscribe to the messages.\n * ```\n * const stream = new ShapeStream(options)\n * stream.subscribe(messages => {\n *   // messages is 1 or more row updates\n * })\n * ```\n *\n * To abort the stream, abort the `signal`\n * passed in via the `ShapeStreamOptions`.\n * ```\n * const aborter = new AbortController()\n * const issueStream = new ShapeStream({\n *   url: `${BASE_URL}/${table}`\n *   subscribe: true,\n *   signal: aborter.signal,\n * })\n * // Later...\n * aborter.abort()\n * ```\n */\n\nexport class ShapeStream<T extends Row<unknown> = Row>\n  implements ShapeStreamInterface<T>\n{\n  static readonly Replica = {\n    FULL: `full` as Replica,\n    DEFAULT: `default` as Replica,\n  }\n\n  readonly options: ShapeStreamOptions<GetExtensions<T>>\n  #error: unknown = null\n\n  readonly #fetchClient: typeof fetch\n  readonly #messageParser: MessageParser<T>\n\n  readonly #subscribers = new Map<\n    number,\n    [\n      (messages: Message<T>[]) => MaybePromise<void>,\n      ((error: Error) => void) | undefined,\n    ]\n  >()\n\n  #started = false\n  #lastOffset: Offset\n  #liveCacheBuster: string // Seconds since our Electric Epoch 😎\n  #lastSyncedAt?: number // unix time\n  #isUpToDate: boolean = false\n  #connected: boolean = false\n  #shapeHandle?: string\n  #schema?: Schema\n  #onError?: ShapeStreamErrorHandler\n  #requestAbortController?: AbortController\n  #isRefreshing = false\n  #tickPromise?: Promise<void>\n  #tickPromiseResolver?: () => void\n  #tickPromiseRejecter?: (reason?: unknown) => void\n\n  constructor(options: ShapeStreamOptions<GetExtensions<T>>) {\n    this.options = { subscribe: true, ...options }\n    validateOptions(this.options)\n    this.#lastOffset = this.options.offset ?? `-1`\n    this.#liveCacheBuster = ``\n    this.#shapeHandle = this.options.handle\n    this.#messageParser = new MessageParser<T>(options.parser)\n    this.#onError = this.options.onError\n\n    const baseFetchClient =\n      options.fetchClient ??\n      ((...args: Parameters<typeof fetch>) => fetch(...args))\n\n    const fetchWithBackoffClient = createFetchWithBackoff(baseFetchClient, {\n      ...(options.backoffOptions ?? BackoffDefaults),\n      onFailedAttempt: () => {\n        this.#connected = false\n        options.backoffOptions?.onFailedAttempt?.()\n      },\n    })\n\n    this.#fetchClient = createFetchWithResponseHeadersCheck(\n      createFetchWithChunkBuffer(fetchWithBackoffClient)\n    )\n  }\n\n  get shapeHandle() {\n    return this.#shapeHandle\n  }\n\n  get error() {\n    return this.#error\n  }\n\n  get isUpToDate() {\n    return this.#isUpToDate\n  }\n\n  get lastOffset() {\n    return this.#lastOffset\n  }\n\n  async #start() {\n    if (this.#started) throw new Error(`Cannot start stream twice`)\n    this.#started = true\n\n    try {\n      while (\n        (!this.options.signal?.aborted && !this.#isUpToDate) ||\n        this.options.subscribe\n      ) {\n        const { url, signal } = this.options\n\n        // Resolve headers and params in parallel\n        const [requestHeaders, params] = await Promise.all([\n          resolveHeaders(this.options.headers),\n          this.options.params\n            ? toInternalParams(convertWhereParamsToObj(this.options.params))\n            : undefined,\n        ])\n\n        // Validate params after resolution\n        if (params) {\n          validateParams(params)\n        }\n\n        const fetchUrl = new URL(url)\n\n        // Add PostgreSQL-specific parameters\n        if (params) {\n          if (params.table)\n            setQueryParam(fetchUrl, TABLE_QUERY_PARAM, params.table)\n          if (params.where)\n            setQueryParam(fetchUrl, WHERE_QUERY_PARAM, params.where)\n          if (params.columns)\n            setQueryParam(fetchUrl, COLUMNS_QUERY_PARAM, params.columns)\n          if (params.replica)\n            setQueryParam(fetchUrl, REPLICA_PARAM, params.replica)\n          if (params.params)\n            setQueryParam(fetchUrl, WHERE_PARAMS_PARAM, params.params)\n\n          // Add any remaining custom parameters\n          const customParams = { ...params }\n          delete customParams.table\n          delete customParams.where\n          delete customParams.columns\n          delete customParams.replica\n          delete customParams.params\n\n          for (const [key, value] of Object.entries(customParams)) {\n            setQueryParam(fetchUrl, key, value)\n          }\n        }\n\n        // Add Electric's internal parameters\n        fetchUrl.searchParams.set(OFFSET_QUERY_PARAM, this.#lastOffset)\n\n        if (this.#isUpToDate) {\n          if (!this.#isRefreshing) {\n            fetchUrl.searchParams.set(LIVE_QUERY_PARAM, `true`)\n          }\n          fetchUrl.searchParams.set(\n            LIVE_CACHE_BUSTER_QUERY_PARAM,\n            this.#liveCacheBuster\n          )\n        }\n\n        if (this.#shapeHandle) {\n          // This should probably be a header for better cache breaking?\n          fetchUrl.searchParams.set(\n            SHAPE_HANDLE_QUERY_PARAM,\n            this.#shapeHandle!\n          )\n        }\n\n        // sort query params in-place for stable URLs and improved cache hits\n        fetchUrl.searchParams.sort()\n\n        // Create a new AbortController for this request\n        this.#requestAbortController = new AbortController()\n\n        // If user provided a signal, listen to it and pass on the reason for the abort\n        let abortListener: (() => void) | undefined\n        if (signal) {\n          abortListener = () => {\n            this.#requestAbortController?.abort(signal.reason)\n          }\n          signal.addEventListener(`abort`, abortListener, { once: true })\n          if (signal.aborted) {\n            // If the signal is already aborted, abort the request immediately\n            this.#requestAbortController?.abort(signal.reason)\n          }\n        }\n\n        let response!: Response\n        try {\n          response = await this.#fetchClient(fetchUrl.toString(), {\n            signal: this.#requestAbortController.signal,\n            headers: requestHeaders,\n          })\n          this.#connected = true\n        } catch (e) {\n          // Handle abort error triggered by refresh\n          if (\n            (e instanceof FetchError || e instanceof FetchBackoffAbortError) &&\n            this.#requestAbortController.signal.aborted &&\n            this.#requestAbortController.signal.reason ===\n              FORCE_DISCONNECT_AND_REFRESH\n          ) {\n            // Loop back to the top of the while loop to start a new request\n            continue\n          }\n\n          if (e instanceof FetchBackoffAbortError) break // interrupted\n          if (!(e instanceof FetchError)) throw e // should never happen\n\n          if (e.status == 409) {\n            // Upon receiving a 409, we should start from scratch\n            // with the newly provided shape handle\n            const newShapeHandle = e.headers[SHAPE_HANDLE_HEADER]\n            this.#reset(newShapeHandle)\n            await this.#publish(e.json as Message<T>[])\n            continue\n          } else if (e.status >= 400 && e.status < 500) {\n            // Notify subscribers\n            this.#sendErrorToSubscribers(e)\n\n            // 400 errors are not actionable without additional user input,\n            // so we exit the loop\n            throw e\n          }\n        } finally {\n          if (abortListener && signal) {\n            signal.removeEventListener(`abort`, abortListener)\n          }\n          this.#requestAbortController = undefined\n        }\n\n        const { headers, status } = response\n        const shapeHandle = headers.get(SHAPE_HANDLE_HEADER)\n        if (shapeHandle) {\n          this.#shapeHandle = shapeHandle\n        }\n\n        const lastOffset = headers.get(CHUNK_LAST_OFFSET_HEADER)\n        if (lastOffset) {\n          this.#lastOffset = lastOffset as Offset\n        }\n\n        const liveCacheBuster = headers.get(LIVE_CACHE_BUSTER_HEADER)\n        if (liveCacheBuster) {\n          this.#liveCacheBuster = liveCacheBuster\n        }\n\n        const getSchema = (): Schema => {\n          const schemaHeader = headers.get(SHAPE_SCHEMA_HEADER)\n          return schemaHeader ? JSON.parse(schemaHeader) : {}\n        }\n        this.#schema = this.#schema ?? getSchema()\n\n        const messages = status === 204 ? `[]` : await response.text()\n\n        if (status === 204) {\n          // There's no content so we are live and up to date\n          this.#lastSyncedAt = Date.now()\n        }\n\n        const batch = this.#messageParser.parse(messages, this.#schema)\n\n        // Update isUpToDate\n        if (batch.length > 0) {\n          const lastMessage = batch[batch.length - 1]\n          if (isUpToDateMessage(lastMessage)) {\n            this.#lastSyncedAt = Date.now()\n            this.#isUpToDate = true\n          }\n\n          await this.#publish(batch)\n        }\n\n        this.#tickPromiseResolver?.()\n      }\n    } catch (err) {\n      this.#error = err\n      if (this.#onError) {\n        const retryOpts = await this.#onError(err as Error)\n        if (typeof retryOpts === `object`) {\n          this.#reset()\n\n          if (`params` in retryOpts) {\n            this.options.params = retryOpts.params\n          }\n\n          if (`headers` in retryOpts) {\n            this.options.headers = retryOpts.headers\n          }\n\n          // Restart\n          this.#started = false\n          this.#start()\n        }\n        return\n      }\n\n      // If no handler is provided for errors just throw so the error still bubbles up.\n      throw err\n    } finally {\n      this.#connected = false\n      this.#tickPromiseRejecter?.()\n    }\n  }\n\n  subscribe(\n    callback: (messages: Message<T>[]) => MaybePromise<void>,\n    onError: (error: Error) => void = () => {}\n  ) {\n    const subscriptionId = Math.random()\n\n    this.#subscribers.set(subscriptionId, [callback, onError])\n    if (!this.#started) this.#start()\n\n    return () => {\n      this.#subscribers.delete(subscriptionId)\n    }\n  }\n\n  unsubscribeAll(): void {\n    this.#subscribers.clear()\n  }\n\n  /** Unix time at which we last synced. Undefined when `isLoading` is true. */\n  lastSyncedAt(): number | undefined {\n    return this.#lastSyncedAt\n  }\n\n  /** Time elapsed since last sync (in ms). Infinity if we did not yet sync. */\n  lastSynced(): number {\n    if (this.#lastSyncedAt === undefined) return Infinity\n    return Date.now() - this.#lastSyncedAt\n  }\n\n  /** Indicates if we are connected to the Electric sync service. */\n  isConnected(): boolean {\n    return this.#connected\n  }\n\n  /** True during initial fetch. False afterwise.  */\n  isLoading(): boolean {\n    return !this.#isUpToDate\n  }\n\n  hasStarted(): boolean {\n    return this.#started\n  }\n\n  /** Await the next tick of the request loop */\n  async #nextTick() {\n    if (this.#tickPromise) {\n      return this.#tickPromise\n    }\n    this.#tickPromise = new Promise((resolve, reject) => {\n      this.#tickPromiseResolver = resolve\n      this.#tickPromiseRejecter = reject\n    })\n    this.#tickPromise.finally(() => {\n      this.#tickPromise = undefined\n      this.#tickPromiseResolver = undefined\n      this.#tickPromiseRejecter = undefined\n    })\n    return this.#tickPromise\n  }\n\n  /**\n   * Refreshes the shape stream.\n   * This preemptively aborts any ongoing long poll and reconnects without\n   * long polling, ensuring that the stream receives an up to date message with the\n   * latest LSN from Postgres at that point in time.\n   */\n  async forceDisconnectAndRefresh(): Promise<void> {\n    this.#isRefreshing = true\n    if (this.#isUpToDate && !this.#requestAbortController?.signal.aborted) {\n      // If we are \"up to date\", any current request will be a \"live\" request\n      // and needs to be aborted\n      this.#requestAbortController?.abort(FORCE_DISCONNECT_AND_REFRESH)\n    }\n    await this.#nextTick()\n    this.#isRefreshing = false\n  }\n\n  async #publish(messages: Message<T>[]): Promise<void> {\n    await Promise.all(\n      Array.from(this.#subscribers.values()).map(async ([callback, __]) => {\n        try {\n          await callback(messages)\n        } catch (err) {\n          queueMicrotask(() => {\n            throw err\n          })\n        }\n      })\n    )\n  }\n\n  #sendErrorToSubscribers(error: Error) {\n    this.#subscribers.forEach(([_, errorFn]) => {\n      errorFn?.(error)\n    })\n  }\n\n  /**\n   * Resets the state of the stream, optionally with a provided\n   * shape handle\n   */\n  #reset(handle?: string) {\n    this.#lastOffset = `-1`\n    this.#liveCacheBuster = ``\n    this.#shapeHandle = handle\n    this.#isUpToDate = false\n    this.#connected = false\n    this.#schema = undefined\n  }\n}\n\n/**\n * Validates that no reserved parameter names are used in the provided params object\n * @throws {ReservedParamError} if any reserved parameter names are found\n */\nfunction validateParams(params: Record<string, unknown> | undefined): void {\n  if (!params) return\n\n  const reservedParams = Object.keys(params).filter((key) =>\n    RESERVED_PARAMS.has(key as ReservedParamKeys)\n  )\n  if (reservedParams.length > 0) {\n    throw new ReservedParamError(reservedParams)\n  }\n}\n\nfunction validateOptions<T>(options: Partial<ShapeStreamOptions<T>>): void {\n  if (!options.url) {\n    throw new MissingShapeUrlError()\n  }\n  if (options.signal && !(options.signal instanceof AbortSignal)) {\n    throw new InvalidSignalError()\n  }\n\n  if (\n    options.offset !== undefined &&\n    options.offset !== `-1` &&\n    !options.handle\n  ) {\n    throw new MissingShapeHandleError()\n  }\n\n  validateParams(options.params)\n\n  return\n}\n\n// `unknown` being in the value is a bit of defensive programming if user doesn't use TS\nfunction setQueryParam(\n  url: URL,\n  key: string,\n  value: Record<string, string> | string | unknown\n): void {\n  if (value === undefined || value == null) {\n    return\n  } else if (typeof value === `string`) {\n    url.searchParams.set(key, value)\n  } else if (typeof value === `object`) {\n    for (const [k, v] of Object.entries(value)) {\n      url.searchParams.set(`${key}[${k}]`, v)\n    }\n  } else {\n    url.searchParams.set(key, value.toString())\n  }\n}\n\nfunction convertWhereParamsToObj(\n  allPgParams: ExternalParamsRecord\n): ExternalParamsRecord {\n  if (Array.isArray(allPgParams.params)) {\n    return {\n      ...allPgParams,\n      params: Object.fromEntries(allPgParams.params.map((v, i) => [i + 1, v])),\n    }\n  }\n  return allPgParams\n}\n","import { Message, Offset, Row } from './types'\nimport { isChangeMessage, isControlMessage } from './helpers'\nimport { FetchError } from './error'\nimport { ShapeStreamInterface } from './client'\n\nexport type ShapeData<T extends Row<unknown> = Row> = Map<string, T>\nexport type ShapeChangedCallback<T extends Row<unknown> = Row> = (data: {\n  value: ShapeData<T>\n  rows: T[]\n}) => void\n\ntype ShapeStatus = `syncing` | `up-to-date`\n\n/**\n * A Shape is an object that subscribes to a shape log,\n * keeps a materialised shape `.rows` in memory and\n * notifies subscribers when the value has changed.\n *\n * It can be used without a framework and as a primitive\n * to simplify developing framework hooks.\n *\n * @constructor\n * @param {ShapeStream<T extends Row>} - the underlying shape stream\n * @example\n * ```\n * const shapeStream = new ShapeStream<{ foo: number }>({\n *   url: `http://localhost:3000/v1/shape`,\n *   params: {\n *     table: `foo`\n *   }\n * })\n * const shape = new Shape(shapeStream)\n * ```\n *\n * `rows` returns a promise that resolves the Shape data once the Shape has been\n * fully loaded (and when resuming from being offline):\n *\n *     const rows = await shape.rows\n *\n * `currentRows` returns the current data synchronously:\n *\n *     const rows = shape.currentRows\n *\n *  Subscribe to updates. Called whenever the shape updates in Postgres.\n *\n *     shape.subscribe(({ rows }) => {\n *       console.log(rows)\n *     })\n */\nexport class Shape<T extends Row<unknown> = Row> {\n  readonly stream: ShapeStreamInterface<T>\n\n  readonly #data: ShapeData<T> = new Map()\n  readonly #subscribers = new Map<number, ShapeChangedCallback<T>>()\n  #status: ShapeStatus = `syncing`\n  #error: FetchError | false = false\n\n  constructor(stream: ShapeStreamInterface<T>) {\n    this.stream = stream\n    this.stream.subscribe(\n      this.#process.bind(this),\n      this.#handleError.bind(this)\n    )\n  }\n\n  get isUpToDate(): boolean {\n    return this.#status === `up-to-date`\n  }\n\n  get lastOffset(): Offset {\n    return this.stream.lastOffset\n  }\n\n  get handle(): string | undefined {\n    return this.stream.shapeHandle\n  }\n\n  get rows(): Promise<T[]> {\n    return this.value.then((v) => Array.from(v.values()))\n  }\n\n  get currentRows(): T[] {\n    return Array.from(this.currentValue.values())\n  }\n\n  get value(): Promise<ShapeData<T>> {\n    return new Promise((resolve, reject) => {\n      if (this.stream.isUpToDate) {\n        resolve(this.currentValue)\n      } else {\n        const unsubscribe = this.subscribe(({ value }) => {\n          unsubscribe()\n          if (this.#error) reject(this.#error)\n          resolve(value)\n        })\n      }\n    })\n  }\n\n  get currentValue() {\n    return this.#data\n  }\n\n  get error() {\n    return this.#error\n  }\n\n  /** Unix time at which we last synced. Undefined when `isLoading` is true. */\n  lastSyncedAt(): number | undefined {\n    return this.stream.lastSyncedAt()\n  }\n\n  /** Time elapsed since last sync (in ms). Infinity if we did not yet sync. */\n  lastSynced() {\n    return this.stream.lastSynced()\n  }\n\n  /** True during initial fetch. False afterwise.  */\n  isLoading() {\n    return this.stream.isLoading()\n  }\n\n  /** Indicates if we are connected to the Electric sync service. */\n  isConnected(): boolean {\n    return this.stream.isConnected()\n  }\n\n  subscribe(callback: ShapeChangedCallback<T>): () => void {\n    const subscriptionId = Math.random()\n\n    this.#subscribers.set(subscriptionId, callback)\n\n    return () => {\n      this.#subscribers.delete(subscriptionId)\n    }\n  }\n\n  unsubscribeAll(): void {\n    this.#subscribers.clear()\n  }\n\n  get numSubscribers() {\n    return this.#subscribers.size\n  }\n\n  #process(messages: Message<T>[]): void {\n    let shouldNotify = false\n\n    messages.forEach((message) => {\n      if (isChangeMessage(message)) {\n        shouldNotify = this.#updateShapeStatus(`syncing`)\n        switch (message.headers.operation) {\n          case `insert`:\n            this.#data.set(message.key, message.value)\n            break\n          case `update`:\n            this.#data.set(message.key, {\n              ...this.#data.get(message.key)!,\n              ...message.value,\n            })\n            break\n          case `delete`:\n            this.#data.delete(message.key)\n            break\n        }\n      }\n\n      if (isControlMessage(message)) {\n        switch (message.headers.control) {\n          case `up-to-date`:\n            shouldNotify = this.#updateShapeStatus(`up-to-date`)\n            break\n          case `must-refetch`:\n            this.#data.clear()\n            this.#error = false\n            shouldNotify = this.#updateShapeStatus(`syncing`)\n            break\n        }\n      }\n    })\n\n    if (shouldNotify) this.#notify()\n  }\n\n  #updateShapeStatus(status: ShapeStatus): boolean {\n    const stateChanged = this.#status !== status\n    this.#status = status\n    return stateChanged && status === `up-to-date`\n  }\n\n  #handleError(e: Error): void {\n    if (e instanceof FetchError) {\n      this.#error = e\n      this.#notify()\n    }\n  }\n\n  #notify(): void {\n    this.#subscribers.forEach((callback) => {\n      callback({ value: this.currentValue, rows: this.currentRows })\n    })\n  }\n}\n"],"mappings":"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","names":["FetchError","_FetchError","status","text","json","headers","url","message","response","__async","contentType","FetchBackoffAbortError","MissingShapeUrlError","InvalidSignalError","MissingShapeHandleError","ReservedParamError","reservedParams","ParserNullValueError","columnName","MissingHeadersError","url","missingHeaders","msg","h","parseNumber","value","parseBool","parseBigInt","parseJson","identityParser","v","defaultParser","pgArrayParser","parser","i","char","str","quoted","last","p","loop","x","xs","MessageParser","__spreadValues","messages","schema","key","row","_b","columnInfo","_a","typ","dimensions","additionalInfo","__objRest","typeParser","makeNullableParser","_","columnName","isNullable","isPgNull","ParserNullValueError","isChangeMessage","message","isControlMessage","isUpToDateMessage","LIVE_CACHE_BUSTER_HEADER","SHAPE_HANDLE_HEADER","CHUNK_LAST_OFFSET_HEADER","SHAPE_SCHEMA_HEADER","CHUNK_UP_TO_DATE_HEADER","COLUMNS_QUERY_PARAM","LIVE_CACHE_BUSTER_QUERY_PARAM","SHAPE_HANDLE_QUERY_PARAM","LIVE_QUERY_PARAM","OFFSET_QUERY_PARAM","TABLE_QUERY_PARAM","WHERE_QUERY_PARAM","REPLICA_PARAM","WHERE_PARAMS_PARAM","FORCE_DISCONNECT_AND_REFRESH","HTTP_RETRY_STATUS_CODES","BackoffDefaults","createFetchWithBackoff","fetchClient","backoffOptions","initialDelay","maxDelay","multiplier","debug","onFailedAttempt","args","__async","_a","url","options","delay","attempt","result","FetchError","e","FetchBackoffAbortError","resolve","ChunkPrefetchDefaults","createFetchWithChunkBuffer","prefetchOptions","maxChunksToPrefetch","prefetchQueue","prefetchedRequest","response","nextUrl","getNextChunkUrl","PrefetchQueue","requiredElectricResponseHeaders","requiredLiveResponseHeaders","requiredNonLiveResponseHeaders","createFetchWithResponseHeadersCheck","headers","missingHeaders","addMissingHeaders","requiredHeaders","h","urlString","LIVE_QUERY_PARAM","MissingHeadersError","_fetchClient","_maxPrefetchedRequests","_prefetchQueue","_queueHeadUrl","_queueTailUrl","_PrefetchQueue_instances","prefetch_fn","__privateAdd","__privateSet","__privateGet","__privateMethod","_","aborter","request","_b","signal","cleanup","chainAborter","__spreadProps","__spreadValues","res","shapeHandle","SHAPE_HANDLE_HEADER","lastOffset","CHUNK_LAST_OFFSET_HEADER","isUpToDate","CHUNK_UP_TO_DATE_HEADER","SHAPE_HANDLE_QUERY_PARAM","OFFSET_QUERY_PARAM","sourceSignal","noop","abortParent","RESERVED_PARAMS","LIVE_CACHE_BUSTER_QUERY_PARAM","SHAPE_HANDLE_QUERY_PARAM","LIVE_QUERY_PARAM","OFFSET_QUERY_PARAM","resolveValue","value","__async","toInternalParams","params","entries","resolvedEntries","_0","key","resolvedValue","_","resolveHeaders","headers","_error","_fetchClient","_messageParser","_subscribers","_started","_lastOffset","_liveCacheBuster","_lastSyncedAt","_isUpToDate","_connected","_shapeHandle","_schema","_onError","_requestAbortController","_isRefreshing","_tickPromise","_tickPromiseResolver","_tickPromiseRejecter","_ShapeStream_instances","start_fn","nextTick_fn","publish_fn","sendErrorToSubscribers_fn","reset_fn","ShapeStream","options","__privateAdd","_a","_b","_c","__spreadValues","validateOptions","__privateSet","MessageParser","baseFetchClient","args","fetchWithBackoffClient","createFetchWithBackoff","__spreadProps","BackoffDefaults","createFetchWithResponseHeadersCheck","createFetchWithChunkBuffer","__privateGet","callback","onError","subscriptionId","__privateMethod","FORCE_DISCONNECT_AND_REFRESH","_d","_e","url","signal","requestHeaders","convertWhereParamsToObj","validateParams","fetchUrl","setQueryParam","TABLE_QUERY_PARAM","WHERE_QUERY_PARAM","COLUMNS_QUERY_PARAM","REPLICA_PARAM","WHERE_PARAMS_PARAM","customParams","abortListener","response","e","FetchError","FetchBackoffAbortError","newShapeHandle","SHAPE_HANDLE_HEADER","status","shapeHandle","lastOffset","CHUNK_LAST_OFFSET_HEADER","liveCacheBuster","LIVE_CACHE_BUSTER_HEADER","getSchema","schemaHeader","SHAPE_SCHEMA_HEADER","messages","batch","lastMessage","isUpToDateMessage","err","retryOpts","resolve","reject","__","error","errorFn","handle","reservedParams","ReservedParamError","MissingShapeUrlError","InvalidSignalError","MissingShapeHandleError","k","v","allPgParams","i","_data","_subscribers","_status","_error","_Shape_instances","process_fn","updateShapeStatus_fn","handleError_fn","notify_fn","Shape","stream","__privateAdd","__privateMethod","__privateGet","v","resolve","reject","unsubscribe","value","callback","subscriptionId","messages","shouldNotify","message","isChangeMessage","__spreadValues","isControlMessage","__privateSet","status","stateChanged","FetchError"]}