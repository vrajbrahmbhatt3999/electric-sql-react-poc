{"version":3,"sources":["../src/match.ts","../src/bigint-utils.ts","../src/multi-shape-stream.ts"],"sourcesContent":["import {\n  isChangeMessage,\n  type ShapeStreamInterface,\n  type ChangeMessage,\n  type GetExtensions,\n  type Operation,\n  type Row,\n  type Value,\n  type Message,\n} from '@electric-sql/client'\n\nexport function matchStream<T extends Row<unknown>>(\n  stream: ShapeStreamInterface<T>,\n  operations: Array<Operation>,\n  matchFn: (message: ChangeMessage<T>) => boolean,\n  timeout = 60000 // ms\n): Promise<ChangeMessage<T>> {\n  return new Promise<ChangeMessage<T>>((resolve, reject) => {\n    const unsubscribe: () => void = stream.subscribe(\n      (messages: Array<unknown>) => {\n        const message = messages\n          .filter((msg): msg is ChangeMessage<T> =>\n            isChangeMessage(msg as Message<Row<never>>)\n          )\n          .find((message) => {\n            const operation: Operation = message.headers.operation\n\n            return operations.includes(operation) && matchFn(message)\n          })\n\n        if (message) {\n          return finish(message)\n        }\n      }\n    )\n\n    const timeoutId: NodeJS.Timeout = setTimeout(() => {\n      const msg: string = `matchStream timed out after ${timeout}ms`\n\n      console.error(msg)\n\n      reject(msg)\n    }, timeout)\n\n    function finish(message: ChangeMessage<T>): void {\n      clearTimeout(timeoutId)\n\n      unsubscribe()\n\n      return resolve(message)\n    }\n  })\n}\n\nexport function matchBy<T extends Row<unknown>>(\n  column: string,\n  value: Value<GetExtensions<T>>\n): (message: ChangeMessage<T>) => boolean {\n  return (message: ChangeMessage<T>) => message.value[column] === value\n}\n","export function bigIntMax(...args: Array<bigint | number>): bigint {\n  return BigInt(args.reduce((m, e) => (e > m ? e : m)))\n}\n\nexport function bigIntMin(...args: Array<bigint | number>): bigint {\n  return BigInt(args.reduce((m, e) => (e < m ? e : m)))\n}\n\nexport function bigIntCompare(a: bigint, b: bigint): 1 | -1 | 0 {\n  return a > b ? 1 : a < b ? -1 : 0\n}\n","import { bigIntCompare, bigIntMax, bigIntMin } from './bigint-utils'\nimport {\n  ShapeStream,\n  isChangeMessage,\n  isControlMessage,\n} from '@electric-sql/client'\nimport type {\n  ChangeMessage,\n  ControlMessage,\n  FetchError,\n  MaybePromise,\n  Row,\n  ShapeStreamOptions,\n} from '@electric-sql/client'\n\ninterface MultiShapeStreamOptions<\n  TShapeRows extends {\n    [K: string]: Row<unknown>\n  } = {\n    [K: string]: Row<unknown>\n  },\n> {\n  shapes: {\n    [K in keyof TShapeRows]:\n      | ShapeStreamOptions<TShapeRows[K]>\n      | ShapeStream<TShapeRows[K]>\n  }\n  start?: boolean\n  checkForUpdatesAfterMs?: number // milliseconds\n}\n\ninterface MultiShapeChangeMessage<\n  T extends Row<unknown>,\n  ShapeNames extends string,\n> extends ChangeMessage<T> {\n  shape: ShapeNames\n}\n\ninterface MultiShapeControlMessage<ShapeNames extends string>\n  extends ControlMessage {\n  shape: ShapeNames\n}\n\ntype MultiShapeMessage<T extends Row<unknown>, ShapeNames extends string> =\n  | MultiShapeChangeMessage<T, ShapeNames>\n  | MultiShapeControlMessage<ShapeNames>\n\nexport type MultiShapeMessages<\n  TShapeRows extends {\n    [K: string]: Row<unknown>\n  },\n> = {\n  [K in keyof TShapeRows & string]: MultiShapeMessage<TShapeRows[K], K>\n}[keyof TShapeRows & string]\n\nexport interface MultiShapeStreamInterface<\n  TShapeRows extends {\n    [K: string]: Row<unknown>\n  },\n> {\n  shapes: { [K in keyof TShapeRows]: ShapeStream<TShapeRows[K]> }\n  checkForUpdatesAfterMs?: number\n\n  subscribe(\n    callback: (\n      messages: MultiShapeMessages<TShapeRows>[]\n    ) => MaybePromise<void>,\n    onError?: (error: FetchError | Error) => void\n  ): () => void\n  unsubscribeAll(): void\n\n  lastSyncedAt(): number | undefined\n  lastSynced(): number\n  isConnected(): boolean\n  isLoading(): boolean\n\n  isUpToDate: boolean\n}\n\n/**\n * A multi-shape stream is a stream that can subscribe to multiple shapes.\n * It ensures that all shapes will receive at least an `up-to-date` message from\n * Electric within the `checkForUpdatesAfterMs` interval.\n *\n * @constructor\n * @param {MultiShapeStreamOptions} options - configure the multi-shape stream\n * @example\n * ```ts\n * const multiShapeStream = new MultiShapeStream({\n *   shapes: {\n *     shape1: {\n *       url: 'http://localhost:3000/v1/shape1',\n *     },\n *     shape2: {\n *       url: 'http://localhost:3000/v1/shape2',\n *     },\n *   },\n * })\n *\n * multiShapeStream.subscribe((msgs) => {\n *   console.log(msgs)\n * })\n *\n * // or with ShapeStream instances\n * const multiShapeStream = new MultiShapeStream({\n *   shapes: {\n *     shape1: new ShapeStream({ url: 'http://localhost:3000/v1/shape1' }),\n *     shape2: new ShapeStream({ url: 'http://localhost:3000/v1/shape2' }),\n *   },\n * })\n * ```\n */\n\nexport class MultiShapeStream<\n  TShapeRows extends {\n    [K: string]: Row<unknown>\n  },\n> implements MultiShapeStreamInterface<TShapeRows>\n{\n  #shapes: { [K in keyof TShapeRows]: ShapeStream<TShapeRows[K]> }\n  #started = false\n  checkForUpdatesAfterMs?: number\n\n  #checkForUpdatesTimeout?: ReturnType<typeof setTimeout> | undefined\n\n  // We keep track of the last lsn of data and up-to-date messages for each shape\n  // so that we can skip checkForUpdates if the lsn of the up-to-date message is\n  // greater than the last lsn of data.\n  #lastDataLsns: { [K in keyof TShapeRows]: bigint }\n  #lastUpToDateLsns: { [K in keyof TShapeRows]: bigint }\n\n  readonly #subscribers = new Map<\n    number,\n    [\n      (messages: MultiShapeMessages<TShapeRows>[]) => MaybePromise<void>,\n      ((error: Error) => void) | undefined,\n    ]\n  >()\n\n  constructor(options: MultiShapeStreamOptions<TShapeRows>) {\n    const {\n      start = true, // By default we start the multi-shape stream\n      checkForUpdatesAfterMs = 100, // Force a check for updates after 100ms\n      shapes,\n    } = options\n    this.checkForUpdatesAfterMs = checkForUpdatesAfterMs\n    this.#shapes = Object.fromEntries(\n      Object.entries(shapes).map(([key, shape]) => [\n        key,\n        shape instanceof ShapeStream\n          ? shape\n          : new ShapeStream<TShapeRows[typeof key]>({\n              ...shape,\n              start: false,\n            }),\n      ])\n    ) as { [K in keyof TShapeRows]: ShapeStream<TShapeRows[K]> }\n    this.#lastDataLsns = Object.fromEntries(\n      Object.entries(shapes).map(([key]) => [key, BigInt(-1)])\n    ) as { [K in keyof TShapeRows]: bigint }\n    this.#lastUpToDateLsns = Object.fromEntries(\n      Object.entries(shapes).map(([key]) => [key, BigInt(-1)])\n    ) as { [K in keyof TShapeRows]: bigint }\n    if (start) this.#start()\n  }\n\n  #start() {\n    if (this.#started) throw new Error(`Cannot start multi-shape stream twice`)\n    for (const [key, shape] of this.#shapeEntries()) {\n      if (shape.hasStarted()) {\n        // The multi-shape stream needs to be started together as a whole, and so we\n        // have to check that a shape is not already started.\n        throw new Error(`Shape ${key} already started`)\n      }\n      shape.subscribe(\n        async (messages) => {\n          // Whats the max lsn of the up-to-date messages?\n          const upToDateLsns = messages\n            .filter(isControlMessage)\n            .map(({ headers }) =>\n              typeof headers.global_last_seen_lsn === `string`\n                ? BigInt(headers.global_last_seen_lsn)\n                : BigInt(0)\n            )\n          if (upToDateLsns.length > 0) {\n            const maxUpToDateLsn = bigIntMax(...upToDateLsns)\n            const lastMaxUpToDateLsn = this.#lastUpToDateLsns[key]\n            if (maxUpToDateLsn > lastMaxUpToDateLsn) {\n              this.#lastUpToDateLsns[key] = maxUpToDateLsn\n            }\n          }\n\n          // Whats the max lsn of the data messages?\n          const dataLsns = messages\n            .filter(isChangeMessage)\n            .map(({ headers }) =>\n              typeof headers.lsn === `string` ? BigInt(headers.lsn) : BigInt(0)\n            )\n          if (dataLsns.length > 0) {\n            const maxDataLsn = bigIntMax(...dataLsns)\n            const lastMaxDataLsn = this.#lastDataLsns[key]\n            if (maxDataLsn > lastMaxDataLsn) {\n              this.#lastDataLsns[key] = maxDataLsn\n            }\n            // There is new data, so we need to schedule a check for updates on\n            // other shapes\n            this.#scheduleCheckForUpdates()\n          }\n\n          // Publish the messages to the multi-shape stream subscribers\n          const multiShapeMessages = messages.map(\n            (message) =>\n              ({\n                ...message,\n                shape: key,\n              }) as MultiShapeMessages<TShapeRows>\n          )\n          await this._publish(multiShapeMessages)\n        },\n        (error) => this.#onError(error)\n      )\n    }\n    this.#started = true\n  }\n\n  #scheduleCheckForUpdates() {\n    this.#checkForUpdatesTimeout ??= setTimeout(() => {\n      this.#checkForUpdates()\n      this.#checkForUpdatesTimeout = undefined\n    }, this.checkForUpdatesAfterMs)\n  }\n\n  async #checkForUpdates() {\n    const maxDataLsn = bigIntMax(...Object.values(this.#lastDataLsns))\n    const refreshPromises = this.#shapeEntries()\n      .filter(([key]) => {\n        // We only need to refresh shapes that have not seen an up-to-date message\n        // lower than the max lsn of the data messages we have received.\n        const lastUpToDateLsn = this.#lastUpToDateLsns[key]\n        return lastUpToDateLsn < maxDataLsn\n      })\n      .map(([_, shape]) => {\n        return shape.forceDisconnectAndRefresh()\n      })\n    await Promise.all(refreshPromises)\n  }\n\n  #onError(error: Error) {\n    // TODO: we probably want to disconnect all shapes here on the first error\n    this.#subscribers.forEach(([_, errorFn]) => {\n      errorFn?.(error)\n    })\n  }\n\n  protected async _publish(\n    messages: MultiShapeMessages<TShapeRows>[]\n  ): Promise<void> {\n    await Promise.all(\n      Array.from(this.#subscribers.values()).map(async ([callback, __]) => {\n        try {\n          await callback(messages)\n        } catch (err) {\n          queueMicrotask(() => {\n            throw err\n          })\n        }\n      })\n    )\n  }\n\n  /**\n   * Returns an array of the shape entries.\n   * Ensures that the shape entries are typed, as `Object.entries`\n   * will not type the entries correctly.\n   */\n  #shapeEntries() {\n    return Object.entries(this.#shapes) as [\n      keyof TShapeRows & string,\n      ShapeStream<TShapeRows[string]>,\n    ][]\n  }\n\n  /**\n   * The ShapeStreams that are being subscribed to.\n   */\n  get shapes() {\n    return this.#shapes\n  }\n\n  subscribe(\n    callback: (\n      messages: MultiShapeMessages<TShapeRows>[]\n    ) => MaybePromise<void>,\n    onError?: (error: FetchError | Error) => void\n  ) {\n    const subscriptionId = Math.random()\n\n    this.#subscribers.set(subscriptionId, [callback, onError])\n    if (!this.#started) this.#start()\n\n    return () => {\n      this.#subscribers.delete(subscriptionId)\n    }\n  }\n\n  unsubscribeAll(): void {\n    this.#subscribers.clear()\n  }\n\n  /** Unix time at which we last synced. Undefined when `isLoading` is true. */\n  lastSyncedAt(): number | undefined {\n    // Min of all the lastSyncedAt values\n    return Math.min(\n      ...this.#shapeEntries().map(\n        ([_, shape]) => shape.lastSyncedAt() ?? Infinity\n      )\n    )\n  }\n\n  /** Time elapsed since last sync (in ms). Infinity if we did not yet sync. */\n  lastSynced(): number {\n    const lastSyncedAt = this.lastSyncedAt()\n    if (lastSyncedAt === undefined) return Infinity\n    return Date.now() - lastSyncedAt\n  }\n\n  /** Indicates if we are connected to the Electric sync service. */\n  isConnected(): boolean {\n    return this.#shapeEntries().every(([_, shape]) => shape.isConnected())\n  }\n\n  /** True during initial fetch. False afterwise. */\n  isLoading(): boolean {\n    return this.#shapeEntries().some(([_, shape]) => shape.isLoading())\n  }\n\n  get isUpToDate() {\n    return this.#shapeEntries().every(([_, shape]) => shape.isUpToDate)\n  }\n}\n\n/**\n * A transactional multi-shape stream is a multi-shape stream that emits the\n * messages in transactional batches, ensuring that all shapes will receive\n * at least an `up-to-date` message from Electric within the `checkForUpdatesAfterMs`\n * interval.\n * It uses the `lsn` metadata to infer transaction boundaries, and the `op_position`\n * metadata to sort the messages within a transaction.\n *\n * @constructor\n * @param {MultiShapeStreamOptions} options - configure the multi-shape stream\n * @example\n * ```ts\n * const transactionalMultiShapeStream = new TransactionalMultiShapeStream({\n *   shapes: {\n *     shape1: {\n *       url: 'http://localhost:3000/v1/shape1',\n *     },\n *     shape2: {\n *       url: 'http://localhost:3000/v1/shape2',\n *     },\n *   },\n * })\n *\n * transactionalMultiShapeStream.subscribe((msgs) => {\n *   console.log(msgs)\n * })\n *\n * // or with ShapeStream instances\n * const transactionalMultiShapeStream = new TransactionalMultiShapeStream({\n *   shapes: {\n *     shape1: new ShapeStream({ url: 'http://localhost:3000/v1/shape1' }),\n *     shape2: new ShapeStream({ url: 'http://localhost:3000/v1/shape2' }),\n *   },\n * })\n * ```\n */\n\nexport class TransactionalMultiShapeStream<\n  TShapeRows extends {\n    [K: string]: Row<unknown>\n  },\n> extends MultiShapeStream<TShapeRows> {\n  #changeMessages = new Map<bigint, MultiShapeMessage<Row<unknown>, string>[]>()\n  #completeLsns: {\n    [K in keyof TShapeRows]: bigint\n  }\n\n  constructor(options: MultiShapeStreamOptions<TShapeRows>) {\n    super(options)\n    this.#completeLsns = Object.fromEntries(\n      Object.entries(options.shapes).map(([key]) => [key, BigInt(-1)])\n    ) as { [K in keyof TShapeRows]: bigint }\n  }\n\n  #getLowestCompleteLsn() {\n    return bigIntMin(...Object.values(this.#completeLsns))\n  }\n\n  protected async _publish(\n    messages: MultiShapeMessages<TShapeRows>[]\n  ): Promise<void> {\n    this.#accumulate(messages)\n    const lowestCompleteLsn = this.#getLowestCompleteLsn()\n    const lsnsToPublish = [...this.#changeMessages.keys()].filter(\n      (lsn) => lsn <= lowestCompleteLsn\n    )\n    const messagesToPublish = lsnsToPublish\n      .sort((a, b) => bigIntCompare(a, b))\n      .map((lsn) =>\n        this.#changeMessages.get(lsn)?.sort((a, b) => {\n          const { headers: aHeaders } = a\n          const { headers: bHeaders } = b\n          if (\n            typeof aHeaders.op_position !== `number` ||\n            typeof bHeaders.op_position !== `number`\n          ) {\n            return 0 // op_position is not present on the snapshot message\n          }\n          return aHeaders.op_position - bHeaders.op_position\n        })\n      )\n      .filter((messages) => messages !== undefined)\n      .flat() as MultiShapeMessages<TShapeRows>[]\n    lsnsToPublish.forEach((lsn) => {\n      this.#changeMessages.delete(lsn)\n    })\n    if (messagesToPublish.length > 0) {\n      await super._publish(messagesToPublish)\n    }\n  }\n\n  #accumulate(messages: MultiShapeMessages<TShapeRows>[]) {\n    const isUpToDate = this.isUpToDate\n    messages.forEach((message) => {\n      const { shape, headers } = message\n      if (isChangeMessage(message)) {\n        // The snapshot message does not have an lsn, so we use 0\n        const lsn =\n          typeof headers.lsn === `string` ? BigInt(headers.lsn) : BigInt(0)\n        if (!this.#changeMessages.has(lsn)) {\n          this.#changeMessages.set(lsn, [])\n        }\n        this.#changeMessages.get(lsn)?.push(message)\n        if (\n          isUpToDate && // All shapes must be up to date\n          typeof headers.last === `boolean` &&\n          headers.last === true\n        ) {\n          this.#completeLsns[shape] = bigIntMax(this.#completeLsns[shape], lsn)\n        }\n      } else if (isControlMessage(message)) {\n        if (headers.control === `up-to-date`) {\n          if (typeof headers.global_last_seen_lsn !== `string`) {\n            throw new Error(`global_last_seen_lsn is not a number`)\n          }\n          this.#completeLsns[shape] = bigIntMax(\n            this.#completeLsns[shape],\n            BigInt(headers.global_last_seen_lsn)\n          )\n        }\n      }\n    })\n  }\n}\n"],"mappings":"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","names":["message","isChangeMessage","isChangeMessage","messages"]}