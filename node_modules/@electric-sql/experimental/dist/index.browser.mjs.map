{"version":3,"sources":["../src/match.ts","../src/bigint-utils.ts","../src/multi-shape-stream.ts"],"sourcesContent":["import {\n  isChangeMessage,\n  type ShapeStreamInterface,\n  type ChangeMessage,\n  type GetExtensions,\n  type Operation,\n  type Row,\n  type Value,\n  type Message,\n} from '@electric-sql/client'\n\nexport function matchStream<T extends Row<unknown>>(\n  stream: ShapeStreamInterface<T>,\n  operations: Array<Operation>,\n  matchFn: (message: ChangeMessage<T>) => boolean,\n  timeout = 60000 // ms\n): Promise<ChangeMessage<T>> {\n  return new Promise<ChangeMessage<T>>((resolve, reject) => {\n    const unsubscribe: () => void = stream.subscribe(\n      (messages: Array<unknown>) => {\n        const message = messages\n          .filter((msg): msg is ChangeMessage<T> =>\n            isChangeMessage(msg as Message<Row<never>>)\n          )\n          .find((message) => {\n            const operation: Operation = message.headers.operation\n\n            return operations.includes(operation) && matchFn(message)\n          })\n\n        if (message) {\n          return finish(message)\n        }\n      }\n    )\n\n    const timeoutId: NodeJS.Timeout = setTimeout(() => {\n      const msg: string = `matchStream timed out after ${timeout}ms`\n\n      console.error(msg)\n\n      reject(msg)\n    }, timeout)\n\n    function finish(message: ChangeMessage<T>): void {\n      clearTimeout(timeoutId)\n\n      unsubscribe()\n\n      return resolve(message)\n    }\n  })\n}\n\nexport function matchBy<T extends Row<unknown>>(\n  column: string,\n  value: Value<GetExtensions<T>>\n): (message: ChangeMessage<T>) => boolean {\n  return (message: ChangeMessage<T>) => message.value[column] === value\n}\n","export function bigIntMax(...args: Array<bigint | number>): bigint {\n  return BigInt(args.reduce((m, e) => (e > m ? e : m)))\n}\n\nexport function bigIntMin(...args: Array<bigint | number>): bigint {\n  return BigInt(args.reduce((m, e) => (e < m ? e : m)))\n}\n\nexport function bigIntCompare(a: bigint, b: bigint): 1 | -1 | 0 {\n  return a > b ? 1 : a < b ? -1 : 0\n}\n","import { bigIntCompare, bigIntMax, bigIntMin } from './bigint-utils'\nimport {\n  ShapeStream,\n  isChangeMessage,\n  isControlMessage,\n} from '@electric-sql/client'\nimport type {\n  ChangeMessage,\n  ControlMessage,\n  FetchError,\n  MaybePromise,\n  Row,\n  ShapeStreamOptions,\n} from '@electric-sql/client'\n\ninterface MultiShapeStreamOptions<\n  TShapeRows extends {\n    [K: string]: Row<unknown>\n  } = {\n    [K: string]: Row<unknown>\n  },\n> {\n  shapes: {\n    [K in keyof TShapeRows]:\n      | ShapeStreamOptions<TShapeRows[K]>\n      | ShapeStream<TShapeRows[K]>\n  }\n  start?: boolean\n  checkForUpdatesAfterMs?: number // milliseconds\n}\n\ninterface MultiShapeChangeMessage<\n  T extends Row<unknown>,\n  ShapeNames extends string,\n> extends ChangeMessage<T> {\n  shape: ShapeNames\n}\n\ninterface MultiShapeControlMessage<ShapeNames extends string>\n  extends ControlMessage {\n  shape: ShapeNames\n}\n\ntype MultiShapeMessage<T extends Row<unknown>, ShapeNames extends string> =\n  | MultiShapeChangeMessage<T, ShapeNames>\n  | MultiShapeControlMessage<ShapeNames>\n\nexport type MultiShapeMessages<\n  TShapeRows extends {\n    [K: string]: Row<unknown>\n  },\n> = {\n  [K in keyof TShapeRows & string]: MultiShapeMessage<TShapeRows[K], K>\n}[keyof TShapeRows & string]\n\nexport interface MultiShapeStreamInterface<\n  TShapeRows extends {\n    [K: string]: Row<unknown>\n  },\n> {\n  shapes: { [K in keyof TShapeRows]: ShapeStream<TShapeRows[K]> }\n  checkForUpdatesAfterMs?: number\n\n  subscribe(\n    callback: (\n      messages: MultiShapeMessages<TShapeRows>[]\n    ) => MaybePromise<void>,\n    onError?: (error: FetchError | Error) => void\n  ): () => void\n  unsubscribeAll(): void\n\n  lastSyncedAt(): number | undefined\n  lastSynced(): number\n  isConnected(): boolean\n  isLoading(): boolean\n\n  isUpToDate: boolean\n}\n\n/**\n * A multi-shape stream is a stream that can subscribe to multiple shapes.\n * It ensures that all shapes will receive at least an `up-to-date` message from\n * Electric within the `checkForUpdatesAfterMs` interval.\n *\n * @constructor\n * @param {MultiShapeStreamOptions} options - configure the multi-shape stream\n * @example\n * ```ts\n * const multiShapeStream = new MultiShapeStream({\n *   shapes: {\n *     shape1: {\n *       url: 'http://localhost:3000/v1/shape1',\n *     },\n *     shape2: {\n *       url: 'http://localhost:3000/v1/shape2',\n *     },\n *   },\n * })\n *\n * multiShapeStream.subscribe((msgs) => {\n *   console.log(msgs)\n * })\n *\n * // or with ShapeStream instances\n * const multiShapeStream = new MultiShapeStream({\n *   shapes: {\n *     shape1: new ShapeStream({ url: 'http://localhost:3000/v1/shape1' }),\n *     shape2: new ShapeStream({ url: 'http://localhost:3000/v1/shape2' }),\n *   },\n * })\n * ```\n */\n\nexport class MultiShapeStream<\n  TShapeRows extends {\n    [K: string]: Row<unknown>\n  },\n> implements MultiShapeStreamInterface<TShapeRows>\n{\n  #shapes: { [K in keyof TShapeRows]: ShapeStream<TShapeRows[K]> }\n  #started = false\n  checkForUpdatesAfterMs?: number\n\n  #checkForUpdatesTimeout?: ReturnType<typeof setTimeout> | undefined\n\n  // We keep track of the last lsn of data and up-to-date messages for each shape\n  // so that we can skip checkForUpdates if the lsn of the up-to-date message is\n  // greater than the last lsn of data.\n  #lastDataLsns: { [K in keyof TShapeRows]: bigint }\n  #lastUpToDateLsns: { [K in keyof TShapeRows]: bigint }\n\n  readonly #subscribers = new Map<\n    number,\n    [\n      (messages: MultiShapeMessages<TShapeRows>[]) => MaybePromise<void>,\n      ((error: Error) => void) | undefined,\n    ]\n  >()\n\n  constructor(options: MultiShapeStreamOptions<TShapeRows>) {\n    const {\n      start = true, // By default we start the multi-shape stream\n      checkForUpdatesAfterMs = 100, // Force a check for updates after 100ms\n      shapes,\n    } = options\n    this.checkForUpdatesAfterMs = checkForUpdatesAfterMs\n    this.#shapes = Object.fromEntries(\n      Object.entries(shapes).map(([key, shape]) => [\n        key,\n        shape instanceof ShapeStream\n          ? shape\n          : new ShapeStream<TShapeRows[typeof key]>({\n              ...shape,\n              start: false,\n            }),\n      ])\n    ) as { [K in keyof TShapeRows]: ShapeStream<TShapeRows[K]> }\n    this.#lastDataLsns = Object.fromEntries(\n      Object.entries(shapes).map(([key]) => [key, BigInt(-1)])\n    ) as { [K in keyof TShapeRows]: bigint }\n    this.#lastUpToDateLsns = Object.fromEntries(\n      Object.entries(shapes).map(([key]) => [key, BigInt(-1)])\n    ) as { [K in keyof TShapeRows]: bigint }\n    if (start) this.#start()\n  }\n\n  #start() {\n    if (this.#started) throw new Error(`Cannot start multi-shape stream twice`)\n    for (const [key, shape] of this.#shapeEntries()) {\n      if (shape.hasStarted()) {\n        // The multi-shape stream needs to be started together as a whole, and so we\n        // have to check that a shape is not already started.\n        throw new Error(`Shape ${key} already started`)\n      }\n      shape.subscribe(\n        async (messages) => {\n          // Whats the max lsn of the up-to-date messages?\n          const upToDateLsns = messages\n            .filter(isControlMessage)\n            .map(({ headers }) =>\n              typeof headers.global_last_seen_lsn === `string`\n                ? BigInt(headers.global_last_seen_lsn)\n                : BigInt(0)\n            )\n          if (upToDateLsns.length > 0) {\n            const maxUpToDateLsn = bigIntMax(...upToDateLsns)\n            const lastMaxUpToDateLsn = this.#lastUpToDateLsns[key]\n            if (maxUpToDateLsn > lastMaxUpToDateLsn) {\n              this.#lastUpToDateLsns[key] = maxUpToDateLsn\n            }\n          }\n\n          // Whats the max lsn of the data messages?\n          const dataLsns = messages\n            .filter(isChangeMessage)\n            .map(({ headers }) =>\n              typeof headers.lsn === `string` ? BigInt(headers.lsn) : BigInt(0)\n            )\n          if (dataLsns.length > 0) {\n            const maxDataLsn = bigIntMax(...dataLsns)\n            const lastMaxDataLsn = this.#lastDataLsns[key]\n            if (maxDataLsn > lastMaxDataLsn) {\n              this.#lastDataLsns[key] = maxDataLsn\n            }\n            // There is new data, so we need to schedule a check for updates on\n            // other shapes\n            this.#scheduleCheckForUpdates()\n          }\n\n          // Publish the messages to the multi-shape stream subscribers\n          const multiShapeMessages = messages.map(\n            (message) =>\n              ({\n                ...message,\n                shape: key,\n              }) as MultiShapeMessages<TShapeRows>\n          )\n          await this._publish(multiShapeMessages)\n        },\n        (error) => this.#onError(error)\n      )\n    }\n    this.#started = true\n  }\n\n  #scheduleCheckForUpdates() {\n    this.#checkForUpdatesTimeout ??= setTimeout(() => {\n      this.#checkForUpdates()\n      this.#checkForUpdatesTimeout = undefined\n    }, this.checkForUpdatesAfterMs)\n  }\n\n  async #checkForUpdates() {\n    const maxDataLsn = bigIntMax(...Object.values(this.#lastDataLsns))\n    const refreshPromises = this.#shapeEntries()\n      .filter(([key]) => {\n        // We only need to refresh shapes that have not seen an up-to-date message\n        // lower than the max lsn of the data messages we have received.\n        const lastUpToDateLsn = this.#lastUpToDateLsns[key]\n        return lastUpToDateLsn < maxDataLsn\n      })\n      .map(([_, shape]) => {\n        return shape.forceDisconnectAndRefresh()\n      })\n    await Promise.all(refreshPromises)\n  }\n\n  #onError(error: Error) {\n    // TODO: we probably want to disconnect all shapes here on the first error\n    this.#subscribers.forEach(([_, errorFn]) => {\n      errorFn?.(error)\n    })\n  }\n\n  protected async _publish(\n    messages: MultiShapeMessages<TShapeRows>[]\n  ): Promise<void> {\n    await Promise.all(\n      Array.from(this.#subscribers.values()).map(async ([callback, __]) => {\n        try {\n          await callback(messages)\n        } catch (err) {\n          queueMicrotask(() => {\n            throw err\n          })\n        }\n      })\n    )\n  }\n\n  /**\n   * Returns an array of the shape entries.\n   * Ensures that the shape entries are typed, as `Object.entries`\n   * will not type the entries correctly.\n   */\n  #shapeEntries() {\n    return Object.entries(this.#shapes) as [\n      keyof TShapeRows & string,\n      ShapeStream<TShapeRows[string]>,\n    ][]\n  }\n\n  /**\n   * The ShapeStreams that are being subscribed to.\n   */\n  get shapes() {\n    return this.#shapes\n  }\n\n  subscribe(\n    callback: (\n      messages: MultiShapeMessages<TShapeRows>[]\n    ) => MaybePromise<void>,\n    onError?: (error: FetchError | Error) => void\n  ) {\n    const subscriptionId = Math.random()\n\n    this.#subscribers.set(subscriptionId, [callback, onError])\n    if (!this.#started) this.#start()\n\n    return () => {\n      this.#subscribers.delete(subscriptionId)\n    }\n  }\n\n  unsubscribeAll(): void {\n    this.#subscribers.clear()\n  }\n\n  /** Unix time at which we last synced. Undefined when `isLoading` is true. */\n  lastSyncedAt(): number | undefined {\n    // Min of all the lastSyncedAt values\n    return Math.min(\n      ...this.#shapeEntries().map(\n        ([_, shape]) => shape.lastSyncedAt() ?? Infinity\n      )\n    )\n  }\n\n  /** Time elapsed since last sync (in ms). Infinity if we did not yet sync. */\n  lastSynced(): number {\n    const lastSyncedAt = this.lastSyncedAt()\n    if (lastSyncedAt === undefined) return Infinity\n    return Date.now() - lastSyncedAt\n  }\n\n  /** Indicates if we are connected to the Electric sync service. */\n  isConnected(): boolean {\n    return this.#shapeEntries().every(([_, shape]) => shape.isConnected())\n  }\n\n  /** True during initial fetch. False afterwise. */\n  isLoading(): boolean {\n    return this.#shapeEntries().some(([_, shape]) => shape.isLoading())\n  }\n\n  get isUpToDate() {\n    return this.#shapeEntries().every(([_, shape]) => shape.isUpToDate)\n  }\n}\n\n/**\n * A transactional multi-shape stream is a multi-shape stream that emits the\n * messages in transactional batches, ensuring that all shapes will receive\n * at least an `up-to-date` message from Electric within the `checkForUpdatesAfterMs`\n * interval.\n * It uses the `lsn` metadata to infer transaction boundaries, and the `op_position`\n * metadata to sort the messages within a transaction.\n *\n * @constructor\n * @param {MultiShapeStreamOptions} options - configure the multi-shape stream\n * @example\n * ```ts\n * const transactionalMultiShapeStream = new TransactionalMultiShapeStream({\n *   shapes: {\n *     shape1: {\n *       url: 'http://localhost:3000/v1/shape1',\n *     },\n *     shape2: {\n *       url: 'http://localhost:3000/v1/shape2',\n *     },\n *   },\n * })\n *\n * transactionalMultiShapeStream.subscribe((msgs) => {\n *   console.log(msgs)\n * })\n *\n * // or with ShapeStream instances\n * const transactionalMultiShapeStream = new TransactionalMultiShapeStream({\n *   shapes: {\n *     shape1: new ShapeStream({ url: 'http://localhost:3000/v1/shape1' }),\n *     shape2: new ShapeStream({ url: 'http://localhost:3000/v1/shape2' }),\n *   },\n * })\n * ```\n */\n\nexport class TransactionalMultiShapeStream<\n  TShapeRows extends {\n    [K: string]: Row<unknown>\n  },\n> extends MultiShapeStream<TShapeRows> {\n  #changeMessages = new Map<bigint, MultiShapeMessage<Row<unknown>, string>[]>()\n  #completeLsns: {\n    [K in keyof TShapeRows]: bigint\n  }\n\n  constructor(options: MultiShapeStreamOptions<TShapeRows>) {\n    super(options)\n    this.#completeLsns = Object.fromEntries(\n      Object.entries(options.shapes).map(([key]) => [key, BigInt(-1)])\n    ) as { [K in keyof TShapeRows]: bigint }\n  }\n\n  #getLowestCompleteLsn() {\n    return bigIntMin(...Object.values(this.#completeLsns))\n  }\n\n  protected async _publish(\n    messages: MultiShapeMessages<TShapeRows>[]\n  ): Promise<void> {\n    this.#accumulate(messages)\n    const lowestCompleteLsn = this.#getLowestCompleteLsn()\n    const lsnsToPublish = [...this.#changeMessages.keys()].filter(\n      (lsn) => lsn <= lowestCompleteLsn\n    )\n    const messagesToPublish = lsnsToPublish\n      .sort((a, b) => bigIntCompare(a, b))\n      .map((lsn) =>\n        this.#changeMessages.get(lsn)?.sort((a, b) => {\n          const { headers: aHeaders } = a\n          const { headers: bHeaders } = b\n          if (\n            typeof aHeaders.op_position !== `number` ||\n            typeof bHeaders.op_position !== `number`\n          ) {\n            return 0 // op_position is not present on the snapshot message\n          }\n          return aHeaders.op_position - bHeaders.op_position\n        })\n      )\n      .filter((messages) => messages !== undefined)\n      .flat() as MultiShapeMessages<TShapeRows>[]\n    lsnsToPublish.forEach((lsn) => {\n      this.#changeMessages.delete(lsn)\n    })\n    if (messagesToPublish.length > 0) {\n      await super._publish(messagesToPublish)\n    }\n  }\n\n  #accumulate(messages: MultiShapeMessages<TShapeRows>[]) {\n    const isUpToDate = this.isUpToDate\n    messages.forEach((message) => {\n      const { shape, headers } = message\n      if (isChangeMessage(message)) {\n        // The snapshot message does not have an lsn, so we use 0\n        const lsn =\n          typeof headers.lsn === `string` ? BigInt(headers.lsn) : BigInt(0)\n        if (!this.#changeMessages.has(lsn)) {\n          this.#changeMessages.set(lsn, [])\n        }\n        this.#changeMessages.get(lsn)?.push(message)\n        if (\n          isUpToDate && // All shapes must be up to date\n          typeof headers.last === `boolean` &&\n          headers.last === true\n        ) {\n          this.#completeLsns[shape] = bigIntMax(this.#completeLsns[shape], lsn)\n        }\n      } else if (isControlMessage(message)) {\n        if (headers.control === `up-to-date`) {\n          if (typeof headers.global_last_seen_lsn !== `string`) {\n            throw new Error(`global_last_seen_lsn is not a number`)\n          }\n          this.#completeLsns[shape] = bigIntMax(\n            this.#completeLsns[shape],\n            BigInt(headers.global_last_seen_lsn)\n          )\n        }\n      }\n    })\n  }\n}\n"],"mappings":"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","names":["isChangeMessage","matchStream","stream","operations","matchFn","timeout","resolve","reject","unsubscribe","messages","message","msg","operation","finish","timeoutId","matchBy","column","value","bigIntMax","args","m","e","bigIntMin","bigIntCompare","a","b","ShapeStream","isChangeMessage","isControlMessage","_shapes","_started","_checkForUpdatesTimeout","_lastDataLsns","_lastUpToDateLsns","_subscribers","_MultiShapeStream_instances","start_fn","scheduleCheckForUpdates_fn","checkForUpdates_fn","onError_fn","shapeEntries_fn","MultiShapeStream","options","__privateAdd","start","checkForUpdatesAfterMs","shapes","__privateSet","key","shape","ShapeStream","__spreadProps","__spreadValues","__privateMethod","messages","__async","__privateGet","_0","callback","__","err","onError","subscriptionId","_","_a","lastSyncedAt","upToDateLsns","isControlMessage","headers","maxUpToDateLsn","bigIntMax","lastMaxUpToDateLsn","dataLsns","isChangeMessage","maxDataLsn","lastMaxDataLsn","multiShapeMessages","message","error","refreshPromises","errorFn","_changeMessages","_completeLsns","_TransactionalMultiShapeStream_instances","getLowestCompleteLsn_fn","accumulate_fn","_TransactionalMultiShapeStream","lowestCompleteLsn","lsnsToPublish","lsn","messagesToPublish","a","b","bigIntCompare","aHeaders","bHeaders","__superGet","bigIntMin","isUpToDate","TransactionalMultiShapeStream"]}